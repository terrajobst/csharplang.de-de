---
ms.openlocfilehash: ecdad8c863d0695bc901e4d96d9ca3decbc248eb
ms.sourcegitcommit: 94a3d151c438d34ede1d99de9eb4ebdc07ba4699
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 04/25/2019
ms.locfileid: "79483595"
---
# <a name="nullable-reference-types-in-c"></a><span data-ttu-id="ce9ca-101">Verweis Typen, die NULL-Werte zulassenC#</span><span class="sxs-lookup"><span data-stu-id="ce9ca-101">Nullable reference types in C#</span></span> #

<span data-ttu-id="ce9ca-102">Ziel dieses Features ist Folgendes:</span><span class="sxs-lookup"><span data-stu-id="ce9ca-102">The goal of this feature is to:</span></span>

* <span data-ttu-id="ce9ca-103">Ermöglicht es Entwicklern, auszudrücken, ob eine Variable, ein Parameter oder ein Ergebnis eines Verweis Typs NULL sein soll oder nicht.</span><span class="sxs-lookup"><span data-stu-id="ce9ca-103">Allow developers to express whether a variable, parameter or result of a reference type is intended to be null or not.</span></span>
* <span data-ttu-id="ce9ca-104">Geben Sie Warnungen an, wenn derartige Variablen, Parameter und Ergebnisse nicht gemäß dieser Absicht verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="ce9ca-104">Provide warnings when such variables, parameters and results are not used according to that intent.</span></span>

## <a name="expression-of-intent"></a><span data-ttu-id="ce9ca-105">Ausdruck der Absicht</span><span class="sxs-lookup"><span data-stu-id="ce9ca-105">Expression of intent</span></span>

<span data-ttu-id="ce9ca-106">Die Sprache enthält bereits die `T?` Syntax für Werttypen.</span><span class="sxs-lookup"><span data-stu-id="ce9ca-106">The language already contains the `T?` syntax for value types.</span></span> <span data-ttu-id="ce9ca-107">Es ist einfach, diese Syntax auf Verweis Typen auszuweiten.</span><span class="sxs-lookup"><span data-stu-id="ce9ca-107">It is straightforward to extend this syntax to reference types.</span></span>

<span data-ttu-id="ce9ca-108">Es wird davon ausgegangen, dass die Absicht eines nicht verzierten Verweis Typs `T` ist, dass er ungleich NULL ist.</span><span class="sxs-lookup"><span data-stu-id="ce9ca-108">It is assumed that the intent of an unadorned reference type `T` is for it to be non-null.</span></span>

## <a name="checking-of-nullable-references"></a><span data-ttu-id="ce9ca-109">Überprüfen von verweisen, die NULL zulassen</span><span class="sxs-lookup"><span data-stu-id="ce9ca-109">Checking of nullable references</span></span>

<span data-ttu-id="ce9ca-110">Eine Fluss Analyse verfolgt Verweis Variablen, die NULL-Werte zulassen.</span><span class="sxs-lookup"><span data-stu-id="ce9ca-110">A flow analysis tracks nullable reference variables.</span></span> <span data-ttu-id="ce9ca-111">Wenn die Analyse nicht NULL ist (z. b. nach einer Überprüfung oder einer Zuweisung), wird Ihr Wert als nicht-NULL-Verweis betrachtet.</span><span class="sxs-lookup"><span data-stu-id="ce9ca-111">Where the analysis deems that they would not be null (e.g. after a check or an assignment), their value will be considered a non-null reference.</span></span>

<span data-ttu-id="ce9ca-112">Ein Verweis, der NULL-Werte zulässt, kann mit dem postfix-`x!` Operator (dem "dammit"-Operator) auch explizit als ungleich NULL behandelt werden, wenn die Fluss Analyse keine nicht-NULL-Situation festlegen kann, die der Entwickler kennt.</span><span class="sxs-lookup"><span data-stu-id="ce9ca-112">A nullable reference can also explicitly be treated as non-null with the postfix `x!` operator (the "dammit" operator), for when flow analysis cannot establish a non-null situation that the developer knows is there.</span></span>

<span data-ttu-id="ce9ca-113">Andernfalls wird eine Warnung ausgegeben, wenn ein Verweis, der NULL-Werte zulässt, dereferenziert wird oder in einen nicht-NULL-Typ konvertiert wird.</span><span class="sxs-lookup"><span data-stu-id="ce9ca-113">Otherwise, a warning is given if a nullable reference is dereferenced, or is converted to a non-null type.</span></span>

<span data-ttu-id="ce9ca-114">Beim Umrechnen von `S[]` in `T?[]` und von `S?[]` in `T[]`wird eine Warnung ausgegeben.</span><span class="sxs-lookup"><span data-stu-id="ce9ca-114">A warning is given when converting from `S[]` to `T?[]` and from `S?[]` to `T[]`.</span></span>

<span data-ttu-id="ce9ca-115">Beim Umrechnen von `C<S>` in `C<T?>` wird eine Warnung ausgegeben, es sei denn, der Typparameter ist kovariant (`out`), und bei der Umstellung von `C<S?>` in `C<T>`, außer wenn der Typparameter kontra Variant (`in`) ist.</span><span class="sxs-lookup"><span data-stu-id="ce9ca-115">A warning is given when converting from `C<S>` to `C<T?>` except when the type parameter is covariant (`out`), and when converting from `C<S?>` to `C<T>` except when the type parameter is contravariant (`in`).</span></span>

<span data-ttu-id="ce9ca-116">Beim `C<T?>` wird eine Warnung ausgegeben, wenn der Typparameter Einschränkungen ungleich NULL aufweist.</span><span class="sxs-lookup"><span data-stu-id="ce9ca-116">A warning is given on `C<T?>` if the type parameter has non-null constraints.</span></span> 

## <a name="checking-of-non-null-references"></a><span data-ttu-id="ce9ca-117">Überprüfen von nicht-NULL-verweisen</span><span class="sxs-lookup"><span data-stu-id="ce9ca-117">Checking of non-null references</span></span>

<span data-ttu-id="ce9ca-118">Eine Warnung wird ausgegeben, wenn ein NULL-wahrsten einer Variablen ungleich NULL zugewiesen oder als nicht-NULL-Parameter übergeben wird.</span><span class="sxs-lookup"><span data-stu-id="ce9ca-118">A warning is given if a null literal is assigned to a non-null variable or passed as a non-null parameter.</span></span>

<span data-ttu-id="ce9ca-119">Eine Warnung wird auch ausgegeben, wenn ein Konstruktor nicht NULL-Verweis Felder explizit initialisiert.</span><span class="sxs-lookup"><span data-stu-id="ce9ca-119">A warning is also given if a constructor does not explicitly initialize non-null reference fields.</span></span>

<span data-ttu-id="ce9ca-120">Wir können nicht ausreichend nachverfolgen, ob alle Elemente eines Arrays von verweisen, die nicht NULL sind, initialisiert werden.</span><span class="sxs-lookup"><span data-stu-id="ce9ca-120">We cannot adequately track that all elements of an array of non-null references are initialized.</span></span> <span data-ttu-id="ce9ca-121">Wir könnten jedoch eine Warnung ausgeben, wenn kein Element eines neu erstellten Arrays zugewiesen wird, bevor das Array gelesen oder weitergereicht wird.</span><span class="sxs-lookup"><span data-stu-id="ce9ca-121">However, we could issue a warning if no element of a newly created array is assigned to before the array is read from or passed on.</span></span> <span data-ttu-id="ce9ca-122">Dies kann den häufigen Fall verarbeiten, ohne zu stark zu sein.</span><span class="sxs-lookup"><span data-stu-id="ce9ca-122">That might handle the common case without being too noisy.</span></span>

<span data-ttu-id="ce9ca-123">Wir müssen entscheiden, ob `default(T)` eine Warnung generiert oder einfach als Typ `T?`behandelt wird.</span><span class="sxs-lookup"><span data-stu-id="ce9ca-123">We need to decide whether `default(T)` generates a warning, or is simply treated as being of the type `T?`.</span></span>

## <a name="metadata-representation"></a><span data-ttu-id="ce9ca-124">Metadatendarstellung</span><span class="sxs-lookup"><span data-stu-id="ce9ca-124">Metadata representation</span></span>

<span data-ttu-id="ce9ca-125">Zusatzelemente der NULL-Zulässigkeit sollten in Metadaten als Attribute dargestellt werden.</span><span class="sxs-lookup"><span data-stu-id="ce9ca-125">Nullability adornments should be represented in metadata as attributes.</span></span> <span data-ttu-id="ce9ca-126">Dies bedeutet, dass downlevelcompiler diese ignorieren.</span><span class="sxs-lookup"><span data-stu-id="ce9ca-126">This means that downlevel compilers will ignore them.</span></span>

<span data-ttu-id="ce9ca-127">Wir müssen entscheiden, ob nur NULL-Werte zulässig sind, oder es gibt Aufschluss darüber, ob ein nicht-NULL-Element in der Assembly "on" war.</span><span class="sxs-lookup"><span data-stu-id="ce9ca-127">We need to decide if only nullable annotations are included, or there's also some indication of whether non-null was "on" in the assembly.</span></span>

## <a name="generics"></a><span data-ttu-id="ce9ca-128">Generika</span><span class="sxs-lookup"><span data-stu-id="ce9ca-128">Generics</span></span>

<span data-ttu-id="ce9ca-129">Wenn ein Typparameter `T` keine NULL-Werte zulässt, wird er innerhalb seines Gültigkeits Bereichs als nicht auf NULL festlegbar behandelt.</span><span class="sxs-lookup"><span data-stu-id="ce9ca-129">If a type parameter `T` has non-nullable constraints, it is treated as non-nullable within its scope.</span></span>

<span data-ttu-id="ce9ca-130">Wenn ein Typparameter nicht eingeschränkt ist oder nur NULL-Werte zulässt, ist die Situation etwas komplexer: Dies bedeutet, dass das entsprechende Typargument *entweder* NULL-Werte zulässt oder keine NULL-Werte zulässt.</span><span class="sxs-lookup"><span data-stu-id="ce9ca-130">If a type parameter is unconstrained or has only nullable constraints, the situation is a little more complex: this means that the corresponding type argument could be *either* nullable or non-nullable.</span></span> <span data-ttu-id="ce9ca-131">Die in dieser Situation sichere Aufgabe besteht darin, den Typparameter *sowohl* als Werte zulässt als auch als nicht-NULL-Werte zu behandeln, und es werden Warnungen ausgegeben, wenn eine Verletzung auftritt.</span><span class="sxs-lookup"><span data-stu-id="ce9ca-131">The safe thing to do in that situation is to treat the type parameter as *both* nullable and non-nullable, giving warnings when either is violated.</span></span> 

<span data-ttu-id="ce9ca-132">Es lohnt sich zu erwägen, ob explizite Verweis Einschränkungen auf NULL-Werte zulässig sind.</span><span class="sxs-lookup"><span data-stu-id="ce9ca-132">It is worth considering whether explicit nullable reference constraints should be allowed.</span></span> <span data-ttu-id="ce9ca-133">Beachten Sie jedoch, dass es nicht möglich ist, Verweis Typen, die NULL-Werte zulassen, *implizit* in bestimmten Fällen eingeschränkt zu werden (geerbte Einschränkungen).</span><span class="sxs-lookup"><span data-stu-id="ce9ca-133">Note, however, that we cannot avoid having nullable reference types *implicitly* be constraints in certain cases (inherited constraints).</span></span>

<span data-ttu-id="ce9ca-134">Die `class` Einschränkung ist nicht NULL.</span><span class="sxs-lookup"><span data-stu-id="ce9ca-134">The `class` constraint is non-null.</span></span> <span data-ttu-id="ce9ca-135">Wir können berücksichtigen, ob `class?` eine gültige Einschränkung, die NULL-Werte zulässt, als Verweis Typen, die NULL-Werte zulassen, sein sollten.</span><span class="sxs-lookup"><span data-stu-id="ce9ca-135">We can consider whether `class?` should be a valid nullable constraint denoting "nullable reference type".</span></span>

## <a name="type-inference"></a><span data-ttu-id="ce9ca-136">Typrückschluss</span><span class="sxs-lookup"><span data-stu-id="ce9ca-136">Type inference</span></span>

<span data-ttu-id="ce9ca-137">Wenn beim Typrückschluss ein Mitwirkender Typ ein Verweistyp ist, der NULL-Werte zulässt, sollte der resultierende Typ NULL-Werte zulassen.</span><span class="sxs-lookup"><span data-stu-id="ce9ca-137">In type inference, if a contributing type is a nullable reference type, the resulting type should be nullable.</span></span> <span data-ttu-id="ce9ca-138">Das heißt, dass NULL-Werte weitergegeben werden.</span><span class="sxs-lookup"><span data-stu-id="ce9ca-138">In other words, nullness is propagated.</span></span>

<span data-ttu-id="ce9ca-139">Wir sollten berücksichtigen, ob der `null` Literale als teilnehmende Ausdruck NULL sein sollte.</span><span class="sxs-lookup"><span data-stu-id="ce9ca-139">We should consider whether the `null` literal as a participating expression should contribute nullness.</span></span> <span data-ttu-id="ce9ca-140">Dies ist heute nicht der Fall: für Werttypen führt dies zu einem Fehler, während für Verweis Typen der NULL-Wert erfolgreich in den Plain-Typ konvertiert wird.</span><span class="sxs-lookup"><span data-stu-id="ce9ca-140">It doesn't today: for value types it leads to an error, whereas for reference types the null successfully converts to the plain type.</span></span> 

```csharp
string? n = "world";
var x = b ? "Hello" : n; // string?
var y = b ? "Hello" : null; // string? or error
var z = b ? 7 : null; // Error today, could be int?
```

## <a name="breaking-changes"></a><span data-ttu-id="ce9ca-141">Aktuelle Änderungen</span><span class="sxs-lookup"><span data-stu-id="ce9ca-141">Breaking changes</span></span>

<span data-ttu-id="ce9ca-142">Warnungen ungleich NULL sind eine offensichtliche Breaking Change für vorhandenen Code und sollten mit einem Opt-in-Mechanismus einhergehen.</span><span class="sxs-lookup"><span data-stu-id="ce9ca-142">Non-null warnings are an obvious breaking change on existing code, and should be accompanied with an opt-in mechanism.</span></span>

<span data-ttu-id="ce9ca-143">Weniger offensichtlich sind Warnungen von Typen, die NULL-Werte zulassen (wie oben beschrieben), eine Breaking Change auf vorhandenem Code in bestimmten Szenarien, in denen die NULL-Zulässigkeit implizit ist:</span><span class="sxs-lookup"><span data-stu-id="ce9ca-143">Less obviously, warnings from nullable types (as described above) are a breaking change on existing code in certain scenarios where the nullability is implicit:</span></span>

* <span data-ttu-id="ce9ca-144">Nicht eingeschränkte Typparameter werden als implizit NULL-Werte behandelt, sodass Sie `object` oder beim Zugriff auf z. b. `ToString` Warnungen erhalten.</span><span class="sxs-lookup"><span data-stu-id="ce9ca-144">Unconstrained type parameters will be treated as implicitly nullable, so assigning them to `object` or accessing e.g. `ToString` will yield warnings.</span></span>
* <span data-ttu-id="ce9ca-145">Wenn der Typrückschluss NULL-Werte von `null` Ausdrücken ableitet, liefert vorhandener Code in manchen Fällen NULL-Werte und nicht auf NULL festleg Bare Typen, was zu neuen Warnungen führen kann.</span><span class="sxs-lookup"><span data-stu-id="ce9ca-145">if type inference infers nullness from `null` expressions, then existing code will sometimes yield nullable rather than non-nullable types, which can lead to new warnings.</span></span>

<span data-ttu-id="ce9ca-146">Daher müssen auf NULL festleg Bare Warnungen ebenfalls optional sein.</span><span class="sxs-lookup"><span data-stu-id="ce9ca-146">So nullable warnings also need to be optional</span></span>

<span data-ttu-id="ce9ca-147">Zum Schluss ist das Hinzufügen von Anmerkungen zu einer vorhandenen API eine Breaking Change für Benutzer, die sich für Warnungen entschieden haben, wenn Sie die Bibliothek aktualisieren.</span><span class="sxs-lookup"><span data-stu-id="ce9ca-147">Finally, adding annotations to an existing API will be a breaking change to users who have opted in to warnings, when they upgrade the library.</span></span> <span data-ttu-id="ce9ca-148">Dies hat auch die Möglichkeit, sich zu entscheiden. "Ich möchte die Fehlerbehebungen, aber ich bin nicht bereit, mit ihren neuen Anmerkungen umzugehen"</span><span class="sxs-lookup"><span data-stu-id="ce9ca-148">This, too, merits the ability to opt in or out. "I want the bug fixes, but I am not ready to deal with their new annotations"</span></span>

<span data-ttu-id="ce9ca-149">Zusammenfassend müssen Sie in der Lage sein, Folgendes zu abonnieren:</span><span class="sxs-lookup"><span data-stu-id="ce9ca-149">In summary, you need to be able to opt in/out of:</span></span>
* <span data-ttu-id="ce9ca-150">NULL-Werte zulassen</span><span class="sxs-lookup"><span data-stu-id="ce9ca-150">Nullable warnings</span></span>
* <span data-ttu-id="ce9ca-151">Nicht-NULL-Warnungen</span><span class="sxs-lookup"><span data-stu-id="ce9ca-151">Non-null warnings</span></span>
* <span data-ttu-id="ce9ca-152">Warnungen von Anmerkungen in anderen Dateien</span><span class="sxs-lookup"><span data-stu-id="ce9ca-152">Warnings from annotations in other files</span></span>

<span data-ttu-id="ce9ca-153">Die Granularität der Zustimmung deutet auf ein Analyse ähnliches Modell hin, bei dem sich Teil Striche mit Pragmas anmelden können, und Schweregrade können vom Benutzer ausgewählt werden.</span><span class="sxs-lookup"><span data-stu-id="ce9ca-153">The granularity of the opt-in suggests an analyzer-like model, where swaths of code can opt in and out with pragmas and severity levels can be chosen by the user.</span></span> <span data-ttu-id="ce9ca-154">Außerdem kann es sein, dass pro Bibliothek-Optionen ("die Anmerkungen von JSON.net ignorieren, bis ich bereit für den Umgang mit dem Fallout sind") möglicherweise im Code als Attribute ausgedrückt werden kann.</span><span class="sxs-lookup"><span data-stu-id="ce9ca-154">Additionally, per-library options ("ignore the annotations from JSON.NET until I'm ready to deal with the fall out") may be expressible in code as attributes.</span></span>

<span data-ttu-id="ce9ca-155">Der Entwurf der Opt-in-/Übergangs--Funktion ist entscheidend für den Erfolg und die Nützlichkeit dieses Features.</span><span class="sxs-lookup"><span data-stu-id="ce9ca-155">The design of the opt-in/transition experience is crucial to the success and usefulness of this feature.</span></span> <span data-ttu-id="ce9ca-156">Wir müssen Folgendes sicherstellen:</span><span class="sxs-lookup"><span data-stu-id="ce9ca-156">We need to make sure that:</span></span>

* <span data-ttu-id="ce9ca-157">Benutzer können die Überprüfung der NULL-Zulässigkeit nach und nach nach Bedarf übernehmen</span><span class="sxs-lookup"><span data-stu-id="ce9ca-157">Users can adopt nullability checking gradually as they want to</span></span>
* <span data-ttu-id="ce9ca-158">Bibliotheks Autoren können NULL-Zulässigkeit-Anmerkungen hinzufügen</span><span class="sxs-lookup"><span data-stu-id="ce9ca-158">Library authors can add nullability annotations without fear of breaking customers</span></span>
* <span data-ttu-id="ce9ca-159">Obwohl dies nicht der Fall ist, ist "Konfigurations Alptraum" nicht sinnvoll.</span><span class="sxs-lookup"><span data-stu-id="ce9ca-159">Despite these, there is not a sense of "configuration nightmare"</span></span>

## <a name="tweaks"></a><span data-ttu-id="ce9ca-160">Anpassungen</span><span class="sxs-lookup"><span data-stu-id="ce9ca-160">Tweaks</span></span>

<span data-ttu-id="ce9ca-161">Wir könnten die `?` Anmerkungen nicht für lokale Variablen verwenden, sondern nur feststellen, ob Sie in Übereinstimmung mit den Ihnen zugewiesenen Informationen verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="ce9ca-161">We could consider not using the `?` annotations on locals, but just observing whether they are used in accordance with what gets assigned to them.</span></span> <span data-ttu-id="ce9ca-162">Ich bevorzuge dies nicht. Ich denke, wir sollten den Benutzern die Absicht überlassen, ihre Absicht auszudrücken.</span><span class="sxs-lookup"><span data-stu-id="ce9ca-162">I don't favor this; I think we should uniformly let people express their intent.</span></span>

<span data-ttu-id="ce9ca-163">Wir könnten eine kurz`T! x` zu Parametern in Erwägung nehmen, die automatisch eine NULL-Lauf Zeit Überprüfung generiert.</span><span class="sxs-lookup"><span data-stu-id="ce9ca-163">We could consider a shorthand `T! x` on parameters, that auto-generates a runtime null check.</span></span>

<span data-ttu-id="ce9ca-164">Bestimmte Muster bei generischen Typen, wie z. b. `FirstOrDefault` oder `TryGet`, haben etwas merkwürdige Verhalten mit nicht auf NULL festleg baren Typargumenten, da Sie in bestimmten Situationen explizit Standardwerte ergeben.</span><span class="sxs-lookup"><span data-stu-id="ce9ca-164">Certain patterns on generic types, such as `FirstOrDefault` or `TryGet`, have slightly weird behavior with non-nullable type arguments, because they explicitly yield default values in certain situations.</span></span> <span data-ttu-id="ce9ca-165">Wir könnten versuchen, das Typsystem zu unterstützen, um diese bessere Anpassung zu ermöglichen.</span><span class="sxs-lookup"><span data-stu-id="ce9ca-165">We could try to nuance the type system to accommodate these better.</span></span> <span data-ttu-id="ce9ca-166">Beispielsweise können wir `?` auf nicht eingeschränkten Typparametern zulassen, obwohl das Typargument bereits NULL-Werte zulassen kann.</span><span class="sxs-lookup"><span data-stu-id="ce9ca-166">For instance, we could allow `?` on unconstrained type parameters, even though the type argument could already be nullable.</span></span> <span data-ttu-id="ce9ca-167">Ich bin mir sicher, dass es Wert ist, und es führt zu einer Bedeutung, die sich auf die Interaktion mit auf NULL festleg baren *Werttypen* bezieht.</span><span class="sxs-lookup"><span data-stu-id="ce9ca-167">I doubt that it is worth it, and it leads to weirdness related to interaction with nullable *value* types.</span></span> 

## <a name="nullable-value-types"></a><span data-ttu-id="ce9ca-168">Auf NULL festlegbare Werttypen</span><span class="sxs-lookup"><span data-stu-id="ce9ca-168">Nullable value types</span></span>

<span data-ttu-id="ce9ca-169">Wir könnten auch einige der obigen Semantik für Werttypen, die NULL-Werte zulassen, in Erwägung gezogen.</span><span class="sxs-lookup"><span data-stu-id="ce9ca-169">We could consider adopting some of the above semantics for nullable value types as well.</span></span>

<span data-ttu-id="ce9ca-170">Wir haben bereits den Typrückschluss erwähnt, bei dem wir `int?` aus `(7, null)`ableiten konnten, anstatt nur einen Fehler zu geben.</span><span class="sxs-lookup"><span data-stu-id="ce9ca-170">We already mentioned type inference, where we could infer `int?` from `(7, null)`, instead of just giving an error.</span></span>

<span data-ttu-id="ce9ca-171">Eine weitere Möglichkeit besteht darin, die Fluss Analyse auf Werte zulässt-Werttypen anzuwenden.</span><span class="sxs-lookup"><span data-stu-id="ce9ca-171">Another opportunity is to apply the flow analysis to nullable value types.</span></span> <span data-ttu-id="ce9ca-172">Wenn Sie als ungleich Null angesehen werden, können wir die Verwendung von als nicht auf NULL festleg baren Typ auf bestimmte Weise zulassen (z. b. Element Zugriff).</span><span class="sxs-lookup"><span data-stu-id="ce9ca-172">When they are deemed non-null, we could actually allow using as the non-nullable type in certain ways (e.g. member access).</span></span> <span data-ttu-id="ce9ca-173">Wir müssen nur darauf achten, dass die Dinge, die Sie *bereits* für einen Werte zulässt-Werttyp ausführen können, für die Back-Kompatibilitäts-Gründe bevorzugt werden.</span><span class="sxs-lookup"><span data-stu-id="ce9ca-173">We just have to be careful that the things that you can *already* do on a nullable value type will be preferred, for back compat reasons.</span></span>
