---
ms.openlocfilehash: f238a711e710bbac7f5b7400fa938bd85dec00c6
ms.sourcegitcommit: 5278336b61519956240a6f7d83bcb4322019e032
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 03/10/2020
ms.locfileid: "79484141"
---
# <a name="support-for--and--on-tuple-types"></a><span data-ttu-id="96d6a-101">Unterstützung für = = und! = für Tupeltypen</span><span class="sxs-lookup"><span data-stu-id="96d6a-101">Support for == and != on tuple types</span></span>

<span data-ttu-id="96d6a-102">Lassen Sie Ausdrücke `t1 == t2`, in denen `t1` und `t2` Tupeltypen mit gleicher Kardinalität sind, und Werten Sie Sie ungefähr wie `temp1.Item1 == temp2.Item1 && temp1.Item2 == temp2.Item2` aus (vorausgesetzt `var temp1 = t1; var temp2 = t2;`).</span><span class="sxs-lookup"><span data-stu-id="96d6a-102">Allow expressions `t1 == t2` where `t1` and `t2` are tuple or nullable tuple types of same cardinality, and evaluate them roughly as `temp1.Item1 == temp2.Item1 && temp1.Item2 == temp2.Item2` (assuming `var temp1 = t1; var temp2 = t2;`).</span></span>

<span data-ttu-id="96d6a-103">Umgekehrt würde es `t1 != t2` ermöglichen und es als `temp1.Item1 != temp2.Item1 || temp1.Item2 != temp2.Item2`auswerten.</span><span class="sxs-lookup"><span data-stu-id="96d6a-103">Conversely it would allow `t1 != t2` and evaluate it as `temp1.Item1 != temp2.Item1 || temp1.Item2 != temp2.Item2`.</span></span>

<span data-ttu-id="96d6a-104">In Fällen, in denen Nullwerte zulässig sind, werden zusätzliche Überprüfungen für `temp1.HasValue` und `temp2.HasValue` verwendet.</span><span class="sxs-lookup"><span data-stu-id="96d6a-104">In the nullable case, additional checks for `temp1.HasValue` and `temp2.HasValue` are used.</span></span> <span data-ttu-id="96d6a-105">Beispielsweise wird `nullableT1 == nullableT2` als `temp1.HasValue == temp2.HasValue ? (temp1.HasValue ? ... : true) : false`ausgewertet.</span><span class="sxs-lookup"><span data-stu-id="96d6a-105">For instance, `nullableT1 == nullableT2` evaluates as `temp1.HasValue == temp2.HasValue ? (temp1.HasValue ? ... : true) : false`.</span></span>

<span data-ttu-id="96d6a-106">Wenn ein Element weiser Vergleich ein nicht-boolescher Ergebnis zurückgibt (z. b. Wenn ein nicht boolescher benutzerdefinierter `operator ==` oder `operator !=` verwendet wird, oder in einem dynamischen Vergleich), wird dieses Ergebnis entweder in `bool` konvertiert oder durch `operator true` oder `operator false` ausgeführt, um eine `bool`zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="96d6a-106">When an element-wise comparison returns a non-bool result (for instance, when a non-bool user-defined `operator ==` or `operator !=` is used, or in a dynamic comparison), then that result will be either converted to `bool` or run through `operator true` or `operator false` to get a `bool`.</span></span> <span data-ttu-id="96d6a-107">Beim tupelvergleich wird immer ein `bool`zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="96d6a-107">The tuple comparison always ends up returning a `bool`.</span></span>

<span data-ttu-id="96d6a-108">Ab C# 7,2 erzeugt dieser Code einen Fehler (`error CS0019: Operator '==' cannot be applied to operands of type '(...)' and '(...)'`), es sei denn, es gibt eine benutzerdefinierte `operator==`.</span><span class="sxs-lookup"><span data-stu-id="96d6a-108">As of C# 7.2, such code produces an error (`error CS0019: Operator '==' cannot be applied to operands of type '(...)' and '(...)'`), unless there is a user-defined `operator==`.</span></span>

## <a name="details"></a><span data-ttu-id="96d6a-109">Details</span><span class="sxs-lookup"><span data-stu-id="96d6a-109">Details</span></span>

<span data-ttu-id="96d6a-110">Wenn Sie den `==`-Operator (oder `!=`) binden, sind die vorhandenen Regeln: (1) dynamischer Fall, (2) Überladungs Auflösung und (3) fehlgeschlagen.</span><span class="sxs-lookup"><span data-stu-id="96d6a-110">When binding the `==` (or `!=`) operator, the existing rules are: (1) dynamic case, (2) overload resolution, and (3) fail.</span></span>
<span data-ttu-id="96d6a-111">Dieses Angebot fügt einen tupelfall zwischen (1) und (2) hinzu: Wenn beide Operanden eines Vergleichs Operators Tupel sind (über Tupeltypen verfügen oder tupelliterale sind) und eine passende Kardinalität aufweisen, wird der Vergleich Element Weise ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="96d6a-111">This proposal adds a tuple case between (1) and (2): if both operands of a comparison operator are tuples (have tuple types or are tuple literals) and have matching cardinality, then the comparison is performed element-wise.</span></span> <span data-ttu-id="96d6a-112">Diese tupelgleichheit wird auch auf auf NULL festleg Bare Tupel angehoben.</span><span class="sxs-lookup"><span data-stu-id="96d6a-112">This tuple equality is also lifted onto nullable tuples.</span></span>

<span data-ttu-id="96d6a-113">Beide Operanden (und im Fall von tupelliteralen) werden in der Reihenfolge von links nach rechts ausgewertet.</span><span class="sxs-lookup"><span data-stu-id="96d6a-113">Both operands (and, in the case of tuple literals, their elements) are evaluated in order from left to right.</span></span> <span data-ttu-id="96d6a-114">Jedes Element Paar wird dann als Operanden verwendet, um den Operator `==` (oder `!=`) rekursiv zu binden.</span><span class="sxs-lookup"><span data-stu-id="96d6a-114">Each pair of elements is then used as operands to bind the operator `==` (or `!=`), recursively.</span></span> <span data-ttu-id="96d6a-115">Alle Elemente mit der Kompilier Zeittyp-`dynamic` verursachen einen Fehler.</span><span class="sxs-lookup"><span data-stu-id="96d6a-115">Any elements with compile-time type `dynamic` cause an error.</span></span> <span data-ttu-id="96d6a-116">Die Ergebnisse dieser Element weisen Vergleiche werden als Operanden in einer Kette von bedingten Operatoren und-Operatoren (oder oder) verwendet.</span><span class="sxs-lookup"><span data-stu-id="96d6a-116">The results of those element-wise comparisons are used as operands in a chain of conditional AND (or OR) operators.</span></span>

<span data-ttu-id="96d6a-117">Beispielsweise werden im Kontext `(int, (int, int)) t1, t2;``t1 == (1, (2, 3))` als `temp1.Item1 == temp2.Item1 && temp1.Item2.Item1 == temp2.Item2.Item1 && temp2.Item2.Item2 == temp2.Item2.Item2`ausgewertet.</span><span class="sxs-lookup"><span data-stu-id="96d6a-117">For instance, in the context of `(int, (int, int)) t1, t2;`, `t1 == (1, (2, 3))` would evaluate as `temp1.Item1 == temp2.Item1 && temp1.Item2.Item1 == temp2.Item2.Item1 && temp2.Item2.Item2 == temp2.Item2.Item2`.</span></span>

<span data-ttu-id="96d6a-118">Wenn ein tupelliteral als Operand (auf beiden Seiten) verwendet wird, empfängt es einen konvertierten tupeltyp, der durch die Element bezogenen Konvertierungen gebildet wird, die beim Binden des Operators `==` (oder `!=`) Element Weise eingeführt werden.</span><span class="sxs-lookup"><span data-stu-id="96d6a-118">When a tuple literal is used as operand (on either side), it receives a converted tuple type formed by the element-wise conversions which are introduced when binding the operator `==` (or `!=`) element-wise.</span></span> 

<span data-ttu-id="96d6a-119">Beispielsweise ist in `(1L, 2, "hello") == (1, 2L, null)`der konvertierte Typ für beide tupelliterale `(long, long, string)`, und das zweite Literale hat keinen natürlichen Typ.</span><span class="sxs-lookup"><span data-stu-id="96d6a-119">For instance, in `(1L, 2, "hello") == (1, 2L, null)`, the converted type for both tuple literals is `(long, long, string)` and the second literal has no natural type.</span></span>


### <a name="deconstruction-and-conversions-to-tuple"></a><span data-ttu-id="96d6a-120">Debug und Konvertierungen in Tupel</span><span class="sxs-lookup"><span data-stu-id="96d6a-120">Deconstruction and conversions to tuple</span></span>
<span data-ttu-id="96d6a-121">In `(a, b) == x`spielt die Tatsache, dass `x` in zwei Elemente decoeinigen kann, keine Rolle.</span><span class="sxs-lookup"><span data-stu-id="96d6a-121">In `(a, b) == x`, the fact that `x` can deconstruct into two elements does not play a role.</span></span> <span data-ttu-id="96d6a-122">Dies könnte in einem zukünftigen Vorschlag der Fall sein, obwohl es Fragen zu `x == y` aufwerfen würde (ist dies ein einfacher Vergleich oder ein Element weiser Vergleich, und wenn dies der Fall ist, welche Kardinalität verwendet wird).</span><span class="sxs-lookup"><span data-stu-id="96d6a-122">That could conceivably be in a future proposal, although it would raise questions about `x == y` (is this a simple comparison or an element-wise comparison, and if so using what cardinality?).</span></span>
<span data-ttu-id="96d6a-123">Ebenso spielen Konvertierungen in Tupel keine Rolle.</span><span class="sxs-lookup"><span data-stu-id="96d6a-123">Similarly, conversions to tuple play no role.</span></span>

### <a name="tuple-element-names"></a><span data-ttu-id="96d6a-124">Tupelelementnamen</span><span class="sxs-lookup"><span data-stu-id="96d6a-124">Tuple element names</span></span>

<span data-ttu-id="96d6a-125">Beim Umrechnen eines tupelliterals warnen wir, wenn ein expliziter tupelelementname im Literalformat angegeben wurde, aber nicht mit dem Ziel-tupelelementnamen identisch ist.</span><span class="sxs-lookup"><span data-stu-id="96d6a-125">When converting a tuple literal, we warn when an explicit tuple element name was provided in the literal, but it doesn't match the target tuple element name.</span></span>
<span data-ttu-id="96d6a-126">Wir verwenden die gleiche Regel beim Tupel-Vergleich, sodass `(int a, int b) t` wir bei `d` in `t == (c, d: 0)`warnen.</span><span class="sxs-lookup"><span data-stu-id="96d6a-126">We use the same rule in tuple comparison, so that assuming `(int a, int b) t` we warn on `d` in `t == (c, d: 0)`.</span></span>

### <a name="non-bool-element-wise-comparison-results"></a><span data-ttu-id="96d6a-127">Nicht boolesche Vergleichsergebnisse (Element Weise)</span><span class="sxs-lookup"><span data-stu-id="96d6a-127">Non-bool element-wise comparison results</span></span>

<span data-ttu-id="96d6a-128">Wenn ein Element weiser Vergleich in einer tupelgleichheit dynamisch ist, verwenden wir einen dynamischen Aufruf des Operators `false` und negieren diese, um eine `bool` zu erhalten und mit weiteren Element bezogenen vergleichen fortzufahren.</span><span class="sxs-lookup"><span data-stu-id="96d6a-128">If an element-wise comparison is dynamic in a tuple equality, we use a dynamic invocation of the operator `false` and negate that to get a `bool` and continue with further element-wise comparisons.</span></span> 

<span data-ttu-id="96d6a-129">Wenn ein Element weiser Vergleich einen anderen nicht booleschen Typ in einer tupelgleichheit zurückgibt, gibt es zwei Fälle:</span><span class="sxs-lookup"><span data-stu-id="96d6a-129">If an element-wise comparison returns some other non-bool type in a tuple equality, there are two cases:</span></span>
- <span data-ttu-id="96d6a-130">Wenn der Typ, der kein boolescher Typ ist, in `bool`konvertiert wird, wird diese Konvertierung angewendet.</span><span class="sxs-lookup"><span data-stu-id="96d6a-130">if the non-bool type converts to `bool`, we apply that conversion,</span></span>
- <span data-ttu-id="96d6a-131">Wenn keine solche Konvertierung vorhanden ist, der Typ jedoch einen Operator `false`hat, verwenden wir diesen und negieren das Ergebnis.</span><span class="sxs-lookup"><span data-stu-id="96d6a-131">if there is no such conversion, but the type has an operator `false`, we'll use that and negate the result.</span></span>

<span data-ttu-id="96d6a-132">Bei einer tupelungleichheit gelten dieselben Regeln, mit der Ausnahme, dass der Operator `true` (ohne Negation) anstelle des Operators `false`verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="96d6a-132">In a tuple inequality, the same rules apply except that we'll use the operator `true` (without negation) instead of the operator `false`.</span></span>

<span data-ttu-id="96d6a-133">Diese Regeln ähneln den Regeln für die Verwendung eines nicht-booleschen Typs in einer `if`-Anweisung und einigen anderen vorhandenen Kontexten.</span><span class="sxs-lookup"><span data-stu-id="96d6a-133">Those rules are similar to the rules involved for using a non-bool type in an `if` statement and some other existing contexts.</span></span>

## <a name="evaluation-order-and-special-cases"></a><span data-ttu-id="96d6a-134">Auswertungs Reihenfolge und Sonderfälle</span><span class="sxs-lookup"><span data-stu-id="96d6a-134">Evaluation order and special cases</span></span>
<span data-ttu-id="96d6a-135">Der Wert auf der linken Seite wird zuerst ausgewertet, dann der Wert auf der rechten Seite, dann die Element weisen Vergleiche von links nach rechts (einschließlich Konvertierungen und mit Early Exit basierend auf vorhandenen Regeln für bedingte and/or-Operatoren).</span><span class="sxs-lookup"><span data-stu-id="96d6a-135">The left-hand-side value is evaluated first, then the right-hand-side value, then the element-wise comparisons from left to right (including conversions, and with early exit based on existing rules for conditional AND/OR operators).</span></span>

<span data-ttu-id="96d6a-136">Wenn beispielsweise eine Konvertierung vom Typ `A` in den Typ `B` und eine Methode `(A, A) GetTuple()`erfolgt, bedeutet das Auswerten `(new A(1), (new B(2), new B(3))) == (new B(4), GetTuple())` Folgendes:</span><span class="sxs-lookup"><span data-stu-id="96d6a-136">For instance, if there is a conversion from type `A` to type `B` and a method `(A, A) GetTuple()`, evaluating `(new A(1), (new B(2), new B(3))) == (new B(4), GetTuple())` means:</span></span>
- `new A(1)`
- `new B(2)`
- `new B(3)`
- `new B(4)`
- `GetTuple()`
- <span data-ttu-id="96d6a-137">Anschließend werden die Element weisen Konvertierungen und Vergleiche und die bedingte Logik ausgewertet (konvertieren Sie `new A(1)` in den Typ `B`, und vergleichen Sie ihn dann mit `new B(4)`usw.).</span><span class="sxs-lookup"><span data-stu-id="96d6a-137">then the element-wise conversions and comparisons and conditional logic is evaluated (convert `new A(1)` to type `B`, then compare it with `new B(4)`, and so on).</span></span>

### <a name="comparing-null-to-null"></a><span data-ttu-id="96d6a-138">Vergleichen von `null` mit `null`</span><span class="sxs-lookup"><span data-stu-id="96d6a-138">Comparing `null` to `null`</span></span>

<span data-ttu-id="96d6a-139">Dies ist ein Sonderfall von regulären vergleichen, der auf tupelvergleiche überträgt.</span><span class="sxs-lookup"><span data-stu-id="96d6a-139">This is a special case from regular comparisons, that carries over to tuple comparisons.</span></span> <span data-ttu-id="96d6a-140">Der `null == null` Vergleich ist zulässig, und die `null` Literale erhalten keinen Typ.</span><span class="sxs-lookup"><span data-stu-id="96d6a-140">The `null == null` comparison is allowed, and the `null` literals do not get any type.</span></span>
<span data-ttu-id="96d6a-141">Bei tupelgleichheit bedeutet dies, dass `(0, null) == (0, null)` ebenfalls zulässig ist und die `null`-und tupelliterale keinen Typ erhalten.</span><span class="sxs-lookup"><span data-stu-id="96d6a-141">In tuple equality, this means, `(0, null) == (0, null)` is also allowed and the `null` and tuple literals don't get a type either.</span></span>

### <a name="comparing-a-nullable-struct-to-null-without-operator"></a><span data-ttu-id="96d6a-142">Vergleichen einer Struktur, die NULL-Werte zulässt, mit `null` ohne `operator==`</span><span class="sxs-lookup"><span data-stu-id="96d6a-142">Comparing a nullable struct to `null` without `operator==`</span></span>

<span data-ttu-id="96d6a-143">Dies ist ein weiterer Sonderfall von regulären vergleichen, der auf tupelvergleiche überträgt.</span><span class="sxs-lookup"><span data-stu-id="96d6a-143">This is another special case from regular comparisons, that carries over to tuple comparisons.</span></span>
<span data-ttu-id="96d6a-144">Wenn Sie ein `struct S` ohne `operator==`haben, ist der `(S?)x == null` Vergleich zulässig, und er wird als `((S?).x).HasValue`interpretiert.</span><span class="sxs-lookup"><span data-stu-id="96d6a-144">If you have a `struct S` without `operator==`, the `(S?)x == null` comparison is allowed, and it is interpreted as `((S?).x).HasValue`.</span></span>
<span data-ttu-id="96d6a-145">Bei der tupelgleichheit wird dieselbe Regel angewendet, sodass `(0, (S?)x) == (0, null)` zulässig ist.</span><span class="sxs-lookup"><span data-stu-id="96d6a-145">In tuple equality, the same rule is applied, so `(0, (S?)x) == (0, null)` is allowed.</span></span>

## <a name="compatibility"></a><span data-ttu-id="96d6a-146">Kompatibilität</span><span class="sxs-lookup"><span data-stu-id="96d6a-146">Compatibility</span></span>

<span data-ttu-id="96d6a-147">Wenn ein Benutzer seine eigenen `ValueTuple` Typen mit einer Implementierung des Vergleichs Operators verfasst hat, wäre er zuvor durch Überladungs Auflösung übernommen worden.</span><span class="sxs-lookup"><span data-stu-id="96d6a-147">If someone wrote their own `ValueTuple` types with  an implementation of the comparison operator, it would have previously been picked up by overload resolution.</span></span> <span data-ttu-id="96d6a-148">Da jedoch der neue tupelfall vor der Überladungs Auflösung steht, wird dieser Fall mit tupelvergleichen behandelt, anstatt auf den benutzerdefinierten Vergleich zu vertrauen.</span><span class="sxs-lookup"><span data-stu-id="96d6a-148">But since the new tuple case comes before overload resolution, we would handle this case with tuple comparison instead of relying on the user-defined comparison.</span></span>

----

<span data-ttu-id="96d6a-149">Bezieht sich auf [relationale und Typtest Operatoren](../../spec/expressions.md#relational-and-type-testing-operators) in Beziehung zu [#190](https://github.com/dotnet/csharplang/issues/190)</span><span class="sxs-lookup"><span data-stu-id="96d6a-149">Relates to [relational and type testing operators](../../spec/expressions.md#relational-and-type-testing-operators) Relates to [#190](https://github.com/dotnet/csharplang/issues/190)</span></span>
