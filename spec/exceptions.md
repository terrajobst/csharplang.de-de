---
ms.openlocfilehash: 75fcd5b00ea5cac218a9f7809c53b179df97825c
ms.sourcegitcommit: 3fc033b6e98ed7ecdf46a85c79b00a3a3ddcf963
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 01/18/2019
ms.locfileid: "47229656"
---
# <a name="exceptions"></a><span data-ttu-id="1aa63-101">Ausnahmen</span><span class="sxs-lookup"><span data-stu-id="1aa63-101">Exceptions</span></span>

<span data-ttu-id="1aa63-102">Ausnahmen in C# bieten eine strukturierte, einheitliche und typsichere Möglichkeit, sowohl auf Systemebene und auf Anwendungsebene Behandeln von fehlerbedingungen.</span><span class="sxs-lookup"><span data-stu-id="1aa63-102">Exceptions in C# provide a structured, uniform, and type-safe way of handling both system level and application level error conditions.</span></span> <span data-ttu-id="1aa63-103">Der Ausnahmemechanismus in C# ist vergleichbar mit C++, mit einigen wichtigen Unterschieden:</span><span class="sxs-lookup"><span data-stu-id="1aa63-103">The exception mechanism in C# is quite similar to that of C++, with a few important differences:</span></span>

*  <span data-ttu-id="1aa63-104">In C# müssen alle Ausnahmen, die von einer Instanz eines Klassentyps, die von abgeleiteten dargestellt werden `System.Exception`.</span><span class="sxs-lookup"><span data-stu-id="1aa63-104">In C#, all exceptions must be represented by an instance of a class type derived from `System.Exception`.</span></span> <span data-ttu-id="1aa63-105">In C++ kann einen beliebigen Wert eines beliebigen Typs verwendet werden, um eine Ausnahme darzustellen.</span><span class="sxs-lookup"><span data-stu-id="1aa63-105">In C++, any value of any type can be used to represent an exception.</span></span>
*  <span data-ttu-id="1aa63-106">In C# einen finally-block ([der Try-Anweisung](statements.md#the-try-statement)) kann verwendet werden, um die Beendigung Code zu schreiben, die in normalen Ausführung und außergewöhnliche Bedingungen, die ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="1aa63-106">In C#, a finally block ([The try statement](statements.md#the-try-statement)) can be used to write termination code that executes in both normal execution and exceptional conditions.</span></span> <span data-ttu-id="1aa63-107">Solcher Code ist schwierig, die in C++ zu schreiben, ohne Code zu duplizieren.</span><span class="sxs-lookup"><span data-stu-id="1aa63-107">Such code is difficult to write in C++ without duplicating code.</span></span>
*  <span data-ttu-id="1aa63-108">In C# auf Systemebene Ausnahmen wie z. B. Überlauf, Division durch Null und Null-Dereferenzierungen Ausnahmeklassen verfügen über klar definierte und werden auf die gleiche Stufe von fehlerbedingungen auf Anwendungsebene.</span><span class="sxs-lookup"><span data-stu-id="1aa63-108">In C#, system-level exceptions such as overflow, divide-by-zero, and null dereferences have well defined exception classes and are on a par with application-level error conditions.</span></span>

## <a name="causes-of-exceptions"></a><span data-ttu-id="1aa63-109">Ursachen von Ausnahmen</span><span class="sxs-lookup"><span data-stu-id="1aa63-109">Causes of exceptions</span></span>

<span data-ttu-id="1aa63-110">Ausnahme kann auf zwei unterschiedliche Arten ausgelöst werden.</span><span class="sxs-lookup"><span data-stu-id="1aa63-110">Exception can be thrown in two different ways.</span></span>

*  <span data-ttu-id="1aa63-111">Ein `throw` Anweisung ([die Throw-Anweisung](statements.md#the-throw-statement)) löst eine Ausnahme aus, sofort und ohne Bedingung.</span><span class="sxs-lookup"><span data-stu-id="1aa63-111">A `throw` statement ([The throw statement](statements.md#the-throw-statement)) throws an exception immediately and unconditionally.</span></span> <span data-ttu-id="1aa63-112">Steuerung niemals erreicht, die Anweisung sofort nach der `throw`.</span><span class="sxs-lookup"><span data-stu-id="1aa63-112">Control never reaches the statement immediately following the `throw`.</span></span>
*  <span data-ttu-id="1aa63-113">Bestimmte außergewöhnlichen Bedingungen, die während der Verarbeitung von C#-Anweisungen und Ausdrücke entstehen unter bestimmten Umständen eine Ausnahme ausgelöst, wenn der Vorgang normal abgeschlossen werden kann.</span><span class="sxs-lookup"><span data-stu-id="1aa63-113">Certain exceptional conditions that arise during the processing of C# statements and expression cause an exception in certain circumstances when the operation cannot be completed normally.</span></span> <span data-ttu-id="1aa63-114">Z. B. eine ganze Zahl Division ([Divisionsoperator](expressions.md#division-operator)) löst eine `System.DivideByZeroException` Wenn der Nenner 0 (null) ist.</span><span class="sxs-lookup"><span data-stu-id="1aa63-114">For example, an integer division operation ([Division operator](expressions.md#division-operator)) throws a `System.DivideByZeroException` if the denominator is zero.</span></span> <span data-ttu-id="1aa63-115">Finden Sie unter [Common Exception Classes](exceptions.md#common-exception-classes) eine Liste der verschiedenen Ausnahmen, die auf diese Weise auftreten können.</span><span class="sxs-lookup"><span data-stu-id="1aa63-115">See [Common Exception Classes](exceptions.md#common-exception-classes) for a list of the various exceptions that can occur in this way.</span></span>

## <a name="the-systemexception-class"></a><span data-ttu-id="1aa63-116">Die System.Exception-Klasse</span><span class="sxs-lookup"><span data-stu-id="1aa63-116">The System.Exception class</span></span>

<span data-ttu-id="1aa63-117">Die `System.Exception` Klasse ist der Basistyp aller Ausnahmen.</span><span class="sxs-lookup"><span data-stu-id="1aa63-117">The `System.Exception` class is the base type of all exceptions.</span></span> <span data-ttu-id="1aa63-118">Diese Klasse verfügt über einige wichtige Eigenschaften, die alle Ausnahmen, die gemeinsam nutzen:</span><span class="sxs-lookup"><span data-stu-id="1aa63-118">This class has a few notable properties that all exceptions share:</span></span>

*  <span data-ttu-id="1aa63-119">`Message` ist eine nur-Lese Eigenschaft des Typs `string` , der eine lesbare Beschreibung des Grunds für die Ausnahme enthält.</span><span class="sxs-lookup"><span data-stu-id="1aa63-119">`Message` is a read-only property of type `string` that contains a human-readable description of the reason for the exception.</span></span>
*  <span data-ttu-id="1aa63-120">`InnerException` ist eine nur-Lese Eigenschaft des Typs `Exception`.</span><span class="sxs-lookup"><span data-stu-id="1aa63-120">`InnerException` is a read-only property of type `Exception`.</span></span> <span data-ttu-id="1aa63-121">Wenn der Wert ungleich Null ist, wird es bezieht sich auf die Ausnahme, die die aktuelle Ausnahme verursacht hat –, also die aktuelle Ausnahme ausgelöst wurde, in einem Catch-Block behandeln die `InnerException`.</span><span class="sxs-lookup"><span data-stu-id="1aa63-121">If its value is non-null, it refers to the exception that caused the current exception—that is, the current exception was raised in a catch block handling the `InnerException`.</span></span> <span data-ttu-id="1aa63-122">Andernfalls ist der Wert null ist, gibt an, dass diese Ausnahme nicht durch eine andere Ausnahme ausgelöst wurde.</span><span class="sxs-lookup"><span data-stu-id="1aa63-122">Otherwise, its value is null, indicating that this exception was not caused by another exception.</span></span> <span data-ttu-id="1aa63-123">Die Anzahl von Ausnahmeobjekten miteinander verkettet werden, auf diese Weise kann beliebige sein.</span><span class="sxs-lookup"><span data-stu-id="1aa63-123">The number of exception objects chained together in this manner can be arbitrary.</span></span>

<span data-ttu-id="1aa63-124">Der Wert dieser Eigenschaften kann angegeben werden, in Aufrufen an den Instanzkonstruktor für `System.Exception`.</span><span class="sxs-lookup"><span data-stu-id="1aa63-124">The value of these properties can be specified in calls to the instance constructor for `System.Exception`.</span></span>

## <a name="how-exceptions-are-handled"></a><span data-ttu-id="1aa63-125">Behandlung von Ausnahmen</span><span class="sxs-lookup"><span data-stu-id="1aa63-125">How exceptions are handled</span></span>

<span data-ttu-id="1aa63-126">Ausnahmen werden behandelt, indem eine `try` Anweisung ([der Try-Anweisung](statements.md#the-try-statement)).</span><span class="sxs-lookup"><span data-stu-id="1aa63-126">Exceptions are handled by a `try` statement ([The try statement](statements.md#the-try-statement)).</span></span>

<span data-ttu-id="1aa63-127">Wenn eine Ausnahme auftritt, das System sucht das nächste `catch` -Klausel, die die Ausnahme behandeln kann, wie durch den Laufzeit-Typ der Ausnahme bestimmt.</span><span class="sxs-lookup"><span data-stu-id="1aa63-127">When an exception occurs, the system searches for the nearest `catch` clause that can handle the exception, as determined by the run-time type of the exception.</span></span> <span data-ttu-id="1aa63-128">Zunächst durchsucht die aktuelle Methode für eine lexikalisch einschließenden `try` -Anweisung und die zugehörigen Catch-Klauseln der Try-Anweisung in der Reihenfolge betrachtet werden.</span><span class="sxs-lookup"><span data-stu-id="1aa63-128">First, the current method is searched for a lexically enclosing `try` statement, and the associated catch clauses of the try statement are considered in order.</span></span> <span data-ttu-id="1aa63-129">Schlägt dies fehl, wird die Methode, die die aktuelle Methode aufgerufen für eine lexikalisch einschließenden durchsucht `try` -Anweisung, die den Punkt des Aufrufs an die aktuelle Methode einschließt.</span><span class="sxs-lookup"><span data-stu-id="1aa63-129">If that fails, the method that called the current method is searched for a lexically enclosing `try` statement that encloses the point of the call to the current method.</span></span> <span data-ttu-id="1aa63-130">Bei dieser Suche wird fortgesetzt, bis eine `catch` Klausel wurde gefunden, die können die aktuelle Ausnahme behandeln, indem Sie benennen eine Ausnahmeklasse, die von derselben Klasse oder eine Basisklasse, von dem Laufzeittyp der ausgelösten Ausnahme ist.</span><span class="sxs-lookup"><span data-stu-id="1aa63-130">This search continues until a `catch` clause is found that can handle the current exception, by naming an exception class that is of the same class, or a base class, of the run-time type of the exception being thrown.</span></span> <span data-ttu-id="1aa63-131">Ein `catch` -Klausel, die eine Ausnahme Klassenname nicht kann eine beliebige Ausnahme behandeln.</span><span class="sxs-lookup"><span data-stu-id="1aa63-131">A `catch` clause that doesn't name an exception class can handle any exception.</span></span>

<span data-ttu-id="1aa63-132">Nach eine übereinstimmenden Catch-Klausel gefunden wird, wird das System die Steuerung an die Catch-Klausel der ersten Anweisung übertragen vorbereitet.</span><span class="sxs-lookup"><span data-stu-id="1aa63-132">Once a matching catch clause is found, the system prepares to transfer control to the first statement of the catch clause.</span></span> <span data-ttu-id="1aa63-133">Vor dem Beginn der Ausführung des Catch-Klausel das System zuerst ausgeführt wird, nacheinander alle `finally` Klauseln, die Try-Anweisungen, die weitere zugeordnet waren geschachtelt sind, als die, die die Ausnahme abgefangen.</span><span class="sxs-lookup"><span data-stu-id="1aa63-133">Before execution of the catch clause begins, the system first executes, in order, any `finally` clauses that were associated with try statements more nested that than the one that caught the exception.</span></span>

<span data-ttu-id="1aa63-134">Wenn keine übereinstimmenden Catch-Klausel gefunden wird, geschieht zweierlei:</span><span class="sxs-lookup"><span data-stu-id="1aa63-134">If no matching catch clause is found, one of two things occurs:</span></span>

*  <span data-ttu-id="1aa63-135">Wenn die Suche nach einer übereinstimmenden Catch-Klausel einen statischen Konstruktor erreicht ([statische Konstruktoren](classes.md#static-constructors)) oder statischen Feldinitialisierer, und klicken Sie dann eine `System.TypeInitializationException` wird ausgelöst, an dem Punkt, der den Aufruf der statischen Konstruktor ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="1aa63-135">If the search for a matching catch clause reaches a static constructor ([Static constructors](classes.md#static-constructors)) or static field initializer, then a `System.TypeInitializationException` is thrown at the point that triggered the invocation of the static constructor.</span></span> <span data-ttu-id="1aa63-136">Die innere Ausnahme von der `System.TypeInitializationException` enthält die Ausnahme, die ursprünglich ausgelöst wurde.</span><span class="sxs-lookup"><span data-stu-id="1aa63-136">The inner exception of the `System.TypeInitializationException` contains the exception that was originally thrown.</span></span>
*  <span data-ttu-id="1aa63-137">Wenn die Suche nach übereinstimmenden Catch-Klauseln im Code, der Anfangs den Thread gestartet hat erreicht, wird die Ausführung des Threads beendet.</span><span class="sxs-lookup"><span data-stu-id="1aa63-137">If the search for matching catch clauses reaches the code that initially started the thread, then execution of the thread is terminated.</span></span> <span data-ttu-id="1aa63-138">Die Auswirkungen des Abbruchs ist implementierungsdefiniert.</span><span class="sxs-lookup"><span data-stu-id="1aa63-138">The impact of such termination is implementation-defined.</span></span>

<span data-ttu-id="1aa63-139">Ausnahmen, die auftreten, während der Destruktorausführung sind muss erwähnt werden.</span><span class="sxs-lookup"><span data-stu-id="1aa63-139">Exceptions that occur during destructor execution are worth special mention.</span></span> <span data-ttu-id="1aa63-140">Wenn eine Ausnahme tritt auf, während der Destruktorausführung diese Ausnahme nicht abgefangen und die Ausführung von diesem Destruktor wird beendet, und der Destruktor der Basisklasse (sofern vorhanden) aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="1aa63-140">If an exception occurs during destructor execution, and that exception is not caught, then the execution of that destructor is terminated and the destructor of the base class (if any) is called.</span></span> <span data-ttu-id="1aa63-141">Wenn keine Basisklasse vorhanden ist (wie im Fall von der `object` Typs) oder wenn es keine Basisklassen-Destruktor, wird die Ausnahme verworfen.</span><span class="sxs-lookup"><span data-stu-id="1aa63-141">If there is no base class (as in the case of the `object` type) or if there is no base class destructor, then the exception is discarded.</span></span>

## <a name="common-exception-classes"></a><span data-ttu-id="1aa63-142">Allgemeine Ausnahmeklassen</span><span class="sxs-lookup"><span data-stu-id="1aa63-142">Common Exception Classes</span></span>

<span data-ttu-id="1aa63-143">Die folgenden Ausnahmen werden von bestimmten C#-Vorgängen ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="1aa63-143">The following exceptions are thrown by certain C# operations.</span></span>

|                                      |                |
|--------------------------------------|----------------|
| `System.ArithmeticException`         | <span data-ttu-id="1aa63-144">Eine Basisklasse für Ausnahmen (z.B. `System.DivideByZeroException` und `System.OverflowException`), die während arithmetischer Operationen auftreten.</span><span class="sxs-lookup"><span data-stu-id="1aa63-144">A base class for exceptions that occur during arithmetic operations, such as `System.DivideByZeroException` and `System.OverflowException`.</span></span> | 
| `System.ArrayTypeMismatchException`  | <span data-ttu-id="1aa63-145">Ausgelöst, wenn Sie ein Speicher in ein Array, das schlägt fehl, da der tatsächliche Typ des gespeicherten Elements mit dem tatsächlichen Typ des Arrays inkompatibel ist.</span><span class="sxs-lookup"><span data-stu-id="1aa63-145">Thrown when a store into an array fails because the actual type of the stored element is incompatible with the actual type of the array.</span></span> | 
| `System.DivideByZeroException`       | <span data-ttu-id="1aa63-146">Ausgelöst, wenn der Versuch, einen Integralwert durch Null zu teilen.</span><span class="sxs-lookup"><span data-stu-id="1aa63-146">Thrown when an attempt to divide an integral value by zero occurs.</span></span> | 
| `System.IndexOutOfRangeException`    | <span data-ttu-id="1aa63-147">Wird ausgelöst, wenn ein Versuch, ein Array mit einem Index zu indizieren, die kleiner als 0 (null) oder außerhalb der Grenzen des Arrays ist.</span><span class="sxs-lookup"><span data-stu-id="1aa63-147">Thrown when an attempt to index an array via an index that is less than zero or outside the bounds of the array.</span></span> | 
| `System.InvalidCastException`        | <span data-ttu-id="1aa63-148">Wird ausgelöst, wenn eine explizite Konvertierung von einer Basisklasse oder Schnittstelle in einem abgeleiteten Typ zur Laufzeit ein Fehler auftritt.</span><span class="sxs-lookup"><span data-stu-id="1aa63-148">Thrown when an explicit conversion from a base type or interface to a derived type fails at run time.</span></span> | 
| `System.NullReferenceException`      | <span data-ttu-id="1aa63-149">Wird ausgelöst, wenn eine `null` -Verweis wird verwendet, in einer Weise, die bewirkt, dass das referenzierte Objekt erforderlich sein.</span><span class="sxs-lookup"><span data-stu-id="1aa63-149">Thrown when a `null` reference is used in a way that causes the referenced object to be required.</span></span> | 
| `System.OutOfMemoryException`        | <span data-ttu-id="1aa63-150">Wird ausgelöst, wenn ein Versuch zur Belegung von Arbeitsspeicher (über `new`) ein Fehler auftritt.</span><span class="sxs-lookup"><span data-stu-id="1aa63-150">Thrown when an attempt to allocate memory (via `new`) fails.</span></span> | 
| `System.OverflowException`           | <span data-ttu-id="1aa63-151">Wird ausgelöst, wenn eine arithmetische Operation im Kontext `checked` überläuft.</span><span class="sxs-lookup"><span data-stu-id="1aa63-151">Thrown when an arithmetic operation in a `checked` context overflows.</span></span> | 
| `System.StackOverflowException`      | <span data-ttu-id="1aa63-152">Wird ausgelöst, wenn der Ausführungsstapel durch zu viele ausstehende Methodenaufrufe ausgeschöpft ist; in der Regel ein Zeichen für sehr tiefe oder unbegrenzte Rekursion.</span><span class="sxs-lookup"><span data-stu-id="1aa63-152">Thrown when the execution stack is exhausted by having too many pending method calls; typically indicative of very deep or unbounded recursion.</span></span> | 
| `System.TypeInitializationException` | <span data-ttu-id="1aa63-153">Wird ausgelöst, wenn ein statischer Konstruktor eine Ausnahme aus, und keine auslöst `catch` Klauseln vorhanden ist, die abgefangen werden.</span><span class="sxs-lookup"><span data-stu-id="1aa63-153">Thrown when a static constructor throws an exception, and no `catch` clauses exists to catch it.</span></span> | 
