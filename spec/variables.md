# <a name="variables"></a><span data-ttu-id="8df36-101">Variablen</span><span class="sxs-lookup"><span data-stu-id="8df36-101">Variables</span></span>

<span data-ttu-id="8df36-102">Variablen stellen Speicherorte dar.</span><span class="sxs-lookup"><span data-stu-id="8df36-102">Variables represent storage locations.</span></span> <span data-ttu-id="8df36-103">Jede Variable hat einen Typ, der bestimmt, welche Werte können in der Variablen gespeichert.</span><span class="sxs-lookup"><span data-stu-id="8df36-103">Every variable has a type that determines what values can be stored in the variable.</span></span> <span data-ttu-id="8df36-104">C# ist eine typsichere-Sprache, und der C#-Compiler garantiert, dass in Variablen gespeicherten Werte immer des entsprechenden Typs.</span><span class="sxs-lookup"><span data-stu-id="8df36-104">C# is a type-safe language, and the C# compiler guarantees that values stored in variables are always of the appropriate type.</span></span> <span data-ttu-id="8df36-105">Der Wert einer Variablen kann geändert werden, über die Zuweisung oder durch die `++` und `--` Operatoren.</span><span class="sxs-lookup"><span data-stu-id="8df36-105">The value of a variable can be changed through assignment or through use of the `++` and `--` operators.</span></span>

<span data-ttu-id="8df36-106">Eine Variable muss ***definitiv zugewiesen*** ([definitive Zuweisung](variables.md#definite-assignment)), bevor ihr Wert abgerufen werden kann.</span><span class="sxs-lookup"><span data-stu-id="8df36-106">A variable must be ***definitely assigned*** ([Definite assignment](variables.md#definite-assignment)) before its value can be obtained.</span></span>

<span data-ttu-id="8df36-107">Wie in den folgenden Abschnitten beschrieben werden, sind Variablen ***ursprünglich zugewiesenen*** oder ***anfänglich nicht zugewiesene***.</span><span class="sxs-lookup"><span data-stu-id="8df36-107">As described in the following sections, variables are either ***initially assigned*** or ***initially unassigned***.</span></span> <span data-ttu-id="8df36-108">Eine anfänglich zugewiesene Variable verfügt über eine klar definierte Anfangswert und wird immer als definitiv zugewiesen.</span><span class="sxs-lookup"><span data-stu-id="8df36-108">An initially assigned variable has a well-defined initial value and is always considered definitely assigned.</span></span> <span data-ttu-id="8df36-109">Eine anfänglich nicht zugewiesene Variable verfügt über keinen Anfangswert.</span><span class="sxs-lookup"><span data-stu-id="8df36-109">An initially unassigned variable has no initial value.</span></span> <span data-ttu-id="8df36-110">Für eine anfänglich nicht zugewiesene Variable definitiv zugewiesen an einem bestimmten Standort berücksichtigt werden muss eine Zuweisung der Variablen in jedem möglichen Ausführungspfad für diesen Speicherort führende auftreten.</span><span class="sxs-lookup"><span data-stu-id="8df36-110">For an initially unassigned variable to be considered definitely assigned at a certain location, an assignment to the variable must occur in every possible execution path leading to that location.</span></span>

## <a name="variable-categories"></a><span data-ttu-id="8df36-111">Variable Kategorien</span><span class="sxs-lookup"><span data-stu-id="8df36-111">Variable categories</span></span>

<span data-ttu-id="8df36-112">C# definiert sieben Kategorien von Variablen: statische Variablen, Instanzvariablen, Elemente des Arrays, Wertparameter, Verweisparameter, Ausgabeparameter und lokale Variablen.</span><span class="sxs-lookup"><span data-stu-id="8df36-112">C# defines seven categories of variables: static variables, instance variables, array elements, value parameters, reference parameters, output parameters, and local variables.</span></span> <span data-ttu-id="8df36-113">Die folgenden Abschnitten wird jede dieser Kategorien beschrieben.</span><span class="sxs-lookup"><span data-stu-id="8df36-113">The sections that follow describe each of these categories.</span></span>

<span data-ttu-id="8df36-114">Im Beispiel</span><span class="sxs-lookup"><span data-stu-id="8df36-114">In the example</span></span>
```csharp
class A
{
public static int x;
int y;

void F(int[] v, int a, ref int b, out int c) {
int i = 1;
c = a + b++;
}
}
```
<span data-ttu-id="8df36-115">`x` ist eine statische Variable `y` ist eine Instanzvariable `v[0]` ist ein Arrayelement `a` Werteparameter ist ein, `b` ist ein Verweisparameter `c` ist ein Output-Parameter und `i` ist eine lokale Variable.</span><span class="sxs-lookup"><span data-stu-id="8df36-115">`x` is a static variable, `y` is an instance variable, `v[0]` is an array element, `a` is a value parameter, `b` is a reference parameter, `c` is an output parameter, and `i` is a local variable.</span></span>

### <a name="static-variables"></a><span data-ttu-id="8df36-116">Statische Variablen</span><span class="sxs-lookup"><span data-stu-id="8df36-116">Static variables</span></span>

<span data-ttu-id="8df36-117">Ein Feld deklariert, mit der `static` Modifizierer wird aufgerufen, eine ***statische Variable***.</span><span class="sxs-lookup"><span data-stu-id="8df36-117">A field declared with the `static` modifier is called a ***static variable***.</span></span> <span data-ttu-id="8df36-118">Wird erstellt, die vor der Ausführung der statische Konstruktor, eine statische Variable ([statische Konstruktoren](classes.md#static-constructors)) für seine enthaltenden Typ und mehr vorhanden ist, wenn die Domäne für die zugeordnete Anwendung ist nicht mehr vorhanden.</span><span class="sxs-lookup"><span data-stu-id="8df36-118">A static variable comes into existence before execution of the static constructor ([Static constructors](classes.md#static-constructors)) for its containing type, and ceases to exist when the associated application domain ceases to exist.</span></span>

<span data-ttu-id="8df36-119">Der Anfangswert einer statischen Variablen ist der Standardwert ([Standardwerte](variables.md#default-values)) der den Typ der Variablen.</span><span class="sxs-lookup"><span data-stu-id="8df36-119">The initial value of a static variable is the default value ([Default values](variables.md#default-values)) of the variable's type.</span></span>

<span data-ttu-id="8df36-120">Für Zwecke der definitive Zuweisungen zu überprüfen gilt eine statische Variable als ursprünglich zugewiesen.</span><span class="sxs-lookup"><span data-stu-id="8df36-120">For purposes of definite assignment checking, a static variable is considered initially assigned.</span></span>

### <a name="instance-variables"></a><span data-ttu-id="8df36-121">Instanzvariablen</span><span class="sxs-lookup"><span data-stu-id="8df36-121">Instance variables</span></span>

<span data-ttu-id="8df36-122">Ein Feld deklariert, ohne die `static` Modifizierer wird aufgerufen, eine ***Instanzvariable***.</span><span class="sxs-lookup"><span data-stu-id="8df36-122">A field declared without the `static` modifier is called an ***instance variable***.</span></span>

#### <a name="instance-variables-in-classes"></a><span data-ttu-id="8df36-123">Instanzvariablen in Klassen</span><span class="sxs-lookup"><span data-stu-id="8df36-123">Instance variables in classes</span></span>

<span data-ttu-id="8df36-124">Eine Instanzvariable für eine Klasse wird erstellt, wenn eine neue Instanz dieser Klasse erstellt wird, und ist nicht vorhanden sein mehr, wenn keine Verweise auf diese Instanz vorhanden sind und der Destruktor der Instanz (falls vorhanden) ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="8df36-124">An instance variable of a class comes into existence when a new instance of that class is created, and ceases to exist when there are no references to that instance and the instance's destructor (if any) has executed.</span></span>

<span data-ttu-id="8df36-125">Der Anfangswert einer Variablen Instanz einer Klasse ist der Standardwert ([Standardwerte](variables.md#default-values)) der den Typ der Variablen.</span><span class="sxs-lookup"><span data-stu-id="8df36-125">The initial value of an instance variable of a class is the default value ([Default values](variables.md#default-values)) of the variable's type.</span></span>

<span data-ttu-id="8df36-126">Für definitive Zuweisungen zu überprüfen, gilt eine Instanzvariable für eine Klasse als ursprünglich zugewiesen.</span><span class="sxs-lookup"><span data-stu-id="8df36-126">For the purpose of definite assignment checking, an instance variable of a class is considered initially assigned.</span></span>

#### <a name="instance-variables-in-structs"></a><span data-ttu-id="8df36-127">Instanzvariablen in Strukturen</span><span class="sxs-lookup"><span data-stu-id="8df36-127">Instance variables in structs</span></span>

<span data-ttu-id="8df36-128">Eine Instanzvariable für eine Struktur verfügt über genau dieselbe Lebensdauer wie die Strukturvariable, die zu der er gehört.</span><span class="sxs-lookup"><span data-stu-id="8df36-128">An instance variable of a struct has exactly the same lifetime as the struct variable to which it belongs.</span></span> <span data-ttu-id="8df36-129">Anders gesagt, wenn eine Variable eines Strukturtyps wird erstellt, oder ist nicht mehr vorhanden, daher führen Sie die Nachrichteninstanzvariablen der Struktur zu.</span><span class="sxs-lookup"><span data-stu-id="8df36-129">In other words, when a variable of a struct type comes into existence or ceases to exist, so too do the instance variables of the struct.</span></span>

<span data-ttu-id="8df36-130">Die anfängliche Zuweisung-Status, der eine Instanzvariable für eine Struktur ist identisch, die von der enthaltenden Struktur-Variablen.</span><span class="sxs-lookup"><span data-stu-id="8df36-130">The initial assignment state of an instance variable of a struct is the same as that of the containing struct variable.</span></span> <span data-ttu-id="8df36-131">Das heißt, wenn eine Strukturvariable als ist zugewiesen, also auch die zugehörigen Instanzvariablen, und wenn eine Strukturvariable als anfänglich kein Wert zugewiesen wird, sind die Instanzvariablen ebenso nicht zugewiesen.</span><span class="sxs-lookup"><span data-stu-id="8df36-131">In other words, when a struct variable is considered initially assigned, so too are its instance variables, and when a struct variable is considered initially unassigned, its instance variables are likewise unassigned.</span></span>

### <a name="array-elements"></a><span data-ttu-id="8df36-132">Array-Elemente</span><span class="sxs-lookup"><span data-stu-id="8df36-132">Array elements</span></span>

<span data-ttu-id="8df36-133">Die Elemente eines Arrays sind vorhanden, wenn eine Arrayinstanz erstellt wird, und nicht mehr vorhanden ist, wenn keine Verweise auf diese Arrayinstanz vorhanden sind.</span><span class="sxs-lookup"><span data-stu-id="8df36-133">The elements of an array come into existence when an array instance is created, and cease to exist when there are no references to that array instance.</span></span>

<span data-ttu-id="8df36-134">Der Anfangswert aller Elemente eines Arrays ist der Standardwert ([Standardwerte](variables.md#default-values)) des Typs der Elemente des Arrays.</span><span class="sxs-lookup"><span data-stu-id="8df36-134">The initial value of each of the elements of an array is the default value ([Default values](variables.md#default-values)) of the type of the array elements.</span></span>

<span data-ttu-id="8df36-135">Für definitive Zuweisungen zu überprüfen, gilt ein Arrayelement anfänglich zugewiesen.</span><span class="sxs-lookup"><span data-stu-id="8df36-135">For the purpose of definite assignment checking, an array element is considered initially assigned.</span></span>

### <a name="value-parameters"></a><span data-ttu-id="8df36-136">Wert-Parametern</span><span class="sxs-lookup"><span data-stu-id="8df36-136">Value parameters</span></span>

<span data-ttu-id="8df36-137">Ein Parameter deklariert, ohne eine `ref` oder `out` Modifizierer ist ein ***"Value"-Parameter***.</span><span class="sxs-lookup"><span data-stu-id="8df36-137">A parameter declared without a `ref` or `out` modifier is a ***value parameter***.</span></span>

<span data-ttu-id="8df36-138">Wird erstellt, die beim Aufruf der Funktionsmember der Member (Methode, Instanzenkonstruktor, Accessor oder -Operator) oder der anonymen Funktion, ein Value-Parameter in der der Parameter gehört, und initialisiert wird, mit dem Wert des Arguments im Aufruf angegeben.</span><span class="sxs-lookup"><span data-stu-id="8df36-138">A value parameter comes into existence upon invocation of the function member (method, instance constructor, accessor, or operator) or anonymous function to which the parameter belongs, and is initialized with the value of the argument given in the invocation.</span></span> <span data-ttu-id="8df36-139">Ein Value-Parameter wird normalerweise bei der Rückgabe der Funktionsmember der Member oder der anonymen Funktion gelöscht.</span><span class="sxs-lookup"><span data-stu-id="8df36-139">A value parameter normally ceases to exist upon return of the function member or anonymous function.</span></span> <span data-ttu-id="8df36-140">Allerdings wird der Value-Parameter von einer anonymen Funktion erfasst ([anonyme Funktionsausdrücke](expressions.md#anonymous-function-expressions)), dessen Lebensdauer mindestens erweitert, bis der Delegat oder Ausdrucksbaumstruktur, die erstellt, die von dieser anonymen Funktion ist für berechtigte eine Garbagecollection.</span><span class="sxs-lookup"><span data-stu-id="8df36-140">However, if the value parameter is captured by an anonymous function ([Anonymous function expressions](expressions.md#anonymous-function-expressions)), its life time extends at least until the delegate or expression tree created from that anonymous function is eligible for garbage collection.</span></span>

<span data-ttu-id="8df36-141">Für definitive Zuweisungen zu überprüfen, gilt ein Value-Parameter als ursprünglich zugewiesen.</span><span class="sxs-lookup"><span data-stu-id="8df36-141">For the purpose of definite assignment checking, a value parameter is considered initially assigned.</span></span>

### <a name="reference-parameters"></a><span data-ttu-id="8df36-142">Verweisparameter</span><span class="sxs-lookup"><span data-stu-id="8df36-142">Reference parameters</span></span>

<span data-ttu-id="8df36-143">Deklarierter Parameter mit einem `ref` Modifizierer ist ein ***Verweisparameter***.</span><span class="sxs-lookup"><span data-stu-id="8df36-143">A parameter declared with a `ref` modifier is a ***reference parameter***.</span></span>

<span data-ttu-id="8df36-144">Ein Verweisparameter wird nicht mit einen neuen Speicherort erstellt.</span><span class="sxs-lookup"><span data-stu-id="8df36-144">A reference parameter does not create a new storage location.</span></span> <span data-ttu-id="8df36-145">Stattdessen stellt ein Verweisparameter am gleichen Speicherort wie die Variable als Argument in der Funktionsmember der Member oder eine anonyme Funktionsaufruf angegeben.</span><span class="sxs-lookup"><span data-stu-id="8df36-145">Instead, a reference parameter represents the same storage location as the variable given as the argument in the function member or anonymous function invocation.</span></span> <span data-ttu-id="8df36-146">Der Wert der Verweisparameter ist daher immer identisch mit der zugrunde liegenden Variablen.</span><span class="sxs-lookup"><span data-stu-id="8df36-146">Thus, the value of a reference parameter is always the same as the underlying variable.</span></span>

<span data-ttu-id="8df36-147">Die folgenden Regeln für definitive Zuweisungen gelten Parameter zu verweisen.</span><span class="sxs-lookup"><span data-stu-id="8df36-147">The following definite assignment rules apply to reference parameters.</span></span> <span data-ttu-id="8df36-148">Beachten Sie die Regeln für Output-Parameter, die in beschriebenen [Ausgabeparameter](variables.md#output-parameters).</span><span class="sxs-lookup"><span data-stu-id="8df36-148">Note the different rules for output parameters described in [Output parameters](variables.md#output-parameters).</span></span>

*  <span data-ttu-id="8df36-149">Eine Variable definitiv zugewiesen werden muss ([definitive Zuweisung](variables.md#definite-assignment)), bevor es als in einem Funktionsaufruf Member oder der Delegat Verweisparameter übergeben werden kann.</span><span class="sxs-lookup"><span data-stu-id="8df36-149">A variable must be definitely assigned ([Definite assignment](variables.md#definite-assignment)) before it can be passed as a reference parameter in a function member or delegate invocation.</span></span>
*  <span data-ttu-id="8df36-150">Ein Verweisparameter in einer Funktionsmember der Member oder eine anonyme Funktion wird als ursprünglich zugewiesenen betrachtet.</span><span class="sxs-lookup"><span data-stu-id="8df36-150">Within a function member or anonymous function, a reference parameter is considered initially assigned.</span></span>

<span data-ttu-id="8df36-151">Innerhalb einer Instanzenmethode oder Instanzaccessor eines Strukturtyps der `this` -Schlüsselwort verhält sich genau wie ein Verweisparameter des Strukturtyps ([diesen Zugriff](expressions.md#this-access)).</span><span class="sxs-lookup"><span data-stu-id="8df36-151">Within an instance method or instance accessor of a struct type, the `this` keyword behaves exactly as a reference parameter of the struct type ([This access](expressions.md#this-access)).</span></span>

### <a name="output-parameters"></a><span data-ttu-id="8df36-152">Output-Parameter</span><span class="sxs-lookup"><span data-stu-id="8df36-152">Output parameters</span></span>

<span data-ttu-id="8df36-153">Ein Parameter deklariert, mit einer `out` Modifizierer ist ein ***output-Parameter***.</span><span class="sxs-lookup"><span data-stu-id="8df36-153">A parameter declared with an `out` modifier is an ***output parameter***.</span></span>

<span data-ttu-id="8df36-154">Ein Output-Parameter wird nicht mit einen neuen Speicherort erstellt.</span><span class="sxs-lookup"><span data-stu-id="8df36-154">An output parameter does not create a new storage location.</span></span> <span data-ttu-id="8df36-155">Stattdessen stellt ein Output-Parameter am gleichen Speicherort wie die Variable als Argument im Funktionsaufruf Member oder Delegaten angegeben.</span><span class="sxs-lookup"><span data-stu-id="8df36-155">Instead, an output parameter represents the same storage location as the variable given as the argument in the function member or delegate invocation.</span></span> <span data-ttu-id="8df36-156">Daher ist der Wert des Output-Parameter immer identisch mit der zugrunde liegenden Variablen.</span><span class="sxs-lookup"><span data-stu-id="8df36-156">Thus, the value of an output parameter is always the same as the underlying variable.</span></span>

<span data-ttu-id="8df36-157">Die folgenden Regeln für definitive Zuweisungen gelten für Ausgabeparameter.</span><span class="sxs-lookup"><span data-stu-id="8df36-157">The following definite assignment rules apply to output parameters.</span></span> <span data-ttu-id="8df36-158">Beachten Sie die Regeln für Verweisparameter, die in beschriebenen [Verweisparameter](variables.md#reference-parameters).</span><span class="sxs-lookup"><span data-stu-id="8df36-158">Note the different rules for reference parameters described in [Reference parameters](variables.md#reference-parameters).</span></span>

*  <span data-ttu-id="8df36-159">Eine Variable muss nicht definitiv zugewiesen werden, bevor es Delegataufruf oder können als Output-Parameter in einem Funktionsmember übergeben werden.</span><span class="sxs-lookup"><span data-stu-id="8df36-159">A variable need not be definitely assigned before it can be passed as an output parameter in a function member or delegate invocation.</span></span>
*  <span data-ttu-id="8df36-160">In diesem Ausführungspfad zugewiesen jede Variable, die übergeben wurde, als Ausgabeparameter betrachtet wird, gemäß dem normalen Abschluss einen Funktionsaufruf Member oder der Delegat wird.</span><span class="sxs-lookup"><span data-stu-id="8df36-160">Following the normal completion of a function member or delegate invocation, each variable that was passed as an output parameter is considered assigned in that execution path.</span></span>
*  <span data-ttu-id="8df36-161">In einer Funktionsmember der Member oder eine anonyme Funktion gilt ein Output-Parameter anfänglich kein Wert zugewiesen.</span><span class="sxs-lookup"><span data-stu-id="8df36-161">Within a function member or anonymous function, an output parameter is considered initially unassigned.</span></span>
*  <span data-ttu-id="8df36-162">Alle Ausgabeparameter einer Funktionsmember der Member oder eine anonyme Funktion muss definitiv zugewiesen ([definitive Zuweisung](variables.md#definite-assignment)) vor der Funktion Elements oder einer anonymen Funktion normalerweise zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="8df36-162">Every output parameter of a function member or anonymous function must be definitely assigned ([Definite assignment](variables.md#definite-assignment)) before the function member or anonymous function returns normally.</span></span>

<span data-ttu-id="8df36-163">Innerhalb eines Instanzkonstruktors eines Strukturtyps der `this` -Schlüsselwort verhält sich genau wie ein Output-Parameter des Strukturtyps ([diesen Zugriff](expressions.md#this-access)).</span><span class="sxs-lookup"><span data-stu-id="8df36-163">Within an instance constructor of a struct type, the `this` keyword behaves exactly as an output parameter of the struct type ([This access](expressions.md#this-access)).</span></span>

### <a name="local-variables"></a><span data-ttu-id="8df36-164">Lokale Variablen</span><span class="sxs-lookup"><span data-stu-id="8df36-164">Local variables</span></span>

<span data-ttu-id="8df36-165">Ein ***lokale Variable*** wird deklariert, indem eine *Local_variable_declaration*, die möglicherweise auftreten, eine *Block*, *For_statement*, eine *Switch_statement* oder *Using_statement*; oder durch eine *Foreach_statement* oder *Specific_catch_clause* für eine *Try_statement*.</span><span class="sxs-lookup"><span data-stu-id="8df36-165">A ***local variable*** is declared by a *local_variable_declaration*, which may occur in a *block*, a *for_statement*, a *switch_statement* or a *using_statement*; or by a *foreach_statement* or a *specific_catch_clause* for a *try_statement*.</span></span>

<span data-ttu-id="8df36-166">Die Lebensdauer einer lokalen Variablen ist der Teil der programmausführung, die während der Speicherung garantiert ist, dafür reserviert werden sollen.</span><span class="sxs-lookup"><span data-stu-id="8df36-166">The lifetime of a local variable is the portion of program execution during which storage is guaranteed to be reserved for it.</span></span> <span data-ttu-id="8df36-167">Diese Lebensdauer erstreckt sich über mindestens von Eintrag in der *Block*, *For_statement*, *Switch_statement*, *Using_statement*, *Foreach_statement*, oder *Specific_catch_clause* mit dem es zugeordnet ist, bis zur Ausführung dieser ist *Block*, *For_statement*, *Switch_statement*, *Using_statement*, *Foreach_statement*, oder *Specific_catch_clause* endet in keiner Weise.</span><span class="sxs-lookup"><span data-stu-id="8df36-167">This lifetime extends at least from entry into the *block*, *for_statement*, *switch_statement*, *using_statement*, *foreach_statement*, or *specific_catch_clause* with which it is associated, until execution of that *block*, *for_statement*, *switch_statement*, *using_statement*, *foreach_statement*, or *specific_catch_clause* ends in any way.</span></span> <span data-ttu-id="8df36-168">(Eingeben einer eingeschlossenen *Block* oder Aufrufen einer Methode wird angehalten, aber nicht beendet, Ausführung der aktuellen *Block*, *For_statement*, *Switch_statement* , *Using_statement*, *Foreach_statement*, oder *Specific_catch_clause*.) Wenn die lokale Variable, die von einer anonymen Funktion erfasst werden ([äußere Variablen erfasst](expressions.md#captured-outer-variables)), seine Lebensdauer mindestens erweitert, bis die Delegat- oder -Struktur, die von der anonymen Funktion, sowie alle anderen Objekte, die enthalten sind, erstellt die erfassten Variablen verweisen, sind für die Garbagecollection.</span><span class="sxs-lookup"><span data-stu-id="8df36-168">(Entering an enclosed *block* or calling a method suspends, but does not end, execution of the current *block*, *for_statement*, *switch_statement*, *using_statement*, *foreach_statement*, or *specific_catch_clause*.) If the local variable is captured by an anonymous function ([Captured outer variables](expressions.md#captured-outer-variables)), its lifetime extends at least until the delegate or expression tree created from the anonymous function, along with any other objects that come to reference the captured variable, are eligible for garbage collection.</span></span>

<span data-ttu-id="8df36-169">Wenn das übergeordnete Element *Block*, *For_statement*, *Switch_statement*, *Using_statement*, *Foreach_statement*, oder *Specific_catch_clause* eingegeben wird rekursiv, eine neue Instanz der lokalen Variablen wird jedes Mal erstellt und die zugehörige *Local_variable_initializer*ausgewertet, falls vorhanden, ist jedes Mal.</span><span class="sxs-lookup"><span data-stu-id="8df36-169">If the parent *block*, *for_statement*, *switch_statement*, *using_statement*, *foreach_statement*, or *specific_catch_clause* is entered recursively, a new instance of the local variable is created each time, and its *local_variable_initializer*, if any, is evaluated each time.</span></span>

<span data-ttu-id="8df36-170">Eine lokale Variable, die eingeführt werden, indem eine *Local_variable_declaration* wird nicht automatisch initialisiert und somit hat keinen Standardwert.</span><span class="sxs-lookup"><span data-stu-id="8df36-170">A local variable introduced by a *local_variable_declaration* is not automatically initialized and thus has no default value.</span></span> <span data-ttu-id="8df36-171">Für definitive Zuweisungen zu überprüfen, eine lokale Variable eingeführt, durch eine *Local_variable_declaration* gilt anfänglich kein Wert zugewiesen.</span><span class="sxs-lookup"><span data-stu-id="8df36-171">For the purpose of definite assignment checking, a local variable introduced by a *local_variable_declaration* is considered initially unassigned.</span></span> <span data-ttu-id="8df36-172">Ein *Local_variable_declaration* eventuell eine *Local_variable_initializer*, in diesem Fall die Variable definitiv zugewiesen erst nach der Initialisierungsausdruck gilt ([ Deklarationsanweisungen](variables.md#declaration-statements)).</span><span class="sxs-lookup"><span data-stu-id="8df36-172">A *local_variable_declaration* may include a *local_variable_initializer*, in which case the variable is considered definitely assigned only after the initializing expression ([Declaration statements](variables.md#declaration-statements)).</span></span>

<span data-ttu-id="8df36-173">Innerhalb des Bereichs einer lokalen Variablen, die eingeführt werden, indem eine *Local_variable_declaration*, es ist ein Fehler während der Kompilierung zu verweisen auf die lokale Variable in der Lage, Text vor dessen *Local_variable_declarator*.</span><span class="sxs-lookup"><span data-stu-id="8df36-173">Within the scope of a local variable introduced by a *local_variable_declaration*, it is a compile-time error to refer to that local variable in a textual position that precedes its *local_variable_declarator*.</span></span> <span data-ttu-id="8df36-174">Wenn es sich bei der Deklaration lokale Variable implizit ist ([lokale Variablendeklarationen](statements.md#local-variable-declarations)), es ist auch ein Fehler zum Verweisen auf die Variable in der *Local_variable_declarator*.</span><span class="sxs-lookup"><span data-stu-id="8df36-174">If the local variable declaration is implicit ([Local variable declarations](statements.md#local-variable-declarations)), it is also an error to refer to the variable within its *local_variable_declarator*.</span></span>

<span data-ttu-id="8df36-175">Eine lokale Variable, die eingeführt werden, indem eine *Foreach_statement* oder *Specific_catch_clause* gilt im gesamten Bereich definitiv zugewiesen.</span><span class="sxs-lookup"><span data-stu-id="8df36-175">A local variable introduced by a *foreach_statement* or a *specific_catch_clause* is considered definitely assigned in its entire scope.</span></span>

<span data-ttu-id="8df36-176">Die tatsächliche Lebensdauer einer lokalen Variablen ist implementierungsabhängig.</span><span class="sxs-lookup"><span data-stu-id="8df36-176">The actual lifetime of a local variable is implementation-dependent.</span></span> <span data-ttu-id="8df36-177">Beispielsweise kann ein Compiler statisch bestimmen, dass eine lokale Variable in einem Block nur für einen kleinen Teil des Blocks verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="8df36-177">For example, a compiler might statically determine that a local variable in a block is only used for a small portion of that block.</span></span> <span data-ttu-id="8df36-178">Verwenden diese Analyse, kann der Compiler Code generieren, die den Wert der Variablen Speicher müssen eine kürzere Lebensdauer hat als des enthaltenden Blocks ergeben.</span><span class="sxs-lookup"><span data-stu-id="8df36-178">Using this analysis, the compiler could generate code that results in the variable's storage having a shorter lifetime than its containing block.</span></span>

<span data-ttu-id="8df36-179">Verweist auf eine lokale Verweisvariable Speicher freigegeben wird, unabhängig von der Lebensdauer der Verweis auf lokale Variablen ([automatische Speicherverwaltung](basic-concepts.md#automatic-memory-management)).</span><span class="sxs-lookup"><span data-stu-id="8df36-179">The storage referred to by a local reference variable is reclaimed independently of the lifetime of that local reference variable ([Automatic memory management](basic-concepts.md#automatic-memory-management)).</span></span>

## <a name="default-values"></a><span data-ttu-id="8df36-180">Standardwerte</span><span class="sxs-lookup"><span data-stu-id="8df36-180">Default values</span></span>

<span data-ttu-id="8df36-181">Die folgenden Kategorien von Variablen werden automatisch auf ihre Standardwerte initialisiert:</span><span class="sxs-lookup"><span data-stu-id="8df36-181">The following categories of variables are automatically initialized to their default values:</span></span>

*  <span data-ttu-id="8df36-182">Statische Variablen.</span><span class="sxs-lookup"><span data-stu-id="8df36-182">Static variables.</span></span>
*  <span data-ttu-id="8df36-183">Instanzvariablen von Klasseninstanzen.</span><span class="sxs-lookup"><span data-stu-id="8df36-183">Instance variables of class instances.</span></span>
*  <span data-ttu-id="8df36-184">Elemente des Arrays.</span><span class="sxs-lookup"><span data-stu-id="8df36-184">Array elements.</span></span>

<span data-ttu-id="8df36-185">Der Standardwert einer Variablen, hängt vom Typ der Variable und wird wie folgt bestimmt:</span><span class="sxs-lookup"><span data-stu-id="8df36-185">The default value of a variable depends on the type of the variable and is determined as follows:</span></span>

*  <span data-ttu-id="8df36-186">Für eine Variable vom eine *Value_type*, der Standardwert ist identisch mit dem Wert berechnet, indem die *Value_type*des Standard-Konstruktor ([Standardkonstruktoren](types.md#default-constructors)).</span><span class="sxs-lookup"><span data-stu-id="8df36-186">For a variable of a *value_type*, the default value is the same as the value computed by the *value_type*'s default constructor ([Default constructors](types.md#default-constructors)).</span></span>
*  <span data-ttu-id="8df36-187">Für eine Variable mit einem *Reference_type*, der Standardwert ist `null`.</span><span class="sxs-lookup"><span data-stu-id="8df36-187">For a variable of a *reference_type*, the default value is `null`.</span></span>

<span data-ttu-id="8df36-188">Initialisierung mit Standardwerten erfolgt in der Regel, dass des Speicher-Managers oder Garbage Collection Arbeitsspeicher, um alle Bits auf 0 initialisiert werden, bevor es für die Verwendung zugeordnet ist.</span><span class="sxs-lookup"><span data-stu-id="8df36-188">Initialization to default values is typically done by having the memory manager or garbage collector initialize memory to all-bits-zero before it is allocated for use.</span></span> <span data-ttu-id="8df36-189">Aus diesem Grund ist es sinnvoll, alle Bits auf 0 zu verwenden, um die null-Verweis darstellen.</span><span class="sxs-lookup"><span data-stu-id="8df36-189">For this reason, it is convenient to use all-bits-zero to represent the null reference.</span></span>

## <a name="definite-assignment"></a><span data-ttu-id="8df36-190">Definitive Zuweisung</span><span class="sxs-lookup"><span data-stu-id="8df36-190">Definite assignment</span></span>

<span data-ttu-id="8df36-191">An einer bestimmten Position in den ausführbaren Code, der ein Funktionsmember werden soll, eine Variable gilt als ***definitiv zugewiesen*** Wenn der Compiler, durch eine bestimmte statische Flussanalyse nachweisen kann ([präzise Regeln für definitive ermitteln Zuweisung](variables.md#precise-rules-for-determining-definite-assignment)), die die Variable automatisch initialisiert wurde oder das Ziel mindestens eine Zuweisung wurde.</span><span class="sxs-lookup"><span data-stu-id="8df36-191">At a given location in the executable code of a function member, a variable is said to be ***definitely assigned*** if the compiler can prove, by a particular static flow analysis ([Precise rules for determining definite assignment](variables.md#precise-rules-for-determining-definite-assignment)), that the variable has been automatically initialized or has been the target of at least one assignment.</span></span> <span data-ttu-id="8df36-192">Informell erwähnt, werden die Regeln für definitive Zuweisungen:</span><span class="sxs-lookup"><span data-stu-id="8df36-192">Informally stated, the rules of definite assignment are:</span></span>

*  <span data-ttu-id="8df36-193">Ein anfänglich zugewiesene Variable ([anfänglich zugewiesene Variablen](variables.md#initially-assigned-variables)) immer als definitiv zugewiesen.</span><span class="sxs-lookup"><span data-stu-id="8df36-193">An initially assigned variable ([Initially assigned variables](variables.md#initially-assigned-variables)) is always considered definitely assigned.</span></span>
*  <span data-ttu-id="8df36-194">Ein anfänglich nicht zugewiesene Variable ([anfänglich nicht zugewiesene Variablen](variables.md#initially-unassigned-variables)) gilt, definitiv zugewiesen an einer bestimmten Position wenn sämtliche möglichen ausführungswege zu diesem Speicherort mindestens eine der folgenden enthalten:</span><span class="sxs-lookup"><span data-stu-id="8df36-194">An initially unassigned variable ([Initially unassigned variables](variables.md#initially-unassigned-variables)) is considered definitely assigned at a given location if all possible execution paths leading to that location contain at least one of the following:</span></span>
    * <span data-ttu-id="8df36-195">Eine einfache Zuweisung ([einfache Zuweisung](expressions.md#simple-assignment)) in dem die Variable der linke Operand ist.</span><span class="sxs-lookup"><span data-stu-id="8df36-195">A simple assignment ([Simple assignment](expressions.md#simple-assignment)) in which the variable is the left operand.</span></span>
    * <span data-ttu-id="8df36-196">Ein Aufrufausdruck ([Aufrufausdrücke](expressions.md#invocation-expressions)) oder Objekterstellungsausdruck ([Erstellung Objektausdrücke](expressions.md#object-creation-expressions)), die die Variable als Output-Parameter übergibt.</span><span class="sxs-lookup"><span data-stu-id="8df36-196">An invocation expression ([Invocation expressions](expressions.md#invocation-expressions)) or object creation expression ([Object creation expressions](expressions.md#object-creation-expressions)) that passes the variable as an output parameter.</span></span>
    * <span data-ttu-id="8df36-197">Für eine lokale Variable einer lokalen Variablendeklaration ([lokale Variablendeklarationen](statements.md#local-variable-declarations)), die einem Variableninitialisierer enthält.</span><span class="sxs-lookup"><span data-stu-id="8df36-197">For a local variable, a local variable declaration ([Local variable declarations](statements.md#local-variable-declarations)) that includes a variable initializer.</span></span>

<span data-ttu-id="8df36-198">Die formale Spezifikation, die zugrunde liegende die oben genannten informellen Regeln finden Sie im [anfänglich zugewiesene Variablen](variables.md#initially-assigned-variables), [anfänglich nicht zugewiesene Variablen](variables.md#initially-unassigned-variables), und [präzise Regeln für die Bestimmung definitive Zuweisung](variables.md#precise-rules-for-determining-definite-assignment).</span><span class="sxs-lookup"><span data-stu-id="8df36-198">The formal specification underlying the above informal rules is described in [Initially assigned variables](variables.md#initially-assigned-variables), [Initially unassigned variables](variables.md#initially-unassigned-variables), and [Precise rules for determining definite assignment](variables.md#precise-rules-for-determining-definite-assignment).</span></span>

<span data-ttu-id="8df36-199">Die definitive Zuweisung Instanzvariablen der Status einer *Struct_type* Variable einzeln sowie als zusammen nachverfolgt werden.</span><span class="sxs-lookup"><span data-stu-id="8df36-199">The definite assignment states of instance variables of a *struct_type* variable are tracked individually as well as collectively.</span></span> <span data-ttu-id="8df36-200">In den oben genannten Regeln zusätzliche die folgenden Regeln gelten für *Struct_type* Variablen und ihre Instanzvariablen:</span><span class="sxs-lookup"><span data-stu-id="8df36-200">In additional to the rules above, the following rules apply to *struct_type* variables and their instance variables:</span></span>

*  <span data-ttu-id="8df36-201">Eine Instanzvariable gilt als definitiv zugewiesen, wenn die enthaltende *Struct_type* gilt als Variable definitiv zugewiesen.</span><span class="sxs-lookup"><span data-stu-id="8df36-201">An instance variable is considered definitely assigned if its containing *struct_type* variable is considered definitely assigned.</span></span>
*  <span data-ttu-id="8df36-202">Ein *Struct_type* Variablen wird definitiv zugewiesenen betrachtet, wenn jede der zugehörigen Instanzvariablen definitiv zugewiesenen betrachtet wird.</span><span class="sxs-lookup"><span data-stu-id="8df36-202">A *struct_type* variable is considered definitely assigned if each of its instance variables is considered definitely assigned.</span></span>

<span data-ttu-id="8df36-203">Definitive Zuweisung ist eine Voraussetzung in den folgenden Kontexten:</span><span class="sxs-lookup"><span data-stu-id="8df36-203">Definite assignment is a requirement in the following contexts:</span></span>

*  <span data-ttu-id="8df36-204">Eine Variable muss definitiv an jedem Standort zugewiesen werden, in denen der Wert abgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="8df36-204">A variable must be definitely assigned at each location where its value is obtained.</span></span> <span data-ttu-id="8df36-205">Dadurch wird sichergestellt, dass nicht definierte Werte nie auftreten.</span><span class="sxs-lookup"><span data-stu-id="8df36-205">This ensures that undefined values never occur.</span></span> <span data-ttu-id="8df36-206">Das Vorhandensein einer Variablen in einem Ausdruck wird betrachtet, um den Wert der Variablen an, außer wenn abzurufen</span><span class="sxs-lookup"><span data-stu-id="8df36-206">The occurrence of a variable in an expression is considered to obtain the value of the variable, except when</span></span>
    * <span data-ttu-id="8df36-207">die Variable wird der linke Operand des eine einfache Zuweisung,</span><span class="sxs-lookup"><span data-stu-id="8df36-207">the variable is the left operand of a simple assignment,</span></span>
    * <span data-ttu-id="8df36-208">die Variable als ein Output-Parameter übergeben wird oder</span><span class="sxs-lookup"><span data-stu-id="8df36-208">the variable is passed as an output parameter, or</span></span>
    * <span data-ttu-id="8df36-209">die Variable ist ein *Struct_type* Variable und tritt ein, wenn der linke Operand des Memberzugriff.</span><span class="sxs-lookup"><span data-stu-id="8df36-209">the variable is a *struct_type* variable and occurs as the left operand of a member access.</span></span>
*  <span data-ttu-id="8df36-210">Eine Variable muss definitiv an jedem Standort zugewiesen werden, in denen sie als Verweisparameter übergeben wird.</span><span class="sxs-lookup"><span data-stu-id="8df36-210">A variable must be definitely assigned at each location where it is passed as a reference parameter.</span></span> <span data-ttu-id="8df36-211">Dadurch wird sichergestellt, dass die aufgerufene Funktionsmember den Verweisparameter, der ursprünglich zugewiesenen berücksichtigt werden kann.</span><span class="sxs-lookup"><span data-stu-id="8df36-211">This ensures that the function member being invoked can consider the reference parameter initially assigned.</span></span>
*  <span data-ttu-id="8df36-212">Ein Funktionsmember alle Ausgabeparameter müssen an jedem Standort, der das Funktionselement, bei dem zurück definitiv zugewiesen werden (über eine `return` Anweisung oder durch die Ausführung, die das Ende der Hauptteil der Funktion Mitglied erreicht).</span><span class="sxs-lookup"><span data-stu-id="8df36-212">All output parameters of a function member must be definitely assigned at each location where the function member returns (through a `return` statement or through execution reaching the end of the function member body).</span></span> <span data-ttu-id="8df36-213">Dadurch wird sichergestellt, dass Funktionsmember keine nicht definierte Werte in der Output-Parameter zurückgeben, sodass des Compilers einen Member-Funktionsaufruf berücksichtigt, der eine Variable als Output-Parameter akzeptiert wird, der eine Zuweisung zur Variablen entspricht.</span><span class="sxs-lookup"><span data-stu-id="8df36-213">This ensures that function members do not return undefined values in output parameters, thus enabling the compiler to consider a function member invocation that takes a variable as an output parameter equivalent to an assignment to the variable.</span></span>
*  <span data-ttu-id="8df36-214">Die `this` der Variable ein *Struct_type* Instanzkonstruktor muss definitiv zugewiesen werden, an jedem Speicherort, in denen dieser Instanzkonstruktor zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="8df36-214">The `this` variable of a *struct_type* instance constructor must be definitely assigned at each location where that instance constructor returns.</span></span>

### <a name="initially-assigned-variables"></a><span data-ttu-id="8df36-215">Ursprünglich zugewiesenen Variablen</span><span class="sxs-lookup"><span data-stu-id="8df36-215">Initially assigned variables</span></span>

<span data-ttu-id="8df36-216">Die folgenden Kategorien von Variablen sind klassifiziert als ursprünglich zugewiesen:</span><span class="sxs-lookup"><span data-stu-id="8df36-216">The following categories of variables are classified as initially assigned:</span></span>

*  <span data-ttu-id="8df36-217">Statische Variablen.</span><span class="sxs-lookup"><span data-stu-id="8df36-217">Static variables.</span></span>
*  <span data-ttu-id="8df36-218">Instanzvariablen von Klasseninstanzen.</span><span class="sxs-lookup"><span data-stu-id="8df36-218">Instance variables of class instances.</span></span>
*  <span data-ttu-id="8df36-219">Instanzvariablen des ursprünglich zugewiesenen Strukturvariablen.</span><span class="sxs-lookup"><span data-stu-id="8df36-219">Instance variables of initially assigned struct variables.</span></span>
*  <span data-ttu-id="8df36-220">Elemente des Arrays.</span><span class="sxs-lookup"><span data-stu-id="8df36-220">Array elements.</span></span>
*  <span data-ttu-id="8df36-221">-Parameter.</span><span class="sxs-lookup"><span data-stu-id="8df36-221">Value parameters.</span></span>
*  <span data-ttu-id="8df36-222">Reference-Parameter.</span><span class="sxs-lookup"><span data-stu-id="8df36-222">Reference parameters.</span></span>
*  <span data-ttu-id="8df36-223">Variablen, die in einem `catch` Klausel oder eine `foreach` Anweisung.</span><span class="sxs-lookup"><span data-stu-id="8df36-223">Variables declared in a `catch` clause or a `foreach` statement.</span></span>

### <a name="initially-unassigned-variables"></a><span data-ttu-id="8df36-224">Ursprünglich zugewiesenen Variablen</span><span class="sxs-lookup"><span data-stu-id="8df36-224">Initially unassigned variables</span></span>

<span data-ttu-id="8df36-225">Die folgenden Kategorien von Variablen sind, wie es ursprünglich nicht zugewiesene klassifiziert:</span><span class="sxs-lookup"><span data-stu-id="8df36-225">The following categories of variables are classified as initially unassigned:</span></span>

*  <span data-ttu-id="8df36-226">Instanzvariablen von Strukturvariablen anfänglich kein Wert zugewiesen.</span><span class="sxs-lookup"><span data-stu-id="8df36-226">Instance variables of initially unassigned struct variables.</span></span>
*  <span data-ttu-id="8df36-227">Output-Parameter, einschließlich der `this` Struktur Instanzkonstruktoren Variable.</span><span class="sxs-lookup"><span data-stu-id="8df36-227">Output parameters, including the `this` variable of struct instance constructors.</span></span>
*  <span data-ttu-id="8df36-228">Deklariert lokale Variablen, mit Ausnahme einer `catch` Klausel oder eine `foreach` Anweisung.</span><span class="sxs-lookup"><span data-stu-id="8df36-228">Local variables, except those declared in a `catch` clause or a `foreach` statement.</span></span>

### <a name="precise-rules-for-determining-definite-assignment"></a><span data-ttu-id="8df36-229">Präzise Regeln für definitive Zuweisungen ermitteln</span><span class="sxs-lookup"><span data-stu-id="8df36-229">Precise rules for determining definite assignment</span></span>

<span data-ttu-id="8df36-230">Um zu bestimmen, dass jede verwendete Variable definitiv zugewiesen ist, muss der Compiler einen Prozess verwenden, der mit dem in diesem Abschnitt beschriebenen entspricht.</span><span class="sxs-lookup"><span data-stu-id="8df36-230">In order to determine that each used variable is definitely assigned, the compiler must use a process that is equivalent to the one described in this section.</span></span>

<span data-ttu-id="8df36-231">Der Compiler verarbeitet den Text der jeder Funktionsmember, die eine oder mehrere anfänglich nicht zugewiesene Variablen.</span><span class="sxs-lookup"><span data-stu-id="8df36-231">The compiler processes the body of each function member that has one or more initially unassigned variables.</span></span> <span data-ttu-id="8df36-232">Für jede anfänglich nicht zugewiesene Variable *v*, der Compiler bestimmt eine ***definitive zuweisungszustand*** für *v* an jedem der folgenden Punkte in der Funktionsmember der Member:</span><span class="sxs-lookup"><span data-stu-id="8df36-232">For each initially unassigned variable *v*, the compiler determines a ***definite assignment state*** for *v* at each of the following points in the function member:</span></span>

*  <span data-ttu-id="8df36-233">Am Anfang jeder Anweisung</span><span class="sxs-lookup"><span data-stu-id="8df36-233">At the beginning of each statement</span></span>
*  <span data-ttu-id="8df36-234">Am Endpunkt ([Endpunkte und Erreichbarkeit](statements.md#end-points-and-reachability)) der einzelnen Anweisungen</span><span class="sxs-lookup"><span data-stu-id="8df36-234">At the end point ([End points and reachability](statements.md#end-points-and-reachability)) of each statement</span></span>
*  <span data-ttu-id="8df36-235">Für jeden Bogen übergibt die Steuerung an eine andere Anweisung oder den Endpunkt einer Anweisung</span><span class="sxs-lookup"><span data-stu-id="8df36-235">On each arc which transfers control to another statement or to the end point of a statement</span></span>
*  <span data-ttu-id="8df36-236">Am Anfang jeder Ausdruck</span><span class="sxs-lookup"><span data-stu-id="8df36-236">At the beginning of each expression</span></span>
*  <span data-ttu-id="8df36-237">Am Ende jeder Ausdruck</span><span class="sxs-lookup"><span data-stu-id="8df36-237">At the end of each expression</span></span>

<span data-ttu-id="8df36-238">Die definitive Zuweisung Zustand des *v* kann es sich um:</span><span class="sxs-lookup"><span data-stu-id="8df36-238">The definite assignment state of *v* can be either:</span></span>

*  <span data-ttu-id="8df36-239">Definitiv zugewiesen.</span><span class="sxs-lookup"><span data-stu-id="8df36-239">Definitely assigned.</span></span> <span data-ttu-id="8df36-240">Dies bedeutet, dass alle möglichen Flows an diesem Punkt ist *v* einen Wert zugewiesen wurde.</span><span class="sxs-lookup"><span data-stu-id="8df36-240">This indicates that on all possible control flows to this point, *v* has been assigned a value.</span></span>
*  <span data-ttu-id="8df36-241">Nicht definitiv zugewiesen.</span><span class="sxs-lookup"><span data-stu-id="8df36-241">Not definitely assigned.</span></span> <span data-ttu-id="8df36-242">Für den Status einer Variablen am Ende ein Ausdruck vom Typ `bool`, der Status einer Variablen, die Mai wird nicht definitiv zugewiesen (jedoch nicht notwendigerweise) fallen in eine der folgenden untergeordneten Status:</span><span class="sxs-lookup"><span data-stu-id="8df36-242">For the state of a variable at the end of an expression of type `bool`, the state of a variable that isn't definitely assigned may (but doesn't necessarily) fall into one of the following sub-states:</span></span>
    * <span data-ttu-id="8df36-243">Nach der als TRUE ausgewertete Ausdruck definitiv zugewiesen.</span><span class="sxs-lookup"><span data-stu-id="8df36-243">Definitely assigned after true expression.</span></span> <span data-ttu-id="8df36-244">Dieser Status Gibt an, dass *v* ist definitiv zugewiesen werden, wenn der boolesche Ausdruck als True ausgewertet, aber es nicht notwendigerweise zugewiesen ist, wenn der boolesche Ausdruck als "false" ausgewertet.</span><span class="sxs-lookup"><span data-stu-id="8df36-244">This state indicates that *v* is definitely assigned if the boolean expression evaluated as true, but is not necessarily assigned if the boolean expression evaluated as false.</span></span>
    * <span data-ttu-id="8df36-245">Nach der false-Ausdruck definitiv zugewiesen.</span><span class="sxs-lookup"><span data-stu-id="8df36-245">Definitely assigned after false expression.</span></span> <span data-ttu-id="8df36-246">Dieser Status Gibt an, dass *v* ist definitiv zugewiesen werden, wenn der boolesche Ausdruck als "false" ausgewertet, aber es nicht notwendigerweise zugewiesen ist, wenn der boolesche Ausdruck als "true" ausgewertet.</span><span class="sxs-lookup"><span data-stu-id="8df36-246">This state indicates that *v* is definitely assigned if the boolean expression evaluated as false, but is not necessarily assigned if the boolean expression evaluated as true.</span></span>

<span data-ttu-id="8df36-247">Die folgenden Regeln bestimmen, wie der Status einer Variablen *v* richtet sich an jedem Standort.</span><span class="sxs-lookup"><span data-stu-id="8df36-247">The following rules govern how the state of a variable *v* is determined at each location.</span></span>

#### <a name="general-rules-for-statements"></a><span data-ttu-id="8df36-248">Allgemeine Regeln für Anweisungen</span><span class="sxs-lookup"><span data-stu-id="8df36-248">General rules for statements</span></span>

*  <span data-ttu-id="8df36-249">*V* wird am Anfang eines Funktionsrumpfs der Member nicht definitiv zugewiesen.</span><span class="sxs-lookup"><span data-stu-id="8df36-249">*v* is not definitely assigned at the beginning of a function member body.</span></span>
*  <span data-ttu-id="8df36-250">*V* wird zu Beginn nicht erreichbare Anweisungen definitiv zugewiesen.</span><span class="sxs-lookup"><span data-stu-id="8df36-250">*v* is definitely assigned at the beginning of any unreachable statement.</span></span>
*  <span data-ttu-id="8df36-251">Die definitive Zuweisung Zustand des *v* am Anfang eine weitere Anweisung richtet sich nach Überprüfen des Zustands definitive Zuweisung *v* auf alle Steuerelement-Flow-Übertragungen, die den Anfang, das als Ziel -Anweisung.</span><span class="sxs-lookup"><span data-stu-id="8df36-251">The definite assignment state of *v* at the beginning of any other statement is determined by checking the definite assignment state of *v* on all control flow transfers that target the beginning of that statement.</span></span> <span data-ttu-id="8df36-252">Wenn (und nur wenn) *v* definitiv zugewiesen, auf alle diese Control Flow-Übertragungen, klicken Sie dann *v* definitiv zugewiesen, die zu Beginn der Anweisung.</span><span class="sxs-lookup"><span data-stu-id="8df36-252">If (and only if) *v* is definitely assigned on all such control flow transfers, then *v* is definitely assigned at the beginning of the statement.</span></span> <span data-ttu-id="8df36-253">Der Satz von möglichen Flow Übertragungen wird bestimmt, auf die gleiche Weise wie bei der Anweisung Erreichbarkeit überprüfen ([Endpunkte und Erreichbarkeit](statements.md#end-points-and-reachability)).</span><span class="sxs-lookup"><span data-stu-id="8df36-253">The set of possible control flow transfers is determined in the same way as for checking statement reachability ([End points and reachability](statements.md#end-points-and-reachability)).</span></span>
*  <span data-ttu-id="8df36-254">Die definitive Zuweisung Zustand des *v* am Endpunkt eines Blocks `checked`, `unchecked`, `if`, `while`, `do`, `for`, `foreach`, `lock`, `using`, oder `switch` Anweisung richtet sich nach der Überprüfung des definitive Zuweisung *v* auf alle Steuerelement-Flow-Übertragungen, die auf den Endpunkt, der diese Anweisung abzielen.</span><span class="sxs-lookup"><span data-stu-id="8df36-254">The definite assignment state of *v* at the end point of a block, `checked`, `unchecked`, `if`, `while`, `do`, `for`, `foreach`, `lock`, `using`, or `switch` statement is determined by checking the definite assignment state of *v* on all control flow transfers that target the end point of that statement.</span></span> <span data-ttu-id="8df36-255">Wenn *v* definitiv zugewiesen, auf alle diese Control Flow-Übertragungen, klicken Sie dann *v* definitiv auf den Endpunkt der Anweisung zugewiesen wird.</span><span class="sxs-lookup"><span data-stu-id="8df36-255">If *v* is definitely assigned on all such control flow transfers, then *v* is definitely assigned at the end point of the statement.</span></span> <span data-ttu-id="8df36-256">Andernfalls *v* am Endpunkt der Anweisung nicht definitiv zugewiesen.</span><span class="sxs-lookup"><span data-stu-id="8df36-256">Otherwise; *v* is not definitely assigned at the end point of the statement.</span></span> <span data-ttu-id="8df36-257">Der Satz von möglichen Flow Übertragungen wird bestimmt, auf die gleiche Weise wie bei der Anweisung Erreichbarkeit überprüfen ([Endpunkte und Erreichbarkeit](statements.md#end-points-and-reachability)).</span><span class="sxs-lookup"><span data-stu-id="8df36-257">The set of possible control flow transfers is determined in the same way as for checking statement reachability ([End points and reachability](statements.md#end-points-and-reachability)).</span></span>

#### <a name="block-statements-checked-and-unchecked-statements"></a><span data-ttu-id="8df36-258">Block-Anweisungen, die dieses Kontrollkästchen aktiviert, und deaktiviert-Anweisungen</span><span class="sxs-lookup"><span data-stu-id="8df36-258">Block statements, checked, and unchecked statements</span></span>

<span data-ttu-id="8df36-259">Die definitive Zuweisung Zustand des *v* Übertragung an die erste Anweisung der Anweisungsliste im-Block (oder am Ende des Blocks, wenn die Anweisungsliste leer ist) für das Steuerelement ist identisch mit der Anweisung definitive Zuweisung *v* vor dem Block, `checked`, oder `unchecked` Anweisung.</span><span class="sxs-lookup"><span data-stu-id="8df36-259">The definite assignment state of *v* on the control transfer to the first statement of the statement list in the block (or to the end point of the block, if the statement list is empty) is the same as the definite assignment statement of *v* before the block, `checked`, or `unchecked` statement.</span></span>

#### <a name="expression-statements"></a><span data-ttu-id="8df36-260">Ausdrucksanweisungen</span><span class="sxs-lookup"><span data-stu-id="8df36-260">Expression statements</span></span>

<span data-ttu-id="8df36-261">Für eine Ausdrucksanweisung *Stmt* , der den Ausdruck aus *Expr*:</span><span class="sxs-lookup"><span data-stu-id="8df36-261">For an expression statement *stmt* that consists of the expression *expr*:</span></span>

*  <span data-ttu-id="8df36-262">*V* hat den gleichen definitive zuweisungszustand am Anfang des *Expr* wie am Anfang des *Stmt*.</span><span class="sxs-lookup"><span data-stu-id="8df36-262">*v* has the same definite assignment state at the beginning of *expr* as at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="8df36-263">Wenn *v* Wenn am Ende der definitiv zugewiesen *Expr*, es ist definitiv zugewiesen, auf den Endpunkt des *Stmt*; andernfalls ist es nicht auf jeden Fall an den Endpunkt des zugewiesen*Stmt*.</span><span class="sxs-lookup"><span data-stu-id="8df36-263">If *v* if definitely assigned at the end of *expr*, it is definitely assigned at the end point of *stmt*; otherwise; it is not definitely assigned at the end point of *stmt*.</span></span>

#### <a name="declaration-statements"></a><span data-ttu-id="8df36-264">Deklarationsanweisungen</span><span class="sxs-lookup"><span data-stu-id="8df36-264">Declaration statements</span></span>

*  <span data-ttu-id="8df36-265">Wenn *Stmt* wird von eine deklarationsanweisung ohne Initialisierer, dann *v* hat den gleichen definitive zuweisungszustand an den Endpunkt des *Stmt* wie am Anfang des *Stmt*.</span><span class="sxs-lookup"><span data-stu-id="8df36-265">If *stmt* is a declaration statement without initializers, then *v* has the same definite assignment state at the end point of *stmt* as at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="8df36-266">Wenn *Stmt* befindet sich auf eine deklarationsanweisung mit Initialisierern, klicken Sie dann die definitive Zuweisung im Status *v* wird bestimmt, als ob *Stmt* wurden eine Anweisungsliste, mit der eine Zuordnung Anweisung für jede Deklaration mit einem Initialisierer (in der Reihenfolge der Deklaration).</span><span class="sxs-lookup"><span data-stu-id="8df36-266">If *stmt* is a declaration statement with initializers, then the definite assignment state for *v* is determined as if *stmt* were a statement list, with one assignment statement for each declaration with an initializer (in the order of declaration).</span></span>

#### <a name="if-statements"></a><span data-ttu-id="8df36-267">Wenn Anweisungen</span><span class="sxs-lookup"><span data-stu-id="8df36-267">If statements</span></span>

<span data-ttu-id="8df36-268">Für eine `if` Anweisung *Stmt* des Formulars:</span><span class="sxs-lookup"><span data-stu-id="8df36-268">For an `if` statement *stmt* of the form:</span></span>
```csharp
if ( expr ) then_stmt else else_stmt
```

*  <span data-ttu-id="8df36-269">*V* hat den gleichen definitive zuweisungszustand am Anfang des *Expr* wie am Anfang des *Stmt*.</span><span class="sxs-lookup"><span data-stu-id="8df36-269">*v* has the same definite assignment state at the beginning of *expr* as at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="8df36-270">Wenn *v* definitiv zugewiesen, am Ende der *Expr*, und klicken Sie dann sie definitiv zugewiesen ist, auf die Steuerelement-Flow-Übertragung an *Then_stmt* und entweder *Else_stmt*  oder der Endpunkt des *Stmt* , falls keine else-Klausel vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="8df36-270">If *v* is definitely assigned at the end of *expr*, then it is definitely assigned on the control flow transfer to *then_stmt* and to either *else_stmt* or to the end-point of *stmt* if there is no else clause.</span></span>
*  <span data-ttu-id="8df36-271">Wenn *v* hat den Status "definitiv zugewiesen nach" true "Ausdruck" am Ende der *Expr*, und klicken Sie dann sie definitiv zugewiesen ist, auf die Steuerelement-Flow-Übertragung an *Then_stmt*, und nicht definitiv zugewiesen, auf die Steuerelement-Flow-Übertragung entweder *Else_stmt* oder der Endpunkt des *Stmt* , falls keine else-Klausel vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="8df36-271">If *v* has the state "definitely assigned after true expression" at the end of *expr*, then it is definitely assigned on the control flow transfer to *then_stmt*, and not definitely assigned on the control flow transfer to either *else_stmt* or to the end-point of *stmt* if there is no else clause.</span></span>
*  <span data-ttu-id="8df36-272">Wenn *v* hat den Status "definitiv zugewiesen nach" false "Ausdruck" am Ende der *Expr*, und klicken Sie dann sie definitiv zugewiesen ist, auf die Steuerelement-Flow-Übertragung an *Else_stmt*, und nicht definitiv zugewiesen, auf die Steuerelement-Flow-Übertragung an *Then_stmt*.</span><span class="sxs-lookup"><span data-stu-id="8df36-272">If *v* has the state "definitely assigned after false expression" at the end of *expr*, then it is definitely assigned on the control flow transfer to *else_stmt*, and not definitely assigned on the control flow transfer to *then_stmt*.</span></span> <span data-ttu-id="8df36-273">Es ist definitiv zugewiesen, auf den Endpunkt des *Stmt* nur, wenn es an der Endpunkt des definitiv zugewiesen ist *Then_stmt*.</span><span class="sxs-lookup"><span data-stu-id="8df36-273">It is definitely assigned at the end-point of *stmt* if and only if it is definitely assigned at the end-point of *then_stmt*.</span></span>
*  <span data-ttu-id="8df36-274">Andernfalls *v* als nicht definitiv zugewiesen, auf die Steuerelement-Flow-Übertragung entweder die *Then_stmt* oder *Else_stmt*, oder der Endpunkt des  *Stmt* , falls keine else-Klausel vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="8df36-274">Otherwise, *v* is considered not definitely assigned on the control flow transfer to either the *then_stmt* or *else_stmt*, or to the end-point of *stmt* if there is no else clause.</span></span>

#### <a name="switch-statements"></a><span data-ttu-id="8df36-275">Switch-Anweisungen</span><span class="sxs-lookup"><span data-stu-id="8df36-275">Switch statements</span></span>

<span data-ttu-id="8df36-276">In einem `switch` Anweisung *Stmt* mit einem steuernden Ausdruck *Expr*:</span><span class="sxs-lookup"><span data-stu-id="8df36-276">In a `switch` statement *stmt* with a controlling expression *expr*:</span></span>

*  <span data-ttu-id="8df36-277">Die definitive Zuweisung Zustand des *v* am Anfang des *Expr* ist identisch mit den Status der *v* am Anfang des *Stmt*.</span><span class="sxs-lookup"><span data-stu-id="8df36-277">The definite assignment state of *v* at the beginning of *expr* is the same as the state of *v* at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="8df36-278">Die definitive Zuweisung Zustand des *v* auf dem Steuerungsfluss Übertragung einer erreichbar Switch-Anweisung Blockierungsliste ist identisch mit den definitive Zuweisung Zustand des *v* am Ende der *Expr*.</span><span class="sxs-lookup"><span data-stu-id="8df36-278">The definite assignment state of *v* on the control flow transfer to a reachable switch block statement list is the same as the definite assignment state of *v* at the end of *expr*.</span></span>

#### <a name="while-statements"></a><span data-ttu-id="8df36-279">While-Anweisungen</span><span class="sxs-lookup"><span data-stu-id="8df36-279">While statements</span></span>

<span data-ttu-id="8df36-280">Für eine `while` Anweisung *Stmt* des Formulars:</span><span class="sxs-lookup"><span data-stu-id="8df36-280">For a `while` statement *stmt* of the form:</span></span>
```csharp
while ( expr ) while_body
```

*  <span data-ttu-id="8df36-281">*V* hat den gleichen definitive zuweisungszustand am Anfang des *Expr* wie am Anfang des *Stmt*.</span><span class="sxs-lookup"><span data-stu-id="8df36-281">*v* has the same definite assignment state at the beginning of *expr* as at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="8df36-282">Wenn *v* definitiv zugewiesen, am Ende der *Expr*, und klicken Sie dann sie definitiv zugewiesen ist, auf die Steuerelement-Flow-Übertragung an *While_body* und den Endpunkt des  *Stmt*.</span><span class="sxs-lookup"><span data-stu-id="8df36-282">If *v* is definitely assigned at the end of *expr*, then it is definitely assigned on the control flow transfer to *while_body* and to the end point of *stmt*.</span></span>
*  <span data-ttu-id="8df36-283">Wenn *v* hat den Status "definitiv zugewiesen nach" true "Ausdruck" am Ende der *Expr*, und klicken Sie dann sie definitiv zugewiesen ist, auf die Steuerelement-Flow-Übertragung an *While_body*, aber nicht der Endpunkt des definitiv zugewiesen *Stmt*.</span><span class="sxs-lookup"><span data-stu-id="8df36-283">If *v* has the state "definitely assigned after true expression" at the end of *expr*, then it is definitely assigned on the control flow transfer to *while_body*, but not definitely assigned at the end-point of *stmt*.</span></span>
*  <span data-ttu-id="8df36-284">Wenn *v* hat den Status "definitiv zugewiesen nach" false "Ausdruck" am Ende der *Expr*, und sie definitiv, auf die Steuerelement-Flow-Übertragung an den Endpunkt des zugewiesen ist *Stmt* , aber nicht definitiv zugewiesen ist, auf die Steuerelement-Flow-Übertragung an *While_body*.</span><span class="sxs-lookup"><span data-stu-id="8df36-284">If *v* has the state "definitely assigned after false expression" at the end of *expr*, then it is definitely assigned on the control flow transfer to the end point of *stmt*, but not definitely assigned on the control flow transfer to *while_body*.</span></span>

#### <a name="do-statements"></a><span data-ttu-id="8df36-285">Führen Sie die Anweisungen</span><span class="sxs-lookup"><span data-stu-id="8df36-285">Do statements</span></span>

<span data-ttu-id="8df36-286">Für eine `do` Anweisung *Stmt* des Formulars:</span><span class="sxs-lookup"><span data-stu-id="8df36-286">For a `do` statement *stmt* of the form:</span></span>
```csharp
do do_body while ( expr ) ;
```

*  <span data-ttu-id="8df36-287">*V* hat den gleichen definitive zuweisungszustand auf die Steuerelement-Flow-Übertragung vom Anfang des *Stmt* zu *Do_body* wie am Anfang des *Stmt*.</span><span class="sxs-lookup"><span data-stu-id="8df36-287">*v* has the same definite assignment state on the control flow transfer from the beginning of *stmt* to *do_body* as at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="8df36-288">*V* hat den gleichen definitive zuweisungszustand am Anfang des *Expr* wie in den Endpunkt des *Do_body*.</span><span class="sxs-lookup"><span data-stu-id="8df36-288">*v* has the same definite assignment state at the beginning of *expr* as at the end point of *do_body*.</span></span>
*  <span data-ttu-id="8df36-289">Wenn *v* definitiv zugewiesen, am Ende der *Expr*, und sie definitiv, auf die Steuerelement-Flow-Übertragung an den Endpunkt des zugewiesen ist *Stmt*.</span><span class="sxs-lookup"><span data-stu-id="8df36-289">If *v* is definitely assigned at the end of *expr*, then it is definitely assigned on the control flow transfer to the end point of *stmt*.</span></span>
*  <span data-ttu-id="8df36-290">Wenn *v* hat den Status "definitiv zugewiesen nach" false "Ausdruck" am Ende der *Expr*, und sie definitiv, auf die Steuerelement-Flow-Übertragung an den Endpunkt des zugewiesen ist *Stmt* .</span><span class="sxs-lookup"><span data-stu-id="8df36-290">If *v* has the state "definitely assigned after false expression" at the end of *expr*, then it is definitely assigned on the control flow transfer to the end point of *stmt*.</span></span>

#### <a name="for-statements"></a><span data-ttu-id="8df36-291">Für Anweisungen</span><span class="sxs-lookup"><span data-stu-id="8df36-291">For statements</span></span>

<span data-ttu-id="8df36-292">Definitive Zuweisungen für die Überprüfung einer `for` -Anweisung der Form:</span><span class="sxs-lookup"><span data-stu-id="8df36-292">Definite assignment checking for a `for` statement of the form:</span></span>
```csharp
for ( for_initializer ; for_condition ; for_iterator ) embedded_statement
```
<span data-ttu-id="8df36-293">erfolgt, als ob die Anweisung geschrieben wurden:</span><span class="sxs-lookup"><span data-stu-id="8df36-293">is done as if the statement were written:</span></span>
```csharp
{
for_initializer ;
while ( for_condition ) {
embedded_statement ;
for_iterator ;
}
}
```

<span data-ttu-id="8df36-294">Wenn die *For_condition* in weggelassen wird die `for` -Anweisung, und klicken Sie dann auf Auswertung definitive Zuweisung fortgesetzt wie *For_condition* wurden durch ersetzt `true` in der oben genannten Erweiterung .</span><span class="sxs-lookup"><span data-stu-id="8df36-294">If the *for_condition* is omitted from the `for` statement, then evaluation of definite assignment proceeds as if *for_condition* were replaced with `true` in the above expansion.</span></span>

#### <a name="break-continue-and-goto-statements"></a><span data-ttu-id="8df36-295">Unterbrechen, den Vorgang fortzusetzen und die Goto-Anweisungen</span><span class="sxs-lookup"><span data-stu-id="8df36-295">Break, continue, and goto statements</span></span>

<span data-ttu-id="8df36-296">Die definitive Zuweisung Zustand des *v* auf die Steuerelement-Flow-Übertragung aufgrund einer `break`, `continue`, oder `goto` -Anweisung ist identisch mit den definitive Zuweisung Zustand des *v* an die Beginn der Anweisung.</span><span class="sxs-lookup"><span data-stu-id="8df36-296">The definite assignment state of *v* on the control flow transfer caused by a `break`, `continue`, or `goto` statement is the same as the definite assignment state of *v* at the beginning of the statement.</span></span>

#### <a name="throw-statements"></a><span data-ttu-id="8df36-297">Throw-Anweisungen</span><span class="sxs-lookup"><span data-stu-id="8df36-297">Throw statements</span></span>

<span data-ttu-id="8df36-298">Für eine Anweisung *Stmt* des Formulars</span><span class="sxs-lookup"><span data-stu-id="8df36-298">For a statement *stmt* of the form</span></span>
```csharp
throw expr ;
```

<span data-ttu-id="8df36-299">Die definitive Zuweisung Zustand des *v* am Anfang des *Expr* ist identisch mit den definitive Zuweisung Zustand des *v* am Anfang des *Stmt*.</span><span class="sxs-lookup"><span data-stu-id="8df36-299">The definite assignment state of *v* at the beginning of *expr* is the same as the definite assignment state of *v* at the beginning of *stmt*.</span></span>

#### <a name="return-statements"></a><span data-ttu-id="8df36-300">Return-Anweisungen</span><span class="sxs-lookup"><span data-stu-id="8df36-300">Return statements</span></span>

<span data-ttu-id="8df36-301">Für eine Anweisung *Stmt* des Formulars</span><span class="sxs-lookup"><span data-stu-id="8df36-301">For a statement *stmt* of the form</span></span>
```csharp
return expr ;
```

*  <span data-ttu-id="8df36-302">Die definitive Zuweisung Zustand des *v* am Anfang des *Expr* ist identisch mit den definitive Zuweisung Zustand des *v* am Anfang des *Stmt*.</span><span class="sxs-lookup"><span data-stu-id="8df36-302">The definite assignment state of *v* at the beginning of *expr* is the same as the definite assignment state of *v* at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="8df36-303">Wenn *v* ist ein Output-Parameter, und es definitiv zugewiesen werden muss:</span><span class="sxs-lookup"><span data-stu-id="8df36-303">If *v* is an output parameter, then it must be definitely assigned either:</span></span>
    * <span data-ttu-id="8df36-304">nach dem *Expr*</span><span class="sxs-lookup"><span data-stu-id="8df36-304">after *expr*</span></span>
    * <span data-ttu-id="8df36-305">oder am Ende der `finally` -Block eine `try` - `finally` oder `try` - `catch` - `finally` einschließt, die die `return` Anweisung.</span><span class="sxs-lookup"><span data-stu-id="8df36-305">or at the end of the `finally` block of a `try`-`finally` or `try`-`catch`-`finally` that encloses the `return` statement.</span></span>

<span data-ttu-id="8df36-306">Für eine Anweisung Stmt des Formulars:</span><span class="sxs-lookup"><span data-stu-id="8df36-306">For a statement stmt of the form:</span></span>
```csharp
return ;
```

*  <span data-ttu-id="8df36-307">Wenn *v* ist ein Output-Parameter, und es definitiv zugewiesen werden muss:</span><span class="sxs-lookup"><span data-stu-id="8df36-307">If *v* is an output parameter, then it must be definitely assigned either:</span></span>
    * <span data-ttu-id="8df36-308">vor dem *Stmt*</span><span class="sxs-lookup"><span data-stu-id="8df36-308">before *stmt*</span></span>
    * <span data-ttu-id="8df36-309">oder am Ende der `finally` -Block eine `try` - `finally` oder `try` - `catch` - `finally` einschließt, die die `return` Anweisung.</span><span class="sxs-lookup"><span data-stu-id="8df36-309">or at the end of the `finally` block of a `try`-`finally` or `try`-`catch`-`finally` that encloses the `return` statement.</span></span>

#### <a name="try-catch-statements"></a><span data-ttu-id="8df36-310">Try-Catch-Anweisungen</span><span class="sxs-lookup"><span data-stu-id="8df36-310">Try-catch statements</span></span>

<span data-ttu-id="8df36-311">Für eine Anweisung *Stmt* des Formulars:</span><span class="sxs-lookup"><span data-stu-id="8df36-311">For a statement *stmt* of the form:</span></span>
```csharp
try try_block
catch(...) catch_block_1
...
catch(...) catch_block_n
```

*  <span data-ttu-id="8df36-312">Die definitive Zuweisung Zustand des *v* am Anfang des *Try_block* ist identisch mit den definitive Zuweisung Zustand des *v* am Anfang des *Stmt*.</span><span class="sxs-lookup"><span data-stu-id="8df36-312">The definite assignment state of *v* at the beginning of *try_block* is the same as the definite assignment state of *v* at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="8df36-313">Die definitive Zuweisung Zustand des *v* am Anfang des *Catch_block_i* (für alle *ich*) ist identisch mit den definitive Zuweisung Zustand des *v*am Anfang des *Stmt*.</span><span class="sxs-lookup"><span data-stu-id="8df36-313">The definite assignment state of *v* at the beginning of *catch_block_i* (for any *i*) is the same as the definite assignment state of *v* at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="8df36-314">Die definitive Zuweisung Zustand des *v* an den Endpunkt des *Stmt* ist definitiv zugewiesenen If (und nur wenn) *v* definitiv zugewiesen, auf den Endpunkt des  *Try_block* und jede *Catch_block_i* (für jede *ich* von 1 bis *n*).</span><span class="sxs-lookup"><span data-stu-id="8df36-314">The definite assignment state of *v* at the end-point of *stmt* is definitely assigned if (and only if) *v* is definitely assigned at the end-point of *try_block* and every *catch_block_i* (for every *i* from 1 to *n*).</span></span>

#### <a name="try-finally-statements"></a><span data-ttu-id="8df36-315">Try-finally-Anweisungen</span><span class="sxs-lookup"><span data-stu-id="8df36-315">Try-finally statements</span></span>

<span data-ttu-id="8df36-316">Für eine `try` Anweisung *Stmt* des Formulars:</span><span class="sxs-lookup"><span data-stu-id="8df36-316">For a `try` statement *stmt* of the form:</span></span>
```csharp
try try_block finally finally_block
```

*  <span data-ttu-id="8df36-317">Die definitive Zuweisung Zustand des *v* am Anfang des *Try_block* ist identisch mit den definitive Zuweisung Zustand des *v* am Anfang des *Stmt*.</span><span class="sxs-lookup"><span data-stu-id="8df36-317">The definite assignment state of *v* at the beginning of *try_block* is the same as the definite assignment state of *v* at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="8df36-318">Die definitive Zuweisung Zustand des *v* am Anfang des *Finally_block* ist identisch mit den definitive Zuweisung Zustand des *v* am Anfang des *Stmt* .</span><span class="sxs-lookup"><span data-stu-id="8df36-318">The definite assignment state of *v* at the beginning of *finally_block* is the same as the definite assignment state of *v* at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="8df36-319">Die definitive Zuweisung Zustand des *v* an den Endpunkt des *Stmt* ist definitiv zugewiesenen If (und nur wenn) mindestens eine der folgenden gilt:</span><span class="sxs-lookup"><span data-stu-id="8df36-319">The definite assignment state of *v* at the end-point of *stmt* is definitely assigned if (and only if) at least one of the following is true:</span></span>
    * <span data-ttu-id="8df36-320">*V* definitiv zugewiesen, auf den Endpunkt des *Try_block*</span><span class="sxs-lookup"><span data-stu-id="8df36-320">*v* is definitely assigned at the end-point of *try_block*</span></span>
    * <span data-ttu-id="8df36-321">*V* definitiv zugewiesen, auf den Endpunkt des *Finally_block*</span><span class="sxs-lookup"><span data-stu-id="8df36-321">*v* is definitely assigned at the end-point of *finally_block*</span></span>

<span data-ttu-id="8df36-322">Wenn eine Übertragung der Steuerelement-Flow (z. B. eine `goto` Anweisung) erfolgt, beginnt innerhalb *Try_block*, und endet, die außerhalb von *Try_block*, klicken Sie dann *v* ist auch als definitiv zugewiesen, auf diese Control Flow-Übertragung, wenn *v* definitiv zugewiesen, auf den Endpunkt des *Finally_block*.</span><span class="sxs-lookup"><span data-stu-id="8df36-322">If a control flow transfer (for example, a `goto` statement) is made that begins within *try_block*, and ends outside of *try_block*, then *v* is also considered definitely assigned on that control flow transfer if *v* is definitely assigned at the end-point of *finally_block*.</span></span> <span data-ttu-id="8df36-323">(Dies ist nicht nur, wenn ein, wenn *v* ist aus einem anderen Grund für diese Control Flow-Übertragung, definitiv zugewiesen, und er weiterhin definitiv zugewiesen gilt.)</span><span class="sxs-lookup"><span data-stu-id="8df36-323">(This is not an only if—if *v* is definitely assigned for another reason on this control flow transfer, then it is still considered definitely assigned.)</span></span>

#### <a name="try-catch-finally-statements"></a><span data-ttu-id="8df36-324">Try-Catch-finally-Anweisungen</span><span class="sxs-lookup"><span data-stu-id="8df36-324">Try-catch-finally statements</span></span>

<span data-ttu-id="8df36-325">Definite Assignment-Analyse für eine `try` - `catch` - `finally` -Anweisung der Form:</span><span class="sxs-lookup"><span data-stu-id="8df36-325">Definite assignment analysis for a `try`-`catch`-`finally` statement of the form:</span></span>
```csharp
try try_block
catch(...) catch_block_1
...
catch(...) catch_block_n
finally *finally_block*
```
<span data-ttu-id="8df36-326">wird ausgeführt, als wäre die Anweisung eine `try` - `finally` einschließenden Anweisung eine `try` - `catch` Anweisung:</span><span class="sxs-lookup"><span data-stu-id="8df36-326">is done as if the statement were a `try`-`finally` statement enclosing a `try`-`catch` statement:</span></span>
```csharp
try {
try try_block
catch(...) catch_block_1
...
catch(...) catch_block_n
}
finally finally_block
```

<span data-ttu-id="8df36-327">Im folgende Beispiel wird veranschaulicht, wie die verschiedenen Blöcke einer `try` Anweisung ([der Try-Anweisung](statements.md#the-try-statement)) Auswirkungen auf die definitive Zuweisung.</span><span class="sxs-lookup"><span data-stu-id="8df36-327">The following example demonstrates how the different blocks of a `try` statement ([The try statement](statements.md#the-try-statement)) affect definite assignment.</span></span>
```csharp
class A
{
static void F() {
int i, j;
try {
goto LABEL;
// neither i nor j definitely assigned
i = 1;
// i definitely assigned
}

catch {
// neither i nor j definitely assigned
i = 3;
// i definitely assigned
}

finally {
// neither i nor j definitely assigned
j = 5;
// j definitely assigned
}
// i and j definitely assigned
LABEL:;
// j definitely assigned

}
}
```

#### <a name="foreach-statements"></a><span data-ttu-id="8df36-328">Foreach-Anweisungen</span><span class="sxs-lookup"><span data-stu-id="8df36-328">Foreach statements</span></span>

<span data-ttu-id="8df36-329">Für eine `foreach` Anweisung *Stmt* des Formulars:</span><span class="sxs-lookup"><span data-stu-id="8df36-329">For a `foreach` statement *stmt* of the form:</span></span>
```csharp
foreach ( type identifier in expr ) embedded_statement
```

*  <span data-ttu-id="8df36-330">Die definitive Zuweisung Zustand des *v* am Anfang des *Expr* ist identisch mit den Status der *v* am Anfang des *Stmt*.</span><span class="sxs-lookup"><span data-stu-id="8df36-330">The definite assignment state of *v* at the beginning of *expr* is the same as the state of *v* at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="8df36-331">Die definitive Zuweisung Zustand des *v* auf die Steuerelement-Flow-Übertragung an *Embedded_statement* oder den Endpunkt des *Stmt* ist identisch mit den Status der *v* am Ende der *Expr*.</span><span class="sxs-lookup"><span data-stu-id="8df36-331">The definite assignment state of *v* on the control flow transfer to *embedded_statement* or to the end point of *stmt* is the same as the state of *v* at the end of *expr*.</span></span>

#### <a name="using-statements"></a><span data-ttu-id="8df36-332">Using-Anweisungen</span><span class="sxs-lookup"><span data-stu-id="8df36-332">Using statements</span></span>

<span data-ttu-id="8df36-333">Für eine `using` Anweisung *Stmt* des Formulars:</span><span class="sxs-lookup"><span data-stu-id="8df36-333">For a `using` statement *stmt* of the form:</span></span>
```csharp
using ( resource_acquisition ) embedded_statement
```

*  <span data-ttu-id="8df36-334">Die definitive Zuweisung Zustand des *v* am Anfang des *Resource_acquisition* ist identisch mit den Status der *v* am Anfang des *Stmt*.</span><span class="sxs-lookup"><span data-stu-id="8df36-334">The definite assignment state of *v* at the beginning of *resource_acquisition* is the same as the state of *v* at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="8df36-335">Die definitive Zuweisung Zustand des *v* auf die Steuerelement-Flow-Übertragung an *Embedded_statement* ist identisch mit den Status der *v* am Ende der *Resource_ Übernahme*.</span><span class="sxs-lookup"><span data-stu-id="8df36-335">The definite assignment state of *v* on the control flow transfer to *embedded_statement* is the same as the state of *v* at the end of *resource_acquisition*.</span></span>

#### <a name="lock-statements"></a><span data-ttu-id="8df36-336">Lock-Anweisungen</span><span class="sxs-lookup"><span data-stu-id="8df36-336">Lock statements</span></span>

<span data-ttu-id="8df36-337">Für eine `lock` Anweisung *Stmt* des Formulars:</span><span class="sxs-lookup"><span data-stu-id="8df36-337">For a `lock` statement *stmt* of the form:</span></span>
```csharp
lock ( expr ) embedded_statement
```

*  <span data-ttu-id="8df36-338">Die definitive Zuweisung Zustand des *v* am Anfang des *Expr* ist identisch mit den Status der *v* am Anfang des *Stmt*.</span><span class="sxs-lookup"><span data-stu-id="8df36-338">The definite assignment state of *v* at the beginning of *expr* is the same as the state of *v* at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="8df36-339">Die definitive Zuweisung Zustand des *v* auf die Steuerelement-Flow-Übertragung an *Embedded_statement* ist identisch mit den Status der *v* am Ende der *Expr*.</span><span class="sxs-lookup"><span data-stu-id="8df36-339">The definite assignment state of *v* on the control flow transfer to *embedded_statement* is the same as the state of *v* at the end of *expr*.</span></span>

#### <a name="yield-statements"></a><span data-ttu-id="8df36-340">Yield-Anweisungen</span><span class="sxs-lookup"><span data-stu-id="8df36-340">Yield statements</span></span>

<span data-ttu-id="8df36-341">Für eine `yield return` Anweisung *Stmt* des Formulars:</span><span class="sxs-lookup"><span data-stu-id="8df36-341">For a `yield return` statement *stmt* of the form:</span></span>
```csharp
yield return expr ;
```

*  <span data-ttu-id="8df36-342">Die definitive Zuweisung Zustand des *v* am Anfang des *Expr* ist identisch mit den Status der *v* am Anfang des *Stmt*.</span><span class="sxs-lookup"><span data-stu-id="8df36-342">The definite assignment state of *v* at the beginning of *expr* is the same as the state of *v* at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="8df36-343">Die definitive Zuweisung Zustand des *v* am Ende der *Stmt* ist identisch mit den Status der *v* am Ende der *Expr*.</span><span class="sxs-lookup"><span data-stu-id="8df36-343">The definite assignment state of *v* at the end of *stmt* is the same as the state of *v* at the end of *expr*.</span></span>
*  <span data-ttu-id="8df36-344">Ein `yield break` -Anweisung hat keine Auswirkung auf die definitive zuweisungszustand.</span><span class="sxs-lookup"><span data-stu-id="8df36-344">A `yield break` statement has no effect on the definite assignment state.</span></span>

#### <a name="general-rules-for-simple-expressions"></a><span data-ttu-id="8df36-345">Allgemeine Regeln für einfache Ausdrücke</span><span class="sxs-lookup"><span data-stu-id="8df36-345">General rules for simple expressions</span></span>

<span data-ttu-id="8df36-346">Die folgende Regel gilt für diese Arten von Ausdrücken: Literale ([Literale](expressions.md#literals)), einfache Namen ([einfache Namen](expressions.md#simple-names)), Ausdrücke für den Memberzugriff ([Memberzugriff](expressions.md#member-access)), Basiszugriff nicht indizierte Ausdrücke ([Base Access](expressions.md#base-access)), `typeof` Ausdrücke ([der Typeof-Operator](expressions.md#the-typeof-operator)), default Wertausdrücken ([Standardwertausdrücke ](expressions.md#default-value-expressions)) und `nameof` Ausdrücke ([Nameof-Ausdrücken](expressions.md#nameof-expressions)).</span><span class="sxs-lookup"><span data-stu-id="8df36-346">The following rule applies to these kinds of expressions: literals ([Literals](expressions.md#literals)), simple names ([Simple names](expressions.md#simple-names)), member access expressions ([Member access](expressions.md#member-access)), non-indexed base access expressions ([Base access](expressions.md#base-access)), `typeof` expressions ([The typeof operator](expressions.md#the-typeof-operator)), default value expressions ([Default value expressions](expressions.md#default-value-expressions)) and `nameof` expressions ([Nameof expressions](expressions.md#nameof-expressions)).</span></span>

*  <span data-ttu-id="8df36-347">Die definitive Zuweisung Zustand des *v* am Ende ein solcher Ausdruck entspricht den definitive Zuweisung Zustand des *v* am Anfang des Ausdrucks.</span><span class="sxs-lookup"><span data-stu-id="8df36-347">The definite assignment state of *v* at the end of such an expression is the same as the definite assignment state of *v* at the beginning of the expression.</span></span>

#### <a name="general-rules-for-expressions-with-embedded-expressions"></a><span data-ttu-id="8df36-348">Allgemeine Regeln für Ausdrücke mit eingebetteten Ausdrücken</span><span class="sxs-lookup"><span data-stu-id="8df36-348">General rules for expressions with embedded expressions</span></span>

<span data-ttu-id="8df36-349">Die folgenden Regeln gelten für diese Arten von Ausdrücken: Ausdrücke in Klammern ([Ausdrücke in Klammern](expressions.md#parenthesized-expressions)), Element Access Expressions ([Elementzugriff](expressions.md#element-access)), Basis Zugriff auf die Ausdrücke mit Indizierung ([Base Access](expressions.md#base-access)), Inkrement- und Dekrement-Ausdrücke ([Postfix-Inkrement und Dekrement-Operatoren](expressions.md#postfix-increment-and-decrement-operators), [Präfix-Inkrement und Dekrement-Operatoren](expressions.md#prefix-increment-and-decrement-operators)), Umwandlungsausdrücke ([Umwandlungsausdrücke](expressions.md#cast-expressions)), unäre `+`, `-`, `~`, `*` binäre Ausdrücke `+`, `-`, `*`, `/`, `%`, `<<`, `>>`, `<`, `<=`, `>`, `>=`, `==`, `!=`, `is`, `as`, `&`, `|`, `^` Ausdrücke ([arithmetische Operatoren](expressions.md#arithmetic-operators), [Schiebeoperatoren](expressions.md#shift-operators), [Relational und Typtest Operatoren](expressions.md#relational-and-type-testing-operators) [Logische Operatoren](expressions.md#logical-operators)), zusammengesetzte Zuweisungsausdrücke ([Verbundzuweisung](expressions.md#compound-assignment)), `checked` und `unchecked` Ausdrücke ([checked und unchecked Operatoren](expressions.md#the-checked-and-unchecked-operators)), sowie Arrays und Delegaten erstellen Ausdrücke ([des neuen Operators](expressions.md#the-new-operator)).</span><span class="sxs-lookup"><span data-stu-id="8df36-349">The following rules apply to these kinds of expressions: parenthesized expressions ([Parenthesized expressions](expressions.md#parenthesized-expressions)), element access expressions ([Element access](expressions.md#element-access)), base access expressions with indexing ([Base access](expressions.md#base-access)), increment and decrement expressions ([Postfix increment and decrement operators](expressions.md#postfix-increment-and-decrement-operators), [Prefix increment and decrement operators](expressions.md#prefix-increment-and-decrement-operators)), cast expressions ([Cast expressions](expressions.md#cast-expressions)), unary `+`, `-`, `~`, `*` expressions, binary `+`, `-`, `*`, `/`, `%`, `<<`, `>>`, `<`, `<=`, `>`, `>=`, `==`, `!=`, `is`, `as`, `&`, `|`, `^` expressions ([Arithmetic operators](expressions.md#arithmetic-operators), [Shift operators](expressions.md#shift-operators), [Relational and type-testing operators](expressions.md#relational-and-type-testing-operators), [Logical operators](expressions.md#logical-operators)), compound assignment expressions ([Compound assignment](expressions.md#compound-assignment)), `checked` and `unchecked` expressions ([The checked and unchecked operators](expressions.md#the-checked-and-unchecked-operators)), plus array and delegate creation expressions ([The new operator](expressions.md#the-new-operator)).</span></span>

<span data-ttu-id="8df36-350">Jeder dieser Ausdrücke hat einen oder mehrere untergeordnete Ausdrücke, die ohne Bedingung in einer festen Reihenfolge ausgewertet werden.</span><span class="sxs-lookup"><span data-stu-id="8df36-350">Each of these expressions has one or more sub-expressions that are unconditionally evaluated in a fixed order.</span></span> <span data-ttu-id="8df36-351">Z. B. die Binärdatei `%` -Operator wertet der linken Seite des Operators, und klicken Sie dann auf der rechten Seite.</span><span class="sxs-lookup"><span data-stu-id="8df36-351">For example, the binary `%` operator evaluates the left hand side of the operator, then the right hand side.</span></span> <span data-ttu-id="8df36-352">Ein Indizierungsvorgang wertet den Ausdruck, der indizierten, und jeder Index Ausdrücke aus, in der Reihenfolge von links nach rechts ausgewertet.</span><span class="sxs-lookup"><span data-stu-id="8df36-352">An indexing operation evaluates the indexed expression, and then evaluates each of the index expressions, in order from left to right.</span></span> <span data-ttu-id="8df36-353">Für einen Ausdruck *Expr*, Unterausdrücken IValidator.h *e1, e2,..., eN*, die in dieser Reihenfolge ausgewertet:</span><span class="sxs-lookup"><span data-stu-id="8df36-353">For an expression *expr*, which has sub-expressions *e1, e2, ..., eN*, evaluated in that order:</span></span>

*  <span data-ttu-id="8df36-354">Die definitive Zuweisung Zustand des *v* am Anfang des *e1* ist identisch mit den definitive zuweisungszustand am Anfang des *Expr*.</span><span class="sxs-lookup"><span data-stu-id="8df36-354">The definite assignment state of *v* at the beginning of *e1* is the same as the definite assignment state at the beginning of *expr*.</span></span>
*  <span data-ttu-id="8df36-355">Die definitive Zuweisung Zustand des *v* am Anfang des *Ei* (*ich* größer als 1) ist identisch mit den definitive zuweisungszustand am Ende der vorherigen Unterausdruck.</span><span class="sxs-lookup"><span data-stu-id="8df36-355">The definite assignment state of *v* at the beginning of *ei* (*i* greater than one) is the same as the definite assignment state at the end of the previous sub-expression.</span></span>
*  <span data-ttu-id="8df36-356">Die definitive Zuweisung Zustand des *v* am Ende der *Expr* ist identisch mit den definitive zuweisungszustand am Ende der *eN*</span><span class="sxs-lookup"><span data-stu-id="8df36-356">The definite assignment state of *v* at the end of *expr* is the same as the definite assignment state at the end of *eN*</span></span>

#### <a name="invocation-expressions-and-object-creation-expressions"></a><span data-ttu-id="8df36-357">Das Aufrufen von Ausdrücken und Erstellung Objektausdrücke</span><span class="sxs-lookup"><span data-stu-id="8df36-357">Invocation expressions and object creation expressions</span></span>

<span data-ttu-id="8df36-358">Für ein Aufrufausdruck *Expr* des Formulars:</span><span class="sxs-lookup"><span data-stu-id="8df36-358">For an invocation expression *expr* of the form:</span></span>
```csharp
primary_expression ( arg1 , arg2 , ... , argN )
```
<span data-ttu-id="8df36-359">oder ein Objekterstellungsausdruck des Formulars:</span><span class="sxs-lookup"><span data-stu-id="8df36-359">or an object creation expression of the form:</span></span>
```csharp
new type ( arg1 , arg2 , ... , argN )
```

*  <span data-ttu-id="8df36-360">Für ein Aufrufausdruck, den Status für definitive Zuweisungen der *v* vor *Primary_expression* ist identisch mit den Status der *v* vor *Expr*.</span><span class="sxs-lookup"><span data-stu-id="8df36-360">For an invocation expression, the definite assignment state of *v* before *primary_expression* is the same as the state of *v* before *expr*.</span></span>
*  <span data-ttu-id="8df36-361">Für ein Aufrufausdruck, den Status für definitive Zuweisungen der *v* vor *arg1* ist identisch mit den Status der *v* nach *Primary_expression*.</span><span class="sxs-lookup"><span data-stu-id="8df36-361">For an invocation expression, the definite assignment state of *v* before *arg1* is the same as the state of *v* after *primary_expression*.</span></span>
*  <span data-ttu-id="8df36-362">Für eine Objekterstellungsausdruck, den Status für definitive Zuweisungen der *v* vor *arg1* ist identisch mit den Status der *v* vor *Expr*.</span><span class="sxs-lookup"><span data-stu-id="8df36-362">For an object creation expression, the definite assignment state of *v* before *arg1* is the same as the state of *v* before *expr*.</span></span>
*  <span data-ttu-id="8df36-363">Für jedes Argument *Argi*, den Status für definitive Zuweisungen der *v* nach *Argi* richtet sich nach den regulären Ausdruck Regeln ignorieren `ref` oder `out`Modifizierer.</span><span class="sxs-lookup"><span data-stu-id="8df36-363">For each argument *argi*, the definite assignment state of *v* after *argi* is determined by the normal expression rules, ignoring any `ref` or `out` modifiers.</span></span>
*  <span data-ttu-id="8df36-364">Für jedes Argument *Argi* für alle *ich* größer als eins, den Status für definitive Zuweisungen der *v* vor *Argi* ist identisch mit den Status der *v* nach der letzten *Arg*.</span><span class="sxs-lookup"><span data-stu-id="8df36-364">For each argument *argi* for any *i* greater than one, the definite assignment state of *v* before *argi* is the same as the state of *v* after the previous *arg*.</span></span>
*  <span data-ttu-id="8df36-365">Wenn die Variable *v* übergeben wird, als ein `out` Argument (d. h., ein Argument des Formulars `out v`) in einem der Argumente, und klicken Sie dann auf den Zustand des *v* nach *Expr* ist definitiv zugewiesen werden.</span><span class="sxs-lookup"><span data-stu-id="8df36-365">If the variable *v* is passed as an `out` argument (i.e., an argument of the form `out v`) in any of the arguments, then the state of *v* after *expr* is definitely assigned.</span></span> <span data-ttu-id="8df36-366">Andernfalls der Status der *v* nach *Expr* ist identisch mit den Status der *v* nach *ArgN*.</span><span class="sxs-lookup"><span data-stu-id="8df36-366">Otherwise; the state of *v* after *expr* is the same as the state of *v* after *argN*.</span></span>
*  <span data-ttu-id="8df36-367">Für Arrayinitialisierer ([Array-Ausdrücke für die Arrayerstellung](expressions.md#array-creation-expressions)), Objektinitialisierer ([Objektinitialisierer](expressions.md#object-initializers)), Auflistungsinitialisierer ([Auflistungsinitialisierer](expressions.md#collection-initializers)) und anonyme Objektinitialisierer ([anonyme Erstellung Objektausdrücke](expressions.md#anonymous-object-creation-expressions)), der Status für definitive Zuweisungen richtet sich nach der Erweiterung, die diese Konstrukte in Form von definiert sind.</span><span class="sxs-lookup"><span data-stu-id="8df36-367">For array initializers ([Array creation expressions](expressions.md#array-creation-expressions)), object initializers ([Object initializers](expressions.md#object-initializers)), collection initializers ([Collection initializers](expressions.md#collection-initializers)) and anonymous object initializers ([Anonymous object creation expressions](expressions.md#anonymous-object-creation-expressions)), the definite assignment state is determined by the expansion that these constructs are defined in terms of.</span></span>

#### <a name="simple-assignment-expressions"></a><span data-ttu-id="8df36-368">Ausdrücke für einfache Zuweisung</span><span class="sxs-lookup"><span data-stu-id="8df36-368">Simple assignment expressions</span></span>

<span data-ttu-id="8df36-369">Für einen Ausdruck *Expr* des Formulars `w = expr_rhs`:</span><span class="sxs-lookup"><span data-stu-id="8df36-369">For an expression *expr* of the form `w = expr_rhs`:</span></span>

*  <span data-ttu-id="8df36-370">Die definitive Zuweisung Zustand des *v* vor *Expr_rhs* ist identisch mit den definitive Zuweisung Zustand des *v* vor *Expr*.</span><span class="sxs-lookup"><span data-stu-id="8df36-370">The definite assignment state of *v* before *expr_rhs* is the same as the definite assignment state of *v* before *expr*.</span></span>
*  <span data-ttu-id="8df36-371">Die definitive Zuweisung Zustand des *v* nach *Expr* richtet sich nach:</span><span class="sxs-lookup"><span data-stu-id="8df36-371">The definite assignment state of *v* after *expr* is determined by:</span></span>
   * <span data-ttu-id="8df36-372">Wenn *w* ist die gleiche Variable als *v*, klicken Sie dann die definitive Zuweisung Zustand des *v* nach *Expr* definitiv zugewiesen.</span><span class="sxs-lookup"><span data-stu-id="8df36-372">If *w* is the same variable as *v*, then the definite assignment state of *v* after *expr* is definitely assigned.</span></span>
   * <span data-ttu-id="8df36-373">Andernfalls, wenn die Zuweisung im Instanzkonstruktor eines Strukturtyps auftritt, wenn *w* ist ein Eigenschaftenzugriff festlegen eine automatisch implementierte Eigenschaft *P* für die Instanz, die erstellt wird und *v* ist das ausgeblendete dahinter liegende Feld *P*, klicken Sie dann die definitive Zuweisung Zustand des *v* nach *Expr* ist definitiv zugewiesen.</span><span class="sxs-lookup"><span data-stu-id="8df36-373">Otherwise, if the assignment occurs within the instance constructor of a struct type, if *w* is a property access designating an automatically implemented property *P* on the instance being constructed and *v* is the hidden backing field of *P*, then the definite assignment state of *v* after *expr* is definitely assigned.</span></span>
   * <span data-ttu-id="8df36-374">Andernfalls die definitive Zuweisung Zustand des *v* nach *Expr* ist identisch mit den definitive Zuweisung Zustand des *v* nach *Expr_rhs*.</span><span class="sxs-lookup"><span data-stu-id="8df36-374">Otherwise, the definite assignment state of *v* after *expr* is the same as the definite assignment state of *v* after *expr_rhs*.</span></span>

#### <a name="-conditional-and-expressions"></a><span data-ttu-id="8df36-375">& & (bedingte AND) Ausdrücke</span><span class="sxs-lookup"><span data-stu-id="8df36-375">&& (conditional AND) expressions</span></span>

<span data-ttu-id="8df36-376">Für einen Ausdruck *Expr* des Formulars `expr_first && expr_second`:</span><span class="sxs-lookup"><span data-stu-id="8df36-376">For an expression *expr* of the form `expr_first && expr_second`:</span></span>

*  <span data-ttu-id="8df36-377">Die definitive Zuweisung Zustand des *v* vor *Expr_first* ist identisch mit den definitive Zuweisung Zustand des *v* vor *Expr*.</span><span class="sxs-lookup"><span data-stu-id="8df36-377">The definite assignment state of *v* before *expr_first* is the same as the definite assignment state of *v* before *expr*.</span></span>
*  <span data-ttu-id="8df36-378">Die definitive Zuweisung Zustand des *v* vor *Expr_second* wird definitiv zugewiesen werden, wenn der Status der *v* nach *Expr_first* ist entweder definitiv zugewiesen oder "nach der als TRUE ausgewertete Ausdruck definitiv zugewiesenen".</span><span class="sxs-lookup"><span data-stu-id="8df36-378">The definite assignment state of *v* before *expr_second* is definitely assigned if the state of *v* after *expr_first* is either definitely assigned or "definitely assigned after true expression".</span></span> <span data-ttu-id="8df36-379">Andernfalls ist es nicht definitiv zugewiesen.</span><span class="sxs-lookup"><span data-stu-id="8df36-379">Otherwise, it is not definitely assigned.</span></span>
*  <span data-ttu-id="8df36-380">Die definitive Zuweisung Zustand des *v* nach *Expr* richtet sich nach:</span><span class="sxs-lookup"><span data-stu-id="8df36-380">The definite assignment state of *v* after *expr* is determined by:</span></span>
    * <span data-ttu-id="8df36-381">Wenn *Expr_first* ist ein konstanter Ausdruck mit dem Wert `false`, klicken Sie dann die definitive Zuweisung Zustand des *v* nach *Expr* ist identisch mit die definitive Zuweisung Status des *v* nach *Expr_first*.</span><span class="sxs-lookup"><span data-stu-id="8df36-381">If *expr_first* is a constant expression with the value `false`, then the definite assignment state of *v* after *expr* is the same as the definite assignment state of *v* after *expr_first*.</span></span>
    * <span data-ttu-id="8df36-382">Andernfalls gilt: Wenn der Status der *v* nach *Expr_first* definitiv zugewiesen wird, klicken Sie dann den Status der *v* nach *Expr* definitiv zugewiesen.</span><span class="sxs-lookup"><span data-stu-id="8df36-382">Otherwise, if the state of *v* after *expr_first* is definitely assigned, then the state of *v* after *expr* is definitely assigned.</span></span>
    * <span data-ttu-id="8df36-383">Andernfalls, wenn der Status der *v* nach *Expr_second* definitiv zugewiesen wird, und der Status der *v* nach *Expr_first* ist "auf jeden Fall zugewiesene nach "false" Ausdruck", und klicken Sie dann den Status der *v* nach *Expr* definitiv zugewiesen.</span><span class="sxs-lookup"><span data-stu-id="8df36-383">Otherwise, if the state of *v* after *expr_second* is definitely assigned, and the state of *v* after *expr_first* is "definitely assigned after false expression", then the state of *v* after *expr* is definitely assigned.</span></span>
    * <span data-ttu-id="8df36-384">Andernfalls gilt: Wenn der Status der *v* nach *Expr_second* definitiv zugewiesen oder "nach der als TRUE ausgewertete Ausdruck definitiv zugewiesenen", und klicken Sie dann den Status der *v* nach  *Expr* "definitiv zugewiesen, nach" true "Ausdruck".</span><span class="sxs-lookup"><span data-stu-id="8df36-384">Otherwise, if the state of *v* after *expr_second* is definitely assigned or "definitely assigned after true expression", then the state of *v* after *expr* is "definitely assigned after true expression".</span></span>
    * <span data-ttu-id="8df36-385">Andernfalls gilt: Wenn der Status der *v* nach *Expr_first* ist "nach" false "Ausdruck definitiv zugewiesenen" und den Status der *v* nach *Expr_second* ist "definitiv zugewiesenen nach" false "Ausdruck", und klicken Sie dann den Status der *v* nach *Expr* "definitiv zugewiesen, nach" false "Ausdruck".</span><span class="sxs-lookup"><span data-stu-id="8df36-385">Otherwise, if the state of *v* after *expr_first* is "definitely assigned after false expression", and the state of *v* after *expr_second* is "definitely assigned after false expression", then the state of *v* after *expr* is "definitely assigned after false expression".</span></span>
    * <span data-ttu-id="8df36-386">Andernfalls den Zustand des *v* nach *Expr* nicht definitiv zugewiesen.</span><span class="sxs-lookup"><span data-stu-id="8df36-386">Otherwise, the state of *v* after *expr* is not definitely assigned.</span></span>

<span data-ttu-id="8df36-387">Im Beispiel</span><span class="sxs-lookup"><span data-stu-id="8df36-387">In the example</span></span>
```csharp
class A
{
    static void F(int x, int y) {
        int i;
        if (x >= 0 && (i = y) >= 0) {
            // i definitely assigned
        }
        else {
            // i not definitely assigned
        }
        // i not definitely assigned
    }
}
```
<span data-ttu-id="8df36-388">die Variable `i` gilt in einem von der eingebetteten Anweisungen des definitiv zugewiesenen ein `if` Anweisung aber nicht in die andere.</span><span class="sxs-lookup"><span data-stu-id="8df36-388">the variable `i` is considered definitely assigned in one of the embedded statements of an `if` statement but not in the other.</span></span> <span data-ttu-id="8df36-389">In der `if` -Anweisung in der Methode `F`, die Variable `i` wird in der ersten eingebettete Anweisung definitiv zugewiesen, da Ausführung des Ausdrucks `(i = y)` steht immer vor Ausführung dieser eingebetteten Anweisung.</span><span class="sxs-lookup"><span data-stu-id="8df36-389">In the `if` statement in method `F`, the variable `i` is definitely assigned in the first embedded statement because execution of the expression `(i = y)` always precedes execution of this embedded statement.</span></span> <span data-ttu-id="8df36-390">Im Gegensatz dazu sind die Variable `i` nicht zugewiesen, in der zweiten eingebettete Anweisung, da `x >= 0` möglicherweise wurden getestet "false", wodurch die Variable `i` aufgehoben.</span><span class="sxs-lookup"><span data-stu-id="8df36-390">In contrast, the variable `i` is not definitely assigned in the second embedded statement, since `x >= 0` might have tested false, resulting in the variable `i` being unassigned.</span></span>

#### <a name="-conditional-or-expressions"></a><span data-ttu-id="8df36-391">|| (bedingte OR) Ausdrücke</span><span class="sxs-lookup"><span data-stu-id="8df36-391">|| (conditional OR) expressions</span></span>

<span data-ttu-id="8df36-392">Für einen Ausdruck *Expr* des Formulars `expr_first || expr_second`:</span><span class="sxs-lookup"><span data-stu-id="8df36-392">For an expression *expr* of the form `expr_first || expr_second`:</span></span>

*  <span data-ttu-id="8df36-393">Die definitive Zuweisung Zustand des *v* vor *Expr_first* ist identisch mit den definitive Zuweisung Zustand des *v* vor *Expr*.</span><span class="sxs-lookup"><span data-stu-id="8df36-393">The definite assignment state of *v* before *expr_first* is the same as the definite assignment state of *v* before *expr*.</span></span>
*  <span data-ttu-id="8df36-394">Die definitive Zuweisung Zustand des *v* vor *Expr_second* wird definitiv zugewiesen werden, wenn der Status der *v* nach *Expr_first* ist entweder definitiv zugewiesen oder "nach" false "Ausdruck definitiv zugewiesenen".</span><span class="sxs-lookup"><span data-stu-id="8df36-394">The definite assignment state of *v* before *expr_second* is definitely assigned if the state of *v* after *expr_first* is either definitely assigned or "definitely assigned after false expression".</span></span> <span data-ttu-id="8df36-395">Andernfalls ist es nicht definitiv zugewiesen.</span><span class="sxs-lookup"><span data-stu-id="8df36-395">Otherwise, it is not definitely assigned.</span></span>
*  <span data-ttu-id="8df36-396">Die definitive Zuweisung-Anweisung von *v* nach *Expr* richtet sich nach:</span><span class="sxs-lookup"><span data-stu-id="8df36-396">The definite assignment statement of *v* after *expr* is determined by:</span></span>
    * <span data-ttu-id="8df36-397">Wenn *Expr_first* ist ein konstanter Ausdruck mit dem Wert `true`, klicken Sie dann die definitive Zuweisung Zustand des *v* nach *Expr* ist identisch mit die definitive Zuweisung Status des *v* nach *Expr_first*.</span><span class="sxs-lookup"><span data-stu-id="8df36-397">If *expr_first* is a constant expression with the value `true`, then the definite assignment state of *v* after *expr* is the same as the definite assignment state of *v* after *expr_first*.</span></span>
    * <span data-ttu-id="8df36-398">Andernfalls gilt: Wenn der Status der *v* nach *Expr_first* definitiv zugewiesen wird, klicken Sie dann den Status der *v* nach *Expr* definitiv zugewiesen.</span><span class="sxs-lookup"><span data-stu-id="8df36-398">Otherwise, if the state of *v* after *expr_first* is definitely assigned, then the state of *v* after *expr* is definitely assigned.</span></span>
    * <span data-ttu-id="8df36-399">Andernfalls, wenn der Status der *v* nach *Expr_second* definitiv zugewiesen wird, und der Status der *v* nach *Expr_first* ist "auf jeden Fall zugewiesene nach "true" Ausdruck", und klicken Sie dann den Status der *v* nach *Expr* definitiv zugewiesen.</span><span class="sxs-lookup"><span data-stu-id="8df36-399">Otherwise, if the state of *v* after *expr_second* is definitely assigned, and the state of *v* after *expr_first* is "definitely assigned after true expression", then the state of *v* after *expr* is definitely assigned.</span></span>
    * <span data-ttu-id="8df36-400">Andernfalls gilt: Wenn der Status der *v* nach *Expr_second* definitiv zugewiesen oder "nach" false "Ausdruck definitiv zugewiesenen", und klicken Sie dann den Status der *v* nach *Expr* "definitiv zugewiesen, nach" false "Ausdruck".</span><span class="sxs-lookup"><span data-stu-id="8df36-400">Otherwise, if the state of *v* after *expr_second* is definitely assigned or "definitely assigned after false expression", then the state of *v* after *expr* is "definitely assigned after false expression".</span></span>
    * <span data-ttu-id="8df36-401">Andernfalls gilt: Wenn der Status der *v* nach *Expr_first* ist "nach der als TRUE ausgewertete Ausdruck definitiv zugewiesenen" und den Status der *v* nach *Expr_second*ist "nach der als TRUE ausgewertete Ausdruck definitiv zugewiesenen", und klicken Sie dann den Status der *v* nach *Expr* "definitiv zugewiesen, nach" true "Ausdruck".</span><span class="sxs-lookup"><span data-stu-id="8df36-401">Otherwise, if the state of *v* after *expr_first* is "definitely assigned after true expression", and the state of *v* after *expr_second* is "definitely assigned after true expression", then the state of *v* after *expr* is "definitely assigned after true expression".</span></span>
    * <span data-ttu-id="8df36-402">Andernfalls den Zustand des *v* nach *Expr* nicht definitiv zugewiesen.</span><span class="sxs-lookup"><span data-stu-id="8df36-402">Otherwise, the state of *v* after *expr* is not definitely assigned.</span></span>

<span data-ttu-id="8df36-403">Im Beispiel</span><span class="sxs-lookup"><span data-stu-id="8df36-403">In the example</span></span>
```csharp
class A
{
    static void G(int x, int y) {
        int i;
        if (x >= 0 || (i = y) >= 0) {
            // i not definitely assigned
        }
        else {
            // i definitely assigned
        }
        // i not definitely assigned
    }
}
```
<span data-ttu-id="8df36-404">die Variable `i` gilt in einem von der eingebetteten Anweisungen des definitiv zugewiesenen ein `if` Anweisung aber nicht in die andere.</span><span class="sxs-lookup"><span data-stu-id="8df36-404">the variable `i` is considered definitely assigned in one of the embedded statements of an `if` statement but not in the other.</span></span> <span data-ttu-id="8df36-405">In der `if` -Anweisung in der Methode `G`, die Variable `i` wird in der zweiten eingebettete Anweisung definitiv zugewiesen, da Ausführung des Ausdrucks `(i = y)` steht immer vor Ausführung dieser eingebetteten Anweisung.</span><span class="sxs-lookup"><span data-stu-id="8df36-405">In the `if` statement in method `G`, the variable `i` is definitely assigned in the second embedded statement because execution of the expression `(i = y)` always precedes execution of this embedded statement.</span></span> <span data-ttu-id="8df36-406">Im Gegensatz dazu sind die Variable `i` nicht zugewiesen, in der ersten eingebettete Anweisung, da `x >= 0` möglicherweise wurden getestet "true", wodurch die Variable `i` aufgehoben.</span><span class="sxs-lookup"><span data-stu-id="8df36-406">In contrast, the variable `i` is not definitely assigned in the first embedded statement, since `x >= 0` might have tested true, resulting in the variable `i` being unassigned.</span></span>

#### <a name="-logical-negation-expressions"></a><span data-ttu-id="8df36-407">!</span><span class="sxs-lookup"><span data-stu-id="8df36-407">!</span></span> <span data-ttu-id="8df36-408">(logische Negation)-Ausdrücke</span><span class="sxs-lookup"><span data-stu-id="8df36-408">(logical negation) expressions</span></span>

<span data-ttu-id="8df36-409">Für einen Ausdruck *Expr* des Formulars `! expr_operand`:</span><span class="sxs-lookup"><span data-stu-id="8df36-409">For an expression *expr* of the form `! expr_operand`:</span></span>

*  <span data-ttu-id="8df36-410">Die definitive Zuweisung Zustand des *v* vor *Expr_operand* ist identisch mit den definitive Zuweisung Zustand des *v* vor *Expr*.</span><span class="sxs-lookup"><span data-stu-id="8df36-410">The definite assignment state of *v* before *expr_operand* is the same as the definite assignment state of *v* before *expr*.</span></span>
*  <span data-ttu-id="8df36-411">Die definitive Zuweisung Zustand des *v* nach *Expr* richtet sich nach:</span><span class="sxs-lookup"><span data-stu-id="8df36-411">The definite assignment state of *v* after *expr* is determined by:</span></span>
    * <span data-ttu-id="8df36-412">Wenn der Status der *v* nach \* Expr_operand \* definitiv zugewiesen wird, klicken Sie dann den Status der *v* nach *Expr* definitiv zugewiesen.</span><span class="sxs-lookup"><span data-stu-id="8df36-412">If the state of *v* after \*expr_operand \*is definitely assigned, then the state of *v* after *expr* is definitely assigned.</span></span>
    * <span data-ttu-id="8df36-413">Wenn der Status der *v* nach \* Expr_operand \* nicht definitiv zugewiesen wird, klicken Sie dann den Status der *v* nach *Expr* nicht definitiv zugewiesen.</span><span class="sxs-lookup"><span data-stu-id="8df36-413">If the state of *v* after \*expr_operand \*is not definitely assigned, then the state of *v* after *expr* is not definitely assigned.</span></span>
    * <span data-ttu-id="8df36-414">Wenn der Status der *v* nach \* Expr_operand \* ist "definitiv zugewiesenen nach" false "Ausdruck", und klicken Sie dann den Status der *v* nach *Expr* "definitiv zugewiesen, nach dem" true " Ausdruck".</span><span class="sxs-lookup"><span data-stu-id="8df36-414">If the state of *v* after \*expr_operand \*is "definitely assigned after false expression", then the state of *v* after *expr* is "definitely assigned after true expression".</span></span>
    * <span data-ttu-id="8df36-415">Wenn der Status der *v* nach \* Expr_operand \* ist "nach der als TRUE ausgewertete Ausdruck definitiv zugewiesenen", und klicken Sie dann den Status der *v* nach *Expr* "definitiv zugewiesen, nach" false " Ausdruck".</span><span class="sxs-lookup"><span data-stu-id="8df36-415">If the state of *v* after \*expr_operand \*is "definitely assigned after true expression", then the state of *v* after *expr* is "definitely assigned after false expression".</span></span>

#### <a name="-null-coalescing-expressions"></a><span data-ttu-id="8df36-416">??</span><span class="sxs-lookup"><span data-stu-id="8df36-416">??</span></span> <span data-ttu-id="8df36-417">Ausdrücke (null-Sammeloperator)</span><span class="sxs-lookup"><span data-stu-id="8df36-417">(null coalescing) expressions</span></span>

<span data-ttu-id="8df36-418">Für einen Ausdruck *Expr* des Formulars `expr_first ?? expr_second`:</span><span class="sxs-lookup"><span data-stu-id="8df36-418">For an expression *expr* of the form `expr_first ?? expr_second`:</span></span>

*  <span data-ttu-id="8df36-419">Die definitive Zuweisung Zustand des *v* vor *Expr_first* ist identisch mit den definitive Zuweisung Zustand des *v* vor *Expr*.</span><span class="sxs-lookup"><span data-stu-id="8df36-419">The definite assignment state of *v* before *expr_first* is the same as the definite assignment state of *v* before *expr*.</span></span>
*  <span data-ttu-id="8df36-420">Die definitive Zuweisung Zustand des *v* vor *Expr_second* ist identisch mit den definitive Zuweisung Zustand des *v* nach *Expr_first*.</span><span class="sxs-lookup"><span data-stu-id="8df36-420">The definite assignment state of *v* before *expr_second* is the same as the definite assignment state of *v* after *expr_first*.</span></span>
*  <span data-ttu-id="8df36-421">Die definitive Zuweisung-Anweisung von *v* nach *Expr* richtet sich nach:</span><span class="sxs-lookup"><span data-stu-id="8df36-421">The definite assignment statement of *v* after *expr* is determined by:</span></span>
    * <span data-ttu-id="8df36-422">Wenn *Expr_first* ist ein konstanter Ausdruck ([Konstante Ausdrücke](expressions.md#constant-expressions)) mit dem Wert null ist, die den Status der *v* nach *Expr* entspricht Wenn sich der Zustand *v* nach *Expr_second*.</span><span class="sxs-lookup"><span data-stu-id="8df36-422">If *expr_first* is a constant expression ([Constant expressions](expressions.md#constant-expressions)) with value null, then the the state of *v* after *expr* is the same as the state of *v* after *expr_second*.</span></span>
*  <span data-ttu-id="8df36-423">Andernfalls den Zustand des *v* nach *Expr* ist identisch mit den definitive Zuweisung Zustand des *v* nach *Expr_first*.</span><span class="sxs-lookup"><span data-stu-id="8df36-423">Otherwise, the state of *v* after *expr* is the same as the definite assignment state of *v* after *expr_first*.</span></span>

#### <a name="-conditional-expressions"></a><span data-ttu-id="8df36-424">?: (Bedingungsausdrücken)</span><span class="sxs-lookup"><span data-stu-id="8df36-424">?: (conditional) expressions</span></span>

<span data-ttu-id="8df36-425">Für einen Ausdruck *Expr* des Formulars `expr_cond ? expr_true : expr_false`:</span><span class="sxs-lookup"><span data-stu-id="8df36-425">For an expression *expr* of the form `expr_cond ? expr_true : expr_false`:</span></span>

*  <span data-ttu-id="8df36-426">Die definitive Zuweisung Zustand des *v* vor *Expr_cond* ist identisch mit den Status der *v* vor *Expr*.</span><span class="sxs-lookup"><span data-stu-id="8df36-426">The definite assignment state of *v* before *expr_cond* is the same as the state of *v* before *expr*.</span></span>
*  <span data-ttu-id="8df36-427">Die definitive Zuweisung Zustand des *v* vor *Expr_true* ist definitiv zugewiesen werden, wenn eine der folgenden enthält:</span><span class="sxs-lookup"><span data-stu-id="8df36-427">The definite assignment state of *v* before *expr_true* is definitely assigned if and only if one of the following holds:</span></span>
    * <span data-ttu-id="8df36-428">*Expr_cond* ist ein konstanter Ausdruck mit dem Wert `false`</span><span class="sxs-lookup"><span data-stu-id="8df36-428">*expr_cond* is a constant expression with the value `false`</span></span>
    * <span data-ttu-id="8df36-429">der Status der *v* nach *Expr_cond* definitiv zugewiesen ist, oder "definitiv zugewiesen nach" true "Ausdruck".</span><span class="sxs-lookup"><span data-stu-id="8df36-429">the state of *v* after *expr_cond* is definitely assigned or "definitely assigned after true expression".</span></span>
*  <span data-ttu-id="8df36-430">Die definitive Zuweisung Zustand des *v* vor *Expr_false* ist definitiv zugewiesen werden, wenn eine der folgenden enthält:</span><span class="sxs-lookup"><span data-stu-id="8df36-430">The definite assignment state of *v* before *expr_false* is definitely assigned if and only if one of the following holds:</span></span>
    * <span data-ttu-id="8df36-431">*Expr_cond* ist ein konstanter Ausdruck mit dem Wert `true`</span><span class="sxs-lookup"><span data-stu-id="8df36-431">*expr_cond* is a constant expression with the value `true`</span></span>
*  <span data-ttu-id="8df36-432">der Status der *v* nach *Expr_cond* definitiv zugewiesen ist, oder "definitiv zugewiesen nach" false "Ausdruck".</span><span class="sxs-lookup"><span data-stu-id="8df36-432">the state of *v* after *expr_cond* is definitely assigned or "definitely assigned after false expression".</span></span>
*  <span data-ttu-id="8df36-433">Die definitive Zuweisung Zustand des *v* nach *Expr* richtet sich nach:</span><span class="sxs-lookup"><span data-stu-id="8df36-433">The definite assignment state of *v* after *expr* is determined by:</span></span>
    * <span data-ttu-id="8df36-434">Wenn *Expr_cond* ist ein konstanter Ausdruck ([Konstante Ausdrücke](expressions.md#constant-expressions)) mit dem Wert `true` klicken Sie dann den Status der *v* nach *Expr* ist identisch mit den Status der *v* nach *Expr_true*.</span><span class="sxs-lookup"><span data-stu-id="8df36-434">If *expr_cond* is a constant expression ([Constant expressions](expressions.md#constant-expressions)) with value `true` then the state of *v* after *expr* is the same as the state of *v* after *expr_true*.</span></span>
    * <span data-ttu-id="8df36-435">Andernfalls gilt: Wenn *Expr_cond* ist ein konstanter Ausdruck ([Konstante Ausdrücke](expressions.md#constant-expressions)) mit dem Wert `false` klicken Sie dann den Status der *v* nach *Expr* ist identisch mit den Status der *v* nach *Expr_false*.</span><span class="sxs-lookup"><span data-stu-id="8df36-435">Otherwise, if *expr_cond* is a constant expression ([Constant expressions](expressions.md#constant-expressions)) with value `false` then the state of *v* after *expr* is the same as the state of *v* after *expr_false*.</span></span>
    * <span data-ttu-id="8df36-436">Andernfalls gilt: Wenn der Status der *v* nach *Expr_true* definitiv zugewiesen und der Status der *v* nach *Expr_false* ist definitiv zugewiesen, klicken Sie dann den Status der *v* nach *Expr* definitiv zugewiesen.</span><span class="sxs-lookup"><span data-stu-id="8df36-436">Otherwise, if the state of *v* after *expr_true* is definitely assigned and the state of *v* after *expr_false* is definitely assigned, then the state of *v* after *expr* is definitely assigned.</span></span>
    * <span data-ttu-id="8df36-437">Andernfalls den Zustand des *v* nach *Expr* nicht definitiv zugewiesen.</span><span class="sxs-lookup"><span data-stu-id="8df36-437">Otherwise, the state of *v* after *expr* is not definitely assigned.</span></span>

#### <a name="anonymous-functions"></a><span data-ttu-id="8df36-438">Anonyme Funktionen</span><span class="sxs-lookup"><span data-stu-id="8df36-438">Anonymous functions</span></span>

<span data-ttu-id="8df36-439">Für eine *Lambda_expression* oder *Anonymous_method_expression* *Expr* mit einem Text (entweder *Block* oder *Ausdruck* ) *Text*:</span><span class="sxs-lookup"><span data-stu-id="8df36-439">For a *lambda_expression* or *anonymous_method_expression* *expr* with a body (either *block* or *expression*) *body*:</span></span>

*  <span data-ttu-id="8df36-440">Die definitive Zuweisung-Status, der eine äußere Variable *v* vor *Text* ist identisch mit den Status der *v* vor *Expr*.</span><span class="sxs-lookup"><span data-stu-id="8df36-440">The definite assignment state of an outer variable *v* before *body* is the same as the state of *v* before *expr*.</span></span> <span data-ttu-id="8df36-441">D. h. wird definitive zuweisungszustand von äußeren Variablen aus dem Kontext der anonymen Funktion geerbt.</span><span class="sxs-lookup"><span data-stu-id="8df36-441">That is, definite assignment state of outer variables is inherited from the context of the anonymous function.</span></span>
*  <span data-ttu-id="8df36-442">Die definitive Zuweisung-Status, der eine äußere Variable *v* nach *Expr* ist identisch mit den Status der *v* vor *Expr*.</span><span class="sxs-lookup"><span data-stu-id="8df36-442">The definite assignment state of an outer variable *v* after *expr* is the same as the state of *v* before *expr*.</span></span>

<span data-ttu-id="8df36-443">Im Beispiel</span><span class="sxs-lookup"><span data-stu-id="8df36-443">The example</span></span>
```csharp
delegate bool Filter(int i);

void F() {
    int max;

    // Error, max is not definitely assigned
    Filter f = (int n) => n < max;

    max = 5;
    DoWork(f);
}
```
<span data-ttu-id="8df36-444">generiert einen Fehler während der Kompilierung, da `max` wird nicht definitiv zugewiesen, in die anonyme Funktion deklariert wird.</span><span class="sxs-lookup"><span data-stu-id="8df36-444">generates a compile-time error since `max` is not definitely assigned where the anonymous function is declared.</span></span> <span data-ttu-id="8df36-445">Im Beispiel</span><span class="sxs-lookup"><span data-stu-id="8df36-445">The example</span></span>
```csharp
delegate void D();

void F() {
    int n;
    D d = () => { n = 1; };

    d();

    // Error, n is not definitely assigned
    Console.WriteLine(n);
}
```
<span data-ttu-id="8df36-446">generiert außerdem einen Fehler während der Kompilierung, da die Zuweisung zu `n` in der anonymen Funktion hat keine Auswirkungen auf die definitive Zuweisung Zustand des `n` außerhalb der anonymen Funktion.</span><span class="sxs-lookup"><span data-stu-id="8df36-446">also generates a compile-time error since the assignment to `n` in the anonymous function has no affect on the definite assignment state of `n` outside the anonymous function.</span></span>

## <a name="variable-references"></a><span data-ttu-id="8df36-447">Variablenverweise</span><span class="sxs-lookup"><span data-stu-id="8df36-447">Variable references</span></span>

<span data-ttu-id="8df36-448">Ein *Variable_reference* ist ein *Ausdruck* , als Variable klassifiziert wird.</span><span class="sxs-lookup"><span data-stu-id="8df36-448">A *variable_reference* is an *expression* that is classified as a variable.</span></span> <span data-ttu-id="8df36-449">Ein *Variable_reference* gibt einen Speicherort, der den aktuellen Wert abzurufen und speichern einen neuen Wert zugegriffen werden kann.</span><span class="sxs-lookup"><span data-stu-id="8df36-449">A *variable_reference* denotes a storage location that can be accessed both to fetch the current value and to store a new value.</span></span>

```antlr
variable_reference
    : expression
    ;
```

<span data-ttu-id="8df36-450">In C und C++ eine *Variable_reference* heißt ein *Lvalue*.</span><span class="sxs-lookup"><span data-stu-id="8df36-450">In C and C++, a *variable_reference* is known as an *lvalue*.</span></span>

## <a name="atomicity-of-variable-references"></a><span data-ttu-id="8df36-451">Unteilbarkeit variabler Verweise</span><span class="sxs-lookup"><span data-stu-id="8df36-451">Atomicity of variable references</span></span>

<span data-ttu-id="8df36-452">Lese- und Schreibvorgänge für die folgenden Datentypen sind atomisch: `bool`, `char`, `byte`, `sbyte`, `short`, `ushort`, `uint`, `int`, `float`, und verweisen auf Typen.</span><span class="sxs-lookup"><span data-stu-id="8df36-452">Reads and writes of the following data types are atomic: `bool`, `char`, `byte`, `sbyte`, `short`, `ushort`, `uint`, `int`, `float`, and reference types.</span></span> <span data-ttu-id="8df36-453">Darüber hinaus sind Lese- und Schreibvorgänge für Enum-Typen mit einem zugrunde liegenden Typ in der vorherigen Liste ebenfalls atomar.</span><span class="sxs-lookup"><span data-stu-id="8df36-453">In addition, reads and writes of enum types with an underlying type in the previous list are also atomic.</span></span> <span data-ttu-id="8df36-454">Lese- und Schreibvorgänge von anderen Typen, einschließlich `long`, `ulong`, `double`, und `decimal`, sowie benutzerdefinierte Typen werden nicht unbedingt atomar sein.</span><span class="sxs-lookup"><span data-stu-id="8df36-454">Reads and writes of other types, including `long`, `ulong`, `double`, and `decimal`, as well as user-defined types, are not guaranteed to be atomic.</span></span> <span data-ttu-id="8df36-455">Abgesehen von der die Bibliotheksfunktionen für diesen Zweck entwickelt gibt es keine Garantie der atomarer Lese-Änderungs-Schreib, z. B. im Fall von Inkrement oder Dekrement.</span><span class="sxs-lookup"><span data-stu-id="8df36-455">Aside from the library functions designed for that purpose, there is no guarantee of atomic read-modify-write, such as in the case of increment or decrement.</span></span>

