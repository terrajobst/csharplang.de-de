---
ms.openlocfilehash: a01cf9387b8dc47de036bf0bd1496c19a441d81c
ms.sourcegitcommit: 7f7fc6e9e195e51b7ff8229aeaa70aa9fbbb63cb
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 09/10/2019
ms.locfileid: "70876799"
---
# <a name="variables"></a><span data-ttu-id="70835-101">Variablen</span><span class="sxs-lookup"><span data-stu-id="70835-101">Variables</span></span>

<span data-ttu-id="70835-102">Variablen stellen Speicherorte dar.</span><span class="sxs-lookup"><span data-stu-id="70835-102">Variables represent storage locations.</span></span> <span data-ttu-id="70835-103">Jede Variable verfügt über einen Typ, der bestimmt, welche Werte in der Variablen gespeichert werden können.</span><span class="sxs-lookup"><span data-stu-id="70835-103">Every variable has a type that determines what values can be stored in the variable.</span></span> <span data-ttu-id="70835-104">C#ist eine typsichere Sprache, und der C# Compiler stellt sicher, dass Werte, die in Variablen gespeichert sind, immer den entsprechenden Typ haben.</span><span class="sxs-lookup"><span data-stu-id="70835-104">C# is a type-safe language, and the C# compiler guarantees that values stored in variables are always of the appropriate type.</span></span> <span data-ttu-id="70835-105">Der Wert einer Variablen kann durch Zuweisung oder durch Verwendung `++` der Operatoren und `--` geändert werden.</span><span class="sxs-lookup"><span data-stu-id="70835-105">The value of a variable can be changed through assignment or through use of the `++` and `--` operators.</span></span>

<span data-ttu-id="70835-106">Eine Variable muss ***definitiv zugewiesen*** werden ([definitive Zuweisung](variables.md#definite-assignment)), bevor ihr Wert abgerufen werden kann.</span><span class="sxs-lookup"><span data-stu-id="70835-106">A variable must be ***definitely assigned*** ([Definite assignment](variables.md#definite-assignment)) before its value can be obtained.</span></span>

<span data-ttu-id="70835-107">Wie in den folgenden Abschnitten beschrieben, werden Variablen entweder ***anfänglich zugewiesen*** oder ***ursprünglich nicht zugewiesen***.</span><span class="sxs-lookup"><span data-stu-id="70835-107">As described in the following sections, variables are either ***initially assigned*** or ***initially unassigned***.</span></span> <span data-ttu-id="70835-108">Eine anfänglich zugewiesene Variable verfügt über einen klar definierten Anfangswert und wird immer als definitiv zugewiesen betrachtet.</span><span class="sxs-lookup"><span data-stu-id="70835-108">An initially assigned variable has a well-defined initial value and is always considered definitely assigned.</span></span> <span data-ttu-id="70835-109">Eine anfänglich nicht zugewiesene Variable hat keinen Anfangswert.</span><span class="sxs-lookup"><span data-stu-id="70835-109">An initially unassigned variable has no initial value.</span></span> <span data-ttu-id="70835-110">Damit eine anfänglich nicht zugewiesene Variable an einem bestimmten Speicherort als definitiv zugewiesen wird, muss eine Zuweisung zur Variablen in jedem möglichen Ausführungs Pfad erfolgen, der zu diesem Speicherort führt.</span><span class="sxs-lookup"><span data-stu-id="70835-110">For an initially unassigned variable to be considered definitely assigned at a certain location, an assignment to the variable must occur in every possible execution path leading to that location.</span></span>

## <a name="variable-categories"></a><span data-ttu-id="70835-111">Variablen Kategorien</span><span class="sxs-lookup"><span data-stu-id="70835-111">Variable categories</span></span>

<span data-ttu-id="70835-112">C#definiert sieben Kategorien von Variablen: statische Variablen, Instanzvariablen, Array Elemente, Wert Parameter, Verweis Parameter, Ausgabeparameter und lokale Variablen.</span><span class="sxs-lookup"><span data-stu-id="70835-112">C# defines seven categories of variables: static variables, instance variables, array elements, value parameters, reference parameters, output parameters, and local variables.</span></span> <span data-ttu-id="70835-113">In den folgenden Abschnitten wird jede dieser Kategorien beschrieben.</span><span class="sxs-lookup"><span data-stu-id="70835-113">The sections that follow describe each of these categories.</span></span>

<span data-ttu-id="70835-114">Im Beispiel</span><span class="sxs-lookup"><span data-stu-id="70835-114">In the example</span></span>
```csharp
class A
{
    public static int x;
    int y;

    void F(int[] v, int a, ref int b, out int c) {
        int i = 1;
        c = a + b++;
    }
}
```
<span data-ttu-id="70835-115">`x`ist eine statische Variable, `y` ist eine Instanzvariable `v[0]` , ist ein Array Element `a` , ist ein Wert Parameter `b` , ist ein Verweis Parameter `c` , ist ein Output-Parameter `i` und ist eine lokale Variable. .</span><span class="sxs-lookup"><span data-stu-id="70835-115">`x` is a static variable, `y` is an instance variable, `v[0]` is an array element, `a` is a value parameter, `b` is a reference parameter, `c` is an output parameter, and `i` is a local variable.</span></span>

### <a name="static-variables"></a><span data-ttu-id="70835-116">Statische Variablen</span><span class="sxs-lookup"><span data-stu-id="70835-116">Static variables</span></span>

<span data-ttu-id="70835-117">Ein Feld, das mit `static` dem-Modifizierer deklariert wird, wird als ***statische Variable***bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="70835-117">A field declared with the `static` modifier is called a ***static variable***.</span></span> <span data-ttu-id="70835-118">Eine statische Variable kommt vor der Ausführung des statischen Konstruktors ([statischer Konstruktoren](classes.md#static-constructors)) für den enthaltenden Typ vor und ist nicht mehr vorhanden, wenn die zugehörige Anwendungsdomäne nicht mehr vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="70835-118">A static variable comes into existence before execution of the static constructor ([Static constructors](classes.md#static-constructors)) for its containing type, and ceases to exist when the associated application domain ceases to exist.</span></span>

<span data-ttu-id="70835-119">Der Anfangswert einer statischen Variablen ist der Standardwert ([Standardwerte](variables.md#default-values)) des Variablen Typs.</span><span class="sxs-lookup"><span data-stu-id="70835-119">The initial value of a static variable is the default value ([Default values](variables.md#default-values)) of the variable's type.</span></span>

<span data-ttu-id="70835-120">Zum Zweck der eindeutigen Zuweisungs Überprüfung wird eine statische Variable als anfänglich zugewiesen betrachtet.</span><span class="sxs-lookup"><span data-stu-id="70835-120">For purposes of definite assignment checking, a static variable is considered initially assigned.</span></span>

### <a name="instance-variables"></a><span data-ttu-id="70835-121">Instanzvariablen</span><span class="sxs-lookup"><span data-stu-id="70835-121">Instance variables</span></span>

<span data-ttu-id="70835-122">Ein Feld, das ohne `static` den Modifizierer deklariert wird, wird als ***Instanzvariable***bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="70835-122">A field declared without the `static` modifier is called an ***instance variable***.</span></span>

#### <a name="instance-variables-in-classes"></a><span data-ttu-id="70835-123">Instanzvariablen in Klassen</span><span class="sxs-lookup"><span data-stu-id="70835-123">Instance variables in classes</span></span>

<span data-ttu-id="70835-124">Eine Instanzvariable einer Klasse tritt auf, wenn eine neue Instanz dieser Klasse erstellt wird, und ist nicht mehr vorhanden, wenn keine Verweise auf diese Instanz vorhanden sind und der Dekonstruktor der Instanz (sofern vorhanden) ausgeführt wurde.</span><span class="sxs-lookup"><span data-stu-id="70835-124">An instance variable of a class comes into existence when a new instance of that class is created, and ceases to exist when there are no references to that instance and the instance's destructor (if any) has executed.</span></span>

<span data-ttu-id="70835-125">Der Anfangswert einer Instanzvariablen einer Klasse ist der Standardwert ([Standardwerte](variables.md#default-values)) des Variablen Typs.</span><span class="sxs-lookup"><span data-stu-id="70835-125">The initial value of an instance variable of a class is the default value ([Default values](variables.md#default-values)) of the variable's type.</span></span>

<span data-ttu-id="70835-126">Zum Zweck der eindeutigen Zuweisungs Überprüfung wird eine Instanzvariable einer Klasse als anfänglich zugewiesen betrachtet.</span><span class="sxs-lookup"><span data-stu-id="70835-126">For the purpose of definite assignment checking, an instance variable of a class is considered initially assigned.</span></span>

#### <a name="instance-variables-in-structs"></a><span data-ttu-id="70835-127">Instanzvariablen in Strukturen</span><span class="sxs-lookup"><span data-stu-id="70835-127">Instance variables in structs</span></span>

<span data-ttu-id="70835-128">Eine Instanzvariable einer Struktur hat genau die gleiche Lebensdauer wie die Struktur Variable, zu der Sie gehört.</span><span class="sxs-lookup"><span data-stu-id="70835-128">An instance variable of a struct has exactly the same lifetime as the struct variable to which it belongs.</span></span> <span data-ttu-id="70835-129">Anders ausgedrückt: Wenn eine Variable eines Struktur Typs vorhanden ist oder nicht mehr vorhanden ist, müssen Sie auch die Instanzvariablen der Struktur verwenden.</span><span class="sxs-lookup"><span data-stu-id="70835-129">In other words, when a variable of a struct type comes into existence or ceases to exist, so too do the instance variables of the struct.</span></span>

<span data-ttu-id="70835-130">Der anfängliche Zuweisungs Status einer Instanzvariablen einer Struktur ist mit der der enthaltenden Struktur Variablen identisch.</span><span class="sxs-lookup"><span data-stu-id="70835-130">The initial assignment state of an instance variable of a struct is the same as that of the containing struct variable.</span></span> <span data-ttu-id="70835-131">Anders ausgedrückt: Wenn eine Struktur Variable als anfänglich zugewiesen betrachtet wird, sind auch die Instanzvariablen, und wenn eine Struktur Variable anfänglich als nicht zugewiesen betrachtet wird, sind deren Instanzvariablen ebenfalls nicht zugewiesen.</span><span class="sxs-lookup"><span data-stu-id="70835-131">In other words, when a struct variable is considered initially assigned, so too are its instance variables, and when a struct variable is considered initially unassigned, its instance variables are likewise unassigned.</span></span>

### <a name="array-elements"></a><span data-ttu-id="70835-132">Array Elemente</span><span class="sxs-lookup"><span data-stu-id="70835-132">Array elements</span></span>

<span data-ttu-id="70835-133">Die Elemente eines Arrays entstehen, wenn eine Array Instanz erstellt wird, und sind nicht mehr vorhanden, wenn keine Verweise auf diese Array Instanz vorhanden sind.</span><span class="sxs-lookup"><span data-stu-id="70835-133">The elements of an array come into existence when an array instance is created, and cease to exist when there are no references to that array instance.</span></span>

<span data-ttu-id="70835-134">Der Anfangswert jedes Elements eines Arrays ist der Standardwert ([Standardwerte](variables.md#default-values)) vom Typ der Array Elemente.</span><span class="sxs-lookup"><span data-stu-id="70835-134">The initial value of each of the elements of an array is the default value ([Default values](variables.md#default-values)) of the type of the array elements.</span></span>

<span data-ttu-id="70835-135">Zum Zweck der eindeutigen Zuweisungs Überprüfung wird ein Array Element als anfänglich zugewiesen betrachtet.</span><span class="sxs-lookup"><span data-stu-id="70835-135">For the purpose of definite assignment checking, an array element is considered initially assigned.</span></span>

### <a name="value-parameters"></a><span data-ttu-id="70835-136">Wert Parameter</span><span class="sxs-lookup"><span data-stu-id="70835-136">Value parameters</span></span>

<span data-ttu-id="70835-137">Ein Parameter, der ohne `ref` - `out` oder-Modifizierer deklariert wird, ist ein ***Wert Parameter***.</span><span class="sxs-lookup"><span data-stu-id="70835-137">A parameter declared without a `ref` or `out` modifier is a ***value parameter***.</span></span>

<span data-ttu-id="70835-138">Ein value-Parameter ist bei dem Aufruf des Funktionsmembers (Methode, Instanzkonstruktor, Accessor oder Operator) oder der anonymen Funktion, zu der der Parameter gehört, vorhanden und wird mit dem Wert des im Aufruf angegebenen Arguments initialisiert.</span><span class="sxs-lookup"><span data-stu-id="70835-138">A value parameter comes into existence upon invocation of the function member (method, instance constructor, accessor, or operator) or anonymous function to which the parameter belongs, and is initialized with the value of the argument given in the invocation.</span></span> <span data-ttu-id="70835-139">Ein value-Parameter ist bei der Rückgabe des Funktionsmembers oder der anonymen Funktion normalerweise nicht mehr vorhanden.</span><span class="sxs-lookup"><span data-stu-id="70835-139">A value parameter normally ceases to exist upon return of the function member or anonymous function.</span></span> <span data-ttu-id="70835-140">Wenn der value-Parameter jedoch von einer anonymen Funktion ([Anonyme Funktions Ausdrücke](expressions.md#anonymous-function-expressions)) aufgezeichnet wird, erweitert seine Lebensdauer mindestens so lange, bis der Delegat oder die Ausdrucks Struktur, die von dieser anonymen Funktion erstellt wurde, für Garbage Collection qualifiziert ist.</span><span class="sxs-lookup"><span data-stu-id="70835-140">However, if the value parameter is captured by an anonymous function ([Anonymous function expressions](expressions.md#anonymous-function-expressions)), its life time extends at least until the delegate or expression tree created from that anonymous function is eligible for garbage collection.</span></span>

<span data-ttu-id="70835-141">Zum Zweck der eindeutigen Zuweisungs Überprüfung wird ein value-Parameter als anfänglich zugewiesen betrachtet.</span><span class="sxs-lookup"><span data-stu-id="70835-141">For the purpose of definite assignment checking, a value parameter is considered initially assigned.</span></span>

### <a name="reference-parameters"></a><span data-ttu-id="70835-142">Verweisparameter</span><span class="sxs-lookup"><span data-stu-id="70835-142">Reference parameters</span></span>

<span data-ttu-id="70835-143">Ein Parameter, der mit `ref` einem-Modifizierer deklariert wird, ist ein ***Verweis Parameter***.</span><span class="sxs-lookup"><span data-stu-id="70835-143">A parameter declared with a `ref` modifier is a ***reference parameter***.</span></span>

<span data-ttu-id="70835-144">Ein Verweis Parameter erstellt keinen neuen Speicherort.</span><span class="sxs-lookup"><span data-stu-id="70835-144">A reference parameter does not create a new storage location.</span></span> <span data-ttu-id="70835-145">Stattdessen stellt ein Verweis Parameter denselben Speicherort wie die Variable dar, die als Argument im Funktionsmember oder anonymen Funktionsaufruf angegeben wird.</span><span class="sxs-lookup"><span data-stu-id="70835-145">Instead, a reference parameter represents the same storage location as the variable given as the argument in the function member or anonymous function invocation.</span></span> <span data-ttu-id="70835-146">Folglich ist der Wert eines Verweis Parameters immer mit der zugrunde liegenden Variablen identisch.</span><span class="sxs-lookup"><span data-stu-id="70835-146">Thus, the value of a reference parameter is always the same as the underlying variable.</span></span>

<span data-ttu-id="70835-147">Die folgenden konkreten Zuweisungs Regeln gelten für Verweis Parameter.</span><span class="sxs-lookup"><span data-stu-id="70835-147">The following definite assignment rules apply to reference parameters.</span></span> <span data-ttu-id="70835-148">Beachten Sie die verschiedenen Regeln für Ausgabeparameter, die in [Ausgabeparametern](variables.md#output-parameters)beschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="70835-148">Note the different rules for output parameters described in [Output parameters](variables.md#output-parameters).</span></span>

*  <span data-ttu-id="70835-149">Eine Variable muss definitiv zugewiesen werden ([definitive Zuweisung](variables.md#definite-assignment)), bevor Sie als Verweis Parameter in einem Funktionsmember oder Delegataufruf übergeben werden kann.</span><span class="sxs-lookup"><span data-stu-id="70835-149">A variable must be definitely assigned ([Definite assignment](variables.md#definite-assignment)) before it can be passed as a reference parameter in a function member or delegate invocation.</span></span>
*  <span data-ttu-id="70835-150">Innerhalb eines Funktionsmembers oder einer anonymen Funktion wird ein Verweis Parameter als anfänglich zugewiesen betrachtet.</span><span class="sxs-lookup"><span data-stu-id="70835-150">Within a function member or anonymous function, a reference parameter is considered initially assigned.</span></span>

<span data-ttu-id="70835-151">In einer Instanzmethode oder einem Instanzaccessor eines Strukturtyps `this` verhält sich das Schlüsselwort genau als Verweis Parameter des Struktur Typs ([dieser Zugriff](expressions.md#this-access)).</span><span class="sxs-lookup"><span data-stu-id="70835-151">Within an instance method or instance accessor of a struct type, the `this` keyword behaves exactly as a reference parameter of the struct type ([This access](expressions.md#this-access)).</span></span>

### <a name="output-parameters"></a><span data-ttu-id="70835-152">Ausgabeparameter</span><span class="sxs-lookup"><span data-stu-id="70835-152">Output parameters</span></span>

<span data-ttu-id="70835-153">Ein mit einem `out` -Modifizierer deklarierter Parameter ist ein ***Output-Parameter***.</span><span class="sxs-lookup"><span data-stu-id="70835-153">A parameter declared with an `out` modifier is an ***output parameter***.</span></span>

<span data-ttu-id="70835-154">Mit einem Output-Parameter wird kein neuer Speicherort erstellt.</span><span class="sxs-lookup"><span data-stu-id="70835-154">An output parameter does not create a new storage location.</span></span> <span data-ttu-id="70835-155">Stattdessen stellt ein Ausgabeparameter denselben Speicherort wie die Variable dar, die im Funktionsmember oder Delegataufruf als Argument angegeben wurde.</span><span class="sxs-lookup"><span data-stu-id="70835-155">Instead, an output parameter represents the same storage location as the variable given as the argument in the function member or delegate invocation.</span></span> <span data-ttu-id="70835-156">Folglich ist der Wert eines Output-Parameters immer mit der zugrunde liegenden Variablen identisch.</span><span class="sxs-lookup"><span data-stu-id="70835-156">Thus, the value of an output parameter is always the same as the underlying variable.</span></span>

<span data-ttu-id="70835-157">Die folgenden konkreten Zuweisungs Regeln gelten für Ausgabeparameter.</span><span class="sxs-lookup"><span data-stu-id="70835-157">The following definite assignment rules apply to output parameters.</span></span> <span data-ttu-id="70835-158">Beachten Sie die verschiedenen Regeln für Verweis Parameter, die in [Verweis Parametern](variables.md#reference-parameters)beschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="70835-158">Note the different rules for reference parameters described in [Reference parameters](variables.md#reference-parameters).</span></span>

*  <span data-ttu-id="70835-159">Eine Variable muss nicht definitiv zugewiesen werden, bevor Sie als Ausgabeparameter in einem Funktionsmember oder Delegataufruf übergeben werden kann.</span><span class="sxs-lookup"><span data-stu-id="70835-159">A variable need not be definitely assigned before it can be passed as an output parameter in a function member or delegate invocation.</span></span>
*  <span data-ttu-id="70835-160">Nach dem normalen Abschluss eines Funktionsmembers oder delegataufruens wird jede Variable, die als Output-Parameter übergeben wurde, in diesem Ausführungs Pfad als zugewiesen betrachtet.</span><span class="sxs-lookup"><span data-stu-id="70835-160">Following the normal completion of a function member or delegate invocation, each variable that was passed as an output parameter is considered assigned in that execution path.</span></span>
*  <span data-ttu-id="70835-161">In einem Funktionsmember oder einer anonymen Funktion wird ein Ausgabeparameter als anfänglich nicht zugewiesen betrachtet.</span><span class="sxs-lookup"><span data-stu-id="70835-161">Within a function member or anonymous function, an output parameter is considered initially unassigned.</span></span>
*  <span data-ttu-id="70835-162">Jeder Ausgabeparameter eines Funktionsmembers oder einer anonymen Funktion muss definitiv zugewiesen werden ([definitive Zuweisung](variables.md#definite-assignment)), bevor der Funktionsmember oder die anonyme Funktion normal zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="70835-162">Every output parameter of a function member or anonymous function must be definitely assigned ([Definite assignment](variables.md#definite-assignment)) before the function member or anonymous function returns normally.</span></span>

<span data-ttu-id="70835-163">Innerhalb eines Instanzkonstruktors eines Struktur Typs verhält sich `this` das Schlüsselwort genau wie ein Ausgabeparameter des Struktur Typs ([dieser Zugriff](expressions.md#this-access)).</span><span class="sxs-lookup"><span data-stu-id="70835-163">Within an instance constructor of a struct type, the `this` keyword behaves exactly as an output parameter of the struct type ([This access](expressions.md#this-access)).</span></span>

### <a name="local-variables"></a><span data-ttu-id="70835-164">Lokale Variablen</span><span class="sxs-lookup"><span data-stu-id="70835-164">Local variables</span></span>

<span data-ttu-id="70835-165">Eine ***lokale Variable*** wird von einem *local_variable_declaration*deklariert, der in einem- *Block*, einem *for_Statement*-, *switch_statement* -oder *using_statement*-Vorgang vorkommen kann. oder durch eine *foreach_statement* oder eine *specific_catch_clause* für eine *try_statement*.</span><span class="sxs-lookup"><span data-stu-id="70835-165">A ***local variable*** is declared by a *local_variable_declaration*, which may occur in a *block*, a *for_statement*, a *switch_statement* or a *using_statement*; or by a *foreach_statement* or a *specific_catch_clause* for a *try_statement*.</span></span>

<span data-ttu-id="70835-166">Die Lebensdauer einer lokalen Variablen ist der Teil der Programmausführung, in dem sichergestellt wird, dass Speicher für Sie reserviert ist.</span><span class="sxs-lookup"><span data-stu-id="70835-166">The lifetime of a local variable is the portion of program execution during which storage is guaranteed to be reserved for it.</span></span> <span data-ttu-id="70835-167">Diese Lebensdauer erweitert mindestens den Eintrag in *Block*, *for_Statement*, *switch_statement*, *using_statement*, *foreach_statement*oder *specific_catch_clause* , mit dem Sie verknüpft ist, bis die Ausführung dieses *Blocks*, *for_Statement*, *switch_statement*, *using_statement*, *foreach_statement*oder *specific_catch_clause* endet in beliebiger Weise.</span><span class="sxs-lookup"><span data-stu-id="70835-167">This lifetime extends at least from entry into the *block*, *for_statement*, *switch_statement*, *using_statement*, *foreach_statement*, or *specific_catch_clause* with which it is associated, until execution of that *block*, *for_statement*, *switch_statement*, *using_statement*, *foreach_statement*, or *specific_catch_clause* ends in any way.</span></span> <span data-ttu-id="70835-168">(Wenn ein eingeschlossener *Block* eingegeben oder eine Methode aufgerufen wird, wird die Ausführung des aktuellen *Blocks*, *for_Statement*, *switch_statement*, *using_statement*, *foreach_statement*oder specific_ angehalten, jedoch nicht beendet.  *catch_clause*.) Wenn die lokale Variable von einer anonymen Funktion ([erfasste äußere Variablen](expressions.md#captured-outer-variables)) aufgezeichnet wird, erweitert ihre Lebensdauer mindestens so lange, bis die Delegat-oder Ausdrucks Baumstruktur, die aus der anonymen Funktion erstellt wurde, zusammen mit allen anderen Objekten, die auf das erfasste Variable, sind für Garbage Collection berechtigt.</span><span class="sxs-lookup"><span data-stu-id="70835-168">(Entering an enclosed *block* or calling a method suspends, but does not end, execution of the current *block*, *for_statement*, *switch_statement*, *using_statement*, *foreach_statement*, or *specific_catch_clause*.) If the local variable is captured by an anonymous function ([Captured outer variables](expressions.md#captured-outer-variables)), its lifetime extends at least until the delegate or expression tree created from the anonymous function, along with any other objects that come to reference the captured variable, are eligible for garbage collection.</span></span>

<span data-ttu-id="70835-169">Wenn der übergeordnete *Block*, *for_Statement*, *switch_statement*, *using_statement*, *foreach_statement*oder *specific_catch_clause* rekursiv eingegeben wird, wird jeweils eine neue Instanz der lokalen Variablen erstellt. die Zeit und Ihre *local_variable_initializer*werden ggf. jedes Mal ausgewertet.</span><span class="sxs-lookup"><span data-stu-id="70835-169">If the parent *block*, *for_statement*, *switch_statement*, *using_statement*, *foreach_statement*, or *specific_catch_clause* is entered recursively, a new instance of the local variable is created each time, and its *local_variable_initializer*, if any, is evaluated each time.</span></span>

<span data-ttu-id="70835-170">Eine von einem *local_variable_declaration* eingeführte lokale Variable wird nicht automatisch initialisiert und hat daher keinen Standardwert.</span><span class="sxs-lookup"><span data-stu-id="70835-170">A local variable introduced by a *local_variable_declaration* is not automatically initialized and thus has no default value.</span></span> <span data-ttu-id="70835-171">Zum Zweck der eindeutigen Zuweisungs Überprüfung wird eine lokale Variable, die von einem *local_variable_declaration* eingeführt wurde, als anfänglich nicht zugewiesen betrachtet.</span><span class="sxs-lookup"><span data-stu-id="70835-171">For the purpose of definite assignment checking, a local variable introduced by a *local_variable_declaration* is considered initially unassigned.</span></span> <span data-ttu-id="70835-172">Ein *local_variable_declaration* kann ein *local_variable_initializer*enthalten. in diesem Fall wird die Variable nach dem Initialisierungs Ausdruck ([Deklarations Anweisungen](variables.md#declaration-statements)) definitiv als definitiv zugewiesen betrachtet.</span><span class="sxs-lookup"><span data-stu-id="70835-172">A *local_variable_declaration* may include a *local_variable_initializer*, in which case the variable is considered definitely assigned only after the initializing expression ([Declaration statements](variables.md#declaration-statements)).</span></span>

<span data-ttu-id="70835-173">Innerhalb des Gültigkeits Bereichs einer lokalen Variablen, die von einem *local_variable_declaration*eingeführt wurde, handelt es sich um einen Kompilierzeitfehler, der in einer Textposition, die dem *local_variable_declarator*vorangestellt ist, auf diese lokale Variable verweist.</span><span class="sxs-lookup"><span data-stu-id="70835-173">Within the scope of a local variable introduced by a *local_variable_declaration*, it is a compile-time error to refer to that local variable in a textual position that precedes its *local_variable_declarator*.</span></span> <span data-ttu-id="70835-174">Wenn die Deklaration der lokalen Variablen implizit ist ([Deklarationen von lokalen Variablen](statements.md#local-variable-declarations)), ist es auch ein Fehler, auf die Variable innerhalb Ihrer *local_variable_declarator*zu verweisen.</span><span class="sxs-lookup"><span data-stu-id="70835-174">If the local variable declaration is implicit ([Local variable declarations](statements.md#local-variable-declarations)), it is also an error to refer to the variable within its *local_variable_declarator*.</span></span>

<span data-ttu-id="70835-175">Eine lokale Variable, die von einem *foreach_statement* oder einem *specific_catch_clause* eingeführt wurde, wird als definitiv in Ihrem gesamten Bereich zugewiesen.</span><span class="sxs-lookup"><span data-stu-id="70835-175">A local variable introduced by a *foreach_statement* or a *specific_catch_clause* is considered definitely assigned in its entire scope.</span></span>

<span data-ttu-id="70835-176">Die tatsächliche Lebensdauer einer lokalen Variablen ist implementierungsabhängig.</span><span class="sxs-lookup"><span data-stu-id="70835-176">The actual lifetime of a local variable is implementation-dependent.</span></span> <span data-ttu-id="70835-177">Beispielsweise kann ein Compiler statisch ermitteln, dass eine lokale Variable in einem-Block nur für einen kleinen Teil dieses Blocks verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="70835-177">For example, a compiler might statically determine that a local variable in a block is only used for a small portion of that block.</span></span> <span data-ttu-id="70835-178">Mithilfe dieser Analyse könnte der Compiler Code generieren, der dazu führt, dass der Speicher der Variablen eine kürzere Lebensdauer aufweist als der enthaltende Block.</span><span class="sxs-lookup"><span data-stu-id="70835-178">Using this analysis, the compiler could generate code that results in the variable's storage having a shorter lifetime than its containing block.</span></span>

<span data-ttu-id="70835-179">Der Speicher, auf den von einer lokalen Verweis Variablen verwiesen wird, wird unabhängig von der Lebensdauer dieser lokalen Verweis Variablen ([Automatische Speicherverwaltung](basic-concepts.md#automatic-memory-management)) freigegeben.</span><span class="sxs-lookup"><span data-stu-id="70835-179">The storage referred to by a local reference variable is reclaimed independently of the lifetime of that local reference variable ([Automatic memory management](basic-concepts.md#automatic-memory-management)).</span></span>

## <a name="default-values"></a><span data-ttu-id="70835-180">Standardwerte</span><span class="sxs-lookup"><span data-stu-id="70835-180">Default values</span></span>

<span data-ttu-id="70835-181">Die folgenden Kategorien von Variablen werden automatisch mit ihren Standardwerten initialisiert:</span><span class="sxs-lookup"><span data-stu-id="70835-181">The following categories of variables are automatically initialized to their default values:</span></span>

*  <span data-ttu-id="70835-182">Statische Variablen.</span><span class="sxs-lookup"><span data-stu-id="70835-182">Static variables.</span></span>
*  <span data-ttu-id="70835-183">Instanzvariablen von Klassen Instanzen.</span><span class="sxs-lookup"><span data-stu-id="70835-183">Instance variables of class instances.</span></span>
*  <span data-ttu-id="70835-184">Array Elemente.</span><span class="sxs-lookup"><span data-stu-id="70835-184">Array elements.</span></span>

<span data-ttu-id="70835-185">Der Standardwert einer Variablen hängt vom Typ der Variablen ab und wird wie folgt bestimmt:</span><span class="sxs-lookup"><span data-stu-id="70835-185">The default value of a variable depends on the type of the variable and is determined as follows:</span></span>

*  <span data-ttu-id="70835-186">Bei einer Variablen eines *value_type*ist der Standardwert identisch mit dem Wert, der vom Standardkonstruktor des *value_type*([Standardkonstruktoren](types.md#default-constructors)) berechnet wird.</span><span class="sxs-lookup"><span data-stu-id="70835-186">For a variable of a *value_type*, the default value is the same as the value computed by the *value_type*'s default constructor ([Default constructors](types.md#default-constructors)).</span></span>
*  <span data-ttu-id="70835-187">Der Standardwert für eine Variable eines *reference_type*ist `null`.</span><span class="sxs-lookup"><span data-stu-id="70835-187">For a variable of a *reference_type*, the default value is `null`.</span></span>

<span data-ttu-id="70835-188">Die Initialisierung zu Standardwerten erfolgt in der Regel, indem der Speicher-Manager oder Garbage Collector den Arbeitsspeicher für alle Bits-NULL initialisieren, bevor er zur Verwendung zugeordnet wird.</span><span class="sxs-lookup"><span data-stu-id="70835-188">Initialization to default values is typically done by having the memory manager or garbage collector initialize memory to all-bits-zero before it is allocated for use.</span></span> <span data-ttu-id="70835-189">Aus diesem Grund ist es praktisch, all-Bits-Zero zum Darstellen des NULL-Verweises zu verwenden.</span><span class="sxs-lookup"><span data-stu-id="70835-189">For this reason, it is convenient to use all-bits-zero to represent the null reference.</span></span>

## <a name="definite-assignment"></a><span data-ttu-id="70835-190">Definitive Zuweisung</span><span class="sxs-lookup"><span data-stu-id="70835-190">Definite assignment</span></span>

<span data-ttu-id="70835-191">An einer bestimmten Stelle im ausführbaren Code eines Funktionsmembers wird eine Variable als ***definitiv zugewiesen*** , wenn der Compiler von einer bestimmten statischen Fluss Analyse ([genaue Regeln zum Bestimmen der eindeutigen Zuweisung](variables.md#precise-rules-for-determining-definite-assignment)) nachweisen kann, dass die Variable wurde automatisch initialisiert oder war das Ziel von mindestens einer Zuweisung.</span><span class="sxs-lookup"><span data-stu-id="70835-191">At a given location in the executable code of a function member, a variable is said to be ***definitely assigned*** if the compiler can prove, by a particular static flow analysis ([Precise rules for determining definite assignment](variables.md#precise-rules-for-determining-definite-assignment)), that the variable has been automatically initialized or has been the target of at least one assignment.</span></span> <span data-ttu-id="70835-192">Die Regeln der eindeutigen Zuweisung sind:</span><span class="sxs-lookup"><span data-stu-id="70835-192">Informally stated, the rules of definite assignment are:</span></span>

*  <span data-ttu-id="70835-193">Eine anfänglich zugewiesene Variable ([anfänglich zugewiesene Variablen](variables.md#initially-assigned-variables)) wird immer als definitiv zugewiesen betrachtet.</span><span class="sxs-lookup"><span data-stu-id="70835-193">An initially assigned variable ([Initially assigned variables](variables.md#initially-assigned-variables)) is always considered definitely assigned.</span></span>
*  <span data-ttu-id="70835-194">Eine anfänglich nicht zugewiesene Variable ([anfänglich nicht zugewiesene Variablen](variables.md#initially-unassigned-variables)) wird als definitiv an einem bestimmten Speicherort zugewiesen betrachtet, wenn alle möglichen Ausführungs Pfade, die zu diesem Speicherort führen, mindestens eine der folgenden Zeichen enthalten:</span><span class="sxs-lookup"><span data-stu-id="70835-194">An initially unassigned variable ([Initially unassigned variables](variables.md#initially-unassigned-variables)) is considered definitely assigned at a given location if all possible execution paths leading to that location contain at least one of the following:</span></span>
    * <span data-ttu-id="70835-195">Eine einfache Zuweisung ([einfache Zuweisung](expressions.md#simple-assignment)), bei der die Variable der linke Operand ist.</span><span class="sxs-lookup"><span data-stu-id="70835-195">A simple assignment ([Simple assignment](expressions.md#simple-assignment)) in which the variable is the left operand.</span></span>
    * <span data-ttu-id="70835-196">Ein Aufruf Ausdruck ([Aufruf Ausdrücke](expressions.md#invocation-expressions)) oder ein Objekt Erstellungs Ausdruck ([Objekt Erstellungs Ausdrücke](expressions.md#object-creation-expressions)), der die Variable als Ausgabeparameter übergibt.</span><span class="sxs-lookup"><span data-stu-id="70835-196">An invocation expression ([Invocation expressions](expressions.md#invocation-expressions)) or object creation expression ([Object creation expressions](expressions.md#object-creation-expressions)) that passes the variable as an output parameter.</span></span>
    * <span data-ttu-id="70835-197">Für eine lokale Variable eine lokale Variablen Deklaration ([Deklarationen von lokalen Variablen](statements.md#local-variable-declarations)), die einen Variableninitialisierer einschließt.</span><span class="sxs-lookup"><span data-stu-id="70835-197">For a local variable, a local variable declaration ([Local variable declarations](statements.md#local-variable-declarations)) that includes a variable initializer.</span></span>

<span data-ttu-id="70835-198">Die formale Spezifikation, die den oben genannten informellen Regeln zugrunde liegt, wird in [anfänglich zugewiesenen Variablen](variables.md#initially-assigned-variables), [anfänglich nicht zugewiesenen Variablen](variables.md#initially-unassigned-variables)und [präzisen Regeln zum Bestimmen der eindeutigen Zuweisung](variables.md#precise-rules-for-determining-definite-assignment)beschrieben.</span><span class="sxs-lookup"><span data-stu-id="70835-198">The formal specification underlying the above informal rules is described in [Initially assigned variables](variables.md#initially-assigned-variables), [Initially unassigned variables](variables.md#initially-unassigned-variables), and [Precise rules for determining definite assignment](variables.md#precise-rules-for-determining-definite-assignment).</span></span>

<span data-ttu-id="70835-199">Die eindeutigen Zuweisungs Zustände von Instanzvariablen einer *struct_type* -Variablen werden einzeln und Kollektiv nachverfolgt.</span><span class="sxs-lookup"><span data-stu-id="70835-199">The definite assignment states of instance variables of a *struct_type* variable are tracked individually as well as collectively.</span></span> <span data-ttu-id="70835-200">Zusätzlich zu den oben aufgeführten Regeln gelten für *struct_type* -Variablen und deren Instanzvariablen die folgenden Regeln:</span><span class="sxs-lookup"><span data-stu-id="70835-200">In addition to the rules above, the following rules apply to *struct_type* variables and their instance variables:</span></span>

*  <span data-ttu-id="70835-201">Eine Instanzvariable wird als definitiv zugewiesen betrachtet, wenn die enthaltende *struct_type* -Variable als definitiv zugewiesen wird.</span><span class="sxs-lookup"><span data-stu-id="70835-201">An instance variable is considered definitely assigned if its containing *struct_type* variable is considered definitely assigned.</span></span>
*  <span data-ttu-id="70835-202">Eine *struct_type* -Variable wird als definitiv zugewiesen betrachtet, wenn die einzelnen Instanzvariablen als definitiv zugewiesen betrachtet werden.</span><span class="sxs-lookup"><span data-stu-id="70835-202">A *struct_type* variable is considered definitely assigned if each of its instance variables is considered definitely assigned.</span></span>

<span data-ttu-id="70835-203">Eine definitive Zuweisung ist eine Anforderung in den folgenden Kontexten:</span><span class="sxs-lookup"><span data-stu-id="70835-203">Definite assignment is a requirement in the following contexts:</span></span>

*  <span data-ttu-id="70835-204">Eine Variable muss an jedem Speicherort, an dem der Wert abgerufen wird, definitiv zugewiesen werden.</span><span class="sxs-lookup"><span data-stu-id="70835-204">A variable must be definitely assigned at each location where its value is obtained.</span></span> <span data-ttu-id="70835-205">Dadurch wird sichergestellt, dass nie definierte Werte auftreten.</span><span class="sxs-lookup"><span data-stu-id="70835-205">This ensures that undefined values never occur.</span></span> <span data-ttu-id="70835-206">Das Vorkommen einer Variablen in einem Ausdruck wird in Erwägung gezogen, den Wert der Variablen zu erhalten, außer wenn</span><span class="sxs-lookup"><span data-stu-id="70835-206">The occurrence of a variable in an expression is considered to obtain the value of the variable, except when</span></span>
    * <span data-ttu-id="70835-207">die Variable ist der linke Operand einer einfachen Zuweisung.</span><span class="sxs-lookup"><span data-stu-id="70835-207">the variable is the left operand of a simple assignment,</span></span>
    * <span data-ttu-id="70835-208">die Variable wird als Output-Parameter übergeben.</span><span class="sxs-lookup"><span data-stu-id="70835-208">the variable is passed as an output parameter, or</span></span>
    * <span data-ttu-id="70835-209">die Variable ist eine *struct_type* -Variable und tritt als Linker Operand eines Element Zugriffs auf.</span><span class="sxs-lookup"><span data-stu-id="70835-209">the variable is a *struct_type* variable and occurs as the left operand of a member access.</span></span>
*  <span data-ttu-id="70835-210">Eine Variable muss an jedem Speicherort, an dem Sie als Verweis Parameter übergeben wird, definitiv zugewiesen werden.</span><span class="sxs-lookup"><span data-stu-id="70835-210">A variable must be definitely assigned at each location where it is passed as a reference parameter.</span></span> <span data-ttu-id="70835-211">Dadurch wird sichergestellt, dass das aufgerufene Funktionsmember den Verweis Parameter, der anfänglich zugewiesen ist, als</span><span class="sxs-lookup"><span data-stu-id="70835-211">This ensures that the function member being invoked can consider the reference parameter initially assigned.</span></span>
*  <span data-ttu-id="70835-212">Alle Ausgabeparameter eines Funktionsmembers müssen definitiv an jedem Speicherort zugewiesen werden, an dem der Funktionsmember `return` zurückgibt (über eine-Anweisung oder durch die Ausführung, die das Ende des Funktionselement Texts erreicht).</span><span class="sxs-lookup"><span data-stu-id="70835-212">All output parameters of a function member must be definitely assigned at each location where the function member returns (through a `return` statement or through execution reaching the end of the function member body).</span></span> <span data-ttu-id="70835-213">Dadurch wird sichergestellt, dass Funktionsmember nicht definierte Werte in Ausgabeparametern zurückgeben. Dadurch kann der Compiler einen Funktionselement Aufruf in Erwägung ziehen, der eine Variable als Output-Parameter annimmt, der einer Zuweisung zur Variablen entspricht.</span><span class="sxs-lookup"><span data-stu-id="70835-213">This ensures that function members do not return undefined values in output parameters, thus enabling the compiler to consider a function member invocation that takes a variable as an output parameter equivalent to an assignment to the variable.</span></span>
*  <span data-ttu-id="70835-214">Die `this` Variable eines *struct_type* -Instanzkonstruktors muss an jedem Speicherort, an dem der Instanzkonstruktor zurückgegeben wird, definitiv zugewiesen werden.</span><span class="sxs-lookup"><span data-stu-id="70835-214">The `this` variable of a *struct_type* instance constructor must be definitely assigned at each location where that instance constructor returns.</span></span>

### <a name="initially-assigned-variables"></a><span data-ttu-id="70835-215">Anfänglich zugewiesene Variablen</span><span class="sxs-lookup"><span data-stu-id="70835-215">Initially assigned variables</span></span>

<span data-ttu-id="70835-216">Die folgenden Kategorien von Variablen werden als anfänglich zugewiesen klassifiziert:</span><span class="sxs-lookup"><span data-stu-id="70835-216">The following categories of variables are classified as initially assigned:</span></span>

*  <span data-ttu-id="70835-217">Statische Variablen.</span><span class="sxs-lookup"><span data-stu-id="70835-217">Static variables.</span></span>
*  <span data-ttu-id="70835-218">Instanzvariablen von Klassen Instanzen.</span><span class="sxs-lookup"><span data-stu-id="70835-218">Instance variables of class instances.</span></span>
*  <span data-ttu-id="70835-219">Instanzvariablen der anfänglich zugewiesenen Struktur Variablen.</span><span class="sxs-lookup"><span data-stu-id="70835-219">Instance variables of initially assigned struct variables.</span></span>
*  <span data-ttu-id="70835-220">Array Elemente.</span><span class="sxs-lookup"><span data-stu-id="70835-220">Array elements.</span></span>
*  <span data-ttu-id="70835-221">Wert Parameter.</span><span class="sxs-lookup"><span data-stu-id="70835-221">Value parameters.</span></span>
*  <span data-ttu-id="70835-222">Verweis Parameter.</span><span class="sxs-lookup"><span data-stu-id="70835-222">Reference parameters.</span></span>
*  <span data-ttu-id="70835-223">In einer `catch` -Klausel oder einer `foreach` -Anweisung deklarierte Variablen.</span><span class="sxs-lookup"><span data-stu-id="70835-223">Variables declared in a `catch` clause or a `foreach` statement.</span></span>

### <a name="initially-unassigned-variables"></a><span data-ttu-id="70835-224">Anfänglich nicht zugewiesene Variablen</span><span class="sxs-lookup"><span data-stu-id="70835-224">Initially unassigned variables</span></span>

<span data-ttu-id="70835-225">Die folgenden Kategorien von Variablen werden als anfänglich nicht zugewiesen klassifiziert:</span><span class="sxs-lookup"><span data-stu-id="70835-225">The following categories of variables are classified as initially unassigned:</span></span>

*  <span data-ttu-id="70835-226">Instanzvariablen ursprünglich nicht zugewiesener Struktur Variablen.</span><span class="sxs-lookup"><span data-stu-id="70835-226">Instance variables of initially unassigned struct variables.</span></span>
*  <span data-ttu-id="70835-227">Ausgabeparameter, einschließlich der `this` Variablen von Strukturinstanzkonstruktoren.</span><span class="sxs-lookup"><span data-stu-id="70835-227">Output parameters, including the `this` variable of struct instance constructors.</span></span>
*  <span data-ttu-id="70835-228">Lokale Variablen, mit Ausnahme derjenigen, die `catch` in einer- `foreach` Klausel oder einer-Anweisung deklariert werden.</span><span class="sxs-lookup"><span data-stu-id="70835-228">Local variables, except those declared in a `catch` clause or a `foreach` statement.</span></span>

### <a name="precise-rules-for-determining-definite-assignment"></a><span data-ttu-id="70835-229">Genaue Regeln zum Bestimmen der eindeutigen Zuweisung</span><span class="sxs-lookup"><span data-stu-id="70835-229">Precise rules for determining definite assignment</span></span>

<span data-ttu-id="70835-230">Um zu ermitteln, ob jede verwendete Variable definitiv zugewiesen ist, muss der Compiler einen Prozess verwenden, der dem in diesem Abschnitt beschriebenen Prozess entspricht.</span><span class="sxs-lookup"><span data-stu-id="70835-230">In order to determine that each used variable is definitely assigned, the compiler must use a process that is equivalent to the one described in this section.</span></span>

<span data-ttu-id="70835-231">Der Compiler verarbeitet den Text der einzelnen Funktionsmember, der über eine oder mehrere anfänglich nicht zugewiesene Variablen verfügt.</span><span class="sxs-lookup"><span data-stu-id="70835-231">The compiler processes the body of each function member that has one or more initially unassigned variables.</span></span> <span data-ttu-id="70835-232">Für jede anfänglich nicht zugewiesene Variable *v*bestimmt der Compiler einen ***eindeutigen Zuweisungs Zustand*** für *v* an jedem der folgenden Punkte im Funktionsmember:</span><span class="sxs-lookup"><span data-stu-id="70835-232">For each initially unassigned variable *v*, the compiler determines a ***definite assignment state*** for *v* at each of the following points in the function member:</span></span>

*  <span data-ttu-id="70835-233">Am Anfang jeder Anweisung</span><span class="sxs-lookup"><span data-stu-id="70835-233">At the beginning of each statement</span></span>
*  <span data-ttu-id="70835-234">Am Endpunkt ([Endpunkte und Erreichbarkeit](statements.md#end-points-and-reachability)) der einzelnen Anweisungen</span><span class="sxs-lookup"><span data-stu-id="70835-234">At the end point ([End points and reachability](statements.md#end-points-and-reachability)) of each statement</span></span>
*  <span data-ttu-id="70835-235">Auf jedem Bogen, der die Steuerung an eine andere Anweisung oder an den Endpunkt einer Anweisung überträgt</span><span class="sxs-lookup"><span data-stu-id="70835-235">On each arc which transfers control to another statement or to the end point of a statement</span></span>
*  <span data-ttu-id="70835-236">Am Anfang jedes Ausdrucks</span><span class="sxs-lookup"><span data-stu-id="70835-236">At the beginning of each expression</span></span>
*  <span data-ttu-id="70835-237">Am Ende jedes Ausdrucks</span><span class="sxs-lookup"><span data-stu-id="70835-237">At the end of each expression</span></span>

<span data-ttu-id="70835-238">Der eindeutige Zuweisungs Status von *v* kann wie folgt lauten:</span><span class="sxs-lookup"><span data-stu-id="70835-238">The definite assignment state of *v* can be either:</span></span>

*  <span data-ttu-id="70835-239">Definitiv zugewiesen.</span><span class="sxs-lookup"><span data-stu-id="70835-239">Definitely assigned.</span></span> <span data-ttu-id="70835-240">Dies deutet darauf hin, dass *v* bei allen möglichen Ablauf Steuerungen ein Wert zugewiesen wurde.</span><span class="sxs-lookup"><span data-stu-id="70835-240">This indicates that on all possible control flows to this point, *v* has been assigned a value.</span></span>
*  <span data-ttu-id="70835-241">Nicht definitiv zugewiesen.</span><span class="sxs-lookup"><span data-stu-id="70835-241">Not definitely assigned.</span></span> <span data-ttu-id="70835-242">Für den Zustand einer Variablen am Ende eines Ausdrucks vom Typ `bool`wird der Status einer Variablen, die nicht definitiv zugewiesen ist, möglicherweise in einen der folgenden Unterzustände versetzt:</span><span class="sxs-lookup"><span data-stu-id="70835-242">For the state of a variable at the end of an expression of type `bool`, the state of a variable that isn't definitely assigned may (but doesn't necessarily) fall into one of the following sub-states:</span></span>
    * <span data-ttu-id="70835-243">Definitiv nach dem true-Ausdruck zugewiesen.</span><span class="sxs-lookup"><span data-stu-id="70835-243">Definitely assigned after true expression.</span></span> <span data-ttu-id="70835-244">Dieser Status gibt an, dass *v* definitiv zugewiesen wird, wenn der boolesche Ausdruck als true ausgewertet wird, aber nicht notwendigerweise zugewiesen wird, wenn der boolesche Ausdruck als false ausgewertet wird.</span><span class="sxs-lookup"><span data-stu-id="70835-244">This state indicates that *v* is definitely assigned if the boolean expression evaluated as true, but is not necessarily assigned if the boolean expression evaluated as false.</span></span>
    * <span data-ttu-id="70835-245">Definitiv zugewiesen nach false-Ausdruck.</span><span class="sxs-lookup"><span data-stu-id="70835-245">Definitely assigned after false expression.</span></span> <span data-ttu-id="70835-246">Dieser Status gibt an, dass *v* definitiv zugewiesen wird, wenn der boolesche Ausdruck als false ausgewertet wird, aber nicht notwendigerweise zugewiesen wird, wenn der boolesche Ausdruck als true ausgewertet wird.</span><span class="sxs-lookup"><span data-stu-id="70835-246">This state indicates that *v* is definitely assigned if the boolean expression evaluated as false, but is not necessarily assigned if the boolean expression evaluated as true.</span></span>

<span data-ttu-id="70835-247">Die folgenden Regeln bestimmen, wie der Zustand einer Variablen *v* an jedem Speicherort bestimmt wird.</span><span class="sxs-lookup"><span data-stu-id="70835-247">The following rules govern how the state of a variable *v* is determined at each location.</span></span>

#### <a name="general-rules-for-statements"></a><span data-ttu-id="70835-248">Allgemeine Regeln für Anweisungen</span><span class="sxs-lookup"><span data-stu-id="70835-248">General rules for statements</span></span>

*  <span data-ttu-id="70835-249">*v* wird nicht definitiv am Anfang eines Funktionsmember-Texts zugewiesen.</span><span class="sxs-lookup"><span data-stu-id="70835-249">*v* is not definitely assigned at the beginning of a function member body.</span></span>
*  <span data-ttu-id="70835-250">*v* wird definitiv am Anfang einer beliebigen nicht erreichbaren Anweisung zugewiesen.</span><span class="sxs-lookup"><span data-stu-id="70835-250">*v* is definitely assigned at the beginning of any unreachable statement.</span></span>
*  <span data-ttu-id="70835-251">Der definitive Zuweisungs Zustand von *v* zu Beginn einer beliebigen anderen Anweisung wird durch Überprüfen des eindeutigen Zuweisungs Status von *v* für alle Ablauf Steuerungs Übertragungen bestimmt, die auf den Anfang dieser Anweisung abzielen.</span><span class="sxs-lookup"><span data-stu-id="70835-251">The definite assignment state of *v* at the beginning of any other statement is determined by checking the definite assignment state of *v* on all control flow transfers that target the beginning of that statement.</span></span> <span data-ttu-id="70835-252">Wenn (und nur wenn) *v* definitiv allen Ablauf Steuerungs Übertragungen zugewiesen ist, wird *v* definitiv am Anfang der Anweisung zugewiesen.</span><span class="sxs-lookup"><span data-stu-id="70835-252">If (and only if) *v* is definitely assigned on all such control flow transfers, then *v* is definitely assigned at the beginning of the statement.</span></span> <span data-ttu-id="70835-253">Der Satz möglicher Ablauf Steuerungs Übertragungen wird auf die gleiche Weise wie für das Überprüfen der Anweisungs Erreichbarkeit ([Endpunkte und Erreichbarkeit](statements.md#end-points-and-reachability)) bestimmt.</span><span class="sxs-lookup"><span data-stu-id="70835-253">The set of possible control flow transfers is determined in the same way as for checking statement reachability ([End points and reachability](statements.md#end-points-and-reachability)).</span></span>
*  <span data-ttu-id="70835-254">Der definitive Zuweisungs Zustand von *v* am Endpunkt eines Blocks, `checked` `unchecked`,, `foreach` `if` `while`,, `do`, `for`,, `lock`, `using`oder `switch`die-Anweisung wird ermittelt, indem der definitive Zuweisungs Status von *v* für alle Ablauf Steuerungs Übertragungen überprüft wird, die auf den Endpunkt dieser Anweisung abzielen.</span><span class="sxs-lookup"><span data-stu-id="70835-254">The definite assignment state of *v* at the end point of a block, `checked`, `unchecked`, `if`, `while`, `do`, `for`, `foreach`, `lock`, `using`, or `switch` statement is determined by checking the definite assignment state of *v* on all control flow transfers that target the end point of that statement.</span></span> <span data-ttu-id="70835-255">Wenn *v* definitiv allen Ablauf Steuerungs Übertragungen zugewiesen ist, wird *v* definitiv am Endpunkt der Anweisung zugewiesen.</span><span class="sxs-lookup"><span data-stu-id="70835-255">If *v* is definitely assigned on all such control flow transfers, then *v* is definitely assigned at the end point of the statement.</span></span> <span data-ttu-id="70835-256">Sonst *v* ist nicht definitiv am Endpunkt der Anweisung zugewiesen.</span><span class="sxs-lookup"><span data-stu-id="70835-256">Otherwise; *v* is not definitely assigned at the end point of the statement.</span></span> <span data-ttu-id="70835-257">Der Satz möglicher Ablauf Steuerungs Übertragungen wird auf die gleiche Weise wie für das Überprüfen der Anweisungs Erreichbarkeit ([Endpunkte und Erreichbarkeit](statements.md#end-points-and-reachability)) bestimmt.</span><span class="sxs-lookup"><span data-stu-id="70835-257">The set of possible control flow transfers is determined in the same way as for checking statement reachability ([End points and reachability](statements.md#end-points-and-reachability)).</span></span>

#### <a name="block-statements-checked-and-unchecked-statements"></a><span data-ttu-id="70835-258">Block Anweisungen, aktivierte und überprüfte Anweisungen</span><span class="sxs-lookup"><span data-stu-id="70835-258">Block statements, checked, and unchecked statements</span></span>

<span data-ttu-id="70835-259">Der definitive Zuweisungs Zustand *v* auf dem Steuerelement wird an die erste Anweisung der Anweisungs Liste im-Block (oder bis zum Endpunkt des-Blocks, wenn die Anweisungs Liste leer ist) mit der eindeutigen Zuweisungsanweisung *v* vor dem-Block übereinstimmen. , `checked` oder`unchecked` -Anweisung.</span><span class="sxs-lookup"><span data-stu-id="70835-259">The definite assignment state of *v* on the control transfer to the first statement of the statement list in the block (or to the end point of the block, if the statement list is empty) is the same as the definite assignment statement of *v* before the block, `checked`, or `unchecked` statement.</span></span>

#### <a name="expression-statements"></a><span data-ttu-id="70835-260">Ausdrucksanweisungen</span><span class="sxs-lookup"><span data-stu-id="70835-260">Expression statements</span></span>

<span data-ttu-id="70835-261">Für eine Expression-Anweisung *stmt* , die aus dem Expression- *expr*besteht:</span><span class="sxs-lookup"><span data-stu-id="70835-261">For an expression statement *stmt* that consists of the expression *expr*:</span></span>

*  <span data-ttu-id="70835-262">*v* hat am Anfang von *expr* denselben eindeutigen Zuweisungs Zustand wie am Anfang von " *stmt*".</span><span class="sxs-lookup"><span data-stu-id="70835-262">*v* has the same definite assignment state at the beginning of *expr* as at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="70835-263">Wenn *v* , wenn es definitiv am Ende von *expr*zugewiesen wurde, definitiv am Endpunkt von *stmt*zugewiesen wird. sonst Es ist nicht definitiv am Endpunkt von *stmt*zugewiesen.</span><span class="sxs-lookup"><span data-stu-id="70835-263">If *v* if definitely assigned at the end of *expr*, it is definitely assigned at the end point of *stmt*; otherwise; it is not definitely assigned at the end point of *stmt*.</span></span>

#### <a name="declaration-statements"></a><span data-ttu-id="70835-264">Deklarationsanweisungen</span><span class="sxs-lookup"><span data-stu-id="70835-264">Declaration statements</span></span>

*  <span data-ttu-id="70835-265">Wenn *stmt* eine Deklarations Anweisung ohne Initialisierer ist, hat *v* denselben eindeutigen Zuweisungs Zustand am Endpunkt von *stmt* wie am Anfang von *stmt*.</span><span class="sxs-lookup"><span data-stu-id="70835-265">If *stmt* is a declaration statement without initializers, then *v* has the same definite assignment state at the end point of *stmt* as at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="70835-266">Wenn *stmt* eine Deklarations Anweisung mit Initialisierern ist, wird der definitive Zuweisungs Zustand für *v* so bestimmt, als ob *stmt* eine Anweisungs Liste wäre, mit einer Zuweisungsanweisung für jede Deklaration mit einem Initialisierer (in der Reihenfolge von Deklaration).</span><span class="sxs-lookup"><span data-stu-id="70835-266">If *stmt* is a declaration statement with initializers, then the definite assignment state for *v* is determined as if *stmt* were a statement list, with one assignment statement for each declaration with an initializer (in the order of declaration).</span></span>

#### <a name="if-statements"></a><span data-ttu-id="70835-267">If-Anweisungen</span><span class="sxs-lookup"><span data-stu-id="70835-267">If statements</span></span>

<span data-ttu-id="70835-268">Für eine `if` -Anweisung *stmt* in der Form:</span><span class="sxs-lookup"><span data-stu-id="70835-268">For an `if` statement *stmt* of the form:</span></span>
```csharp
if ( expr ) then_stmt else else_stmt
```

*  <span data-ttu-id="70835-269">*v* hat am Anfang von *expr* denselben eindeutigen Zuweisungs Zustand wie am Anfang von " *stmt*".</span><span class="sxs-lookup"><span data-stu-id="70835-269">*v* has the same definite assignment state at the beginning of *expr* as at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="70835-270">Wenn *v* am Ende von *expr*definitiv zugewiesen ist, wird es definitiv auf der Ablauf Steuerungs Übertragung an *then_stmt* und entweder an *else_stmt* oder an den Endpunkt von *stmt* zugewiesen, wenn keine ELSE-Klausel vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="70835-270">If *v* is definitely assigned at the end of *expr*, then it is definitely assigned on the control flow transfer to *then_stmt* and to either *else_stmt* or to the end-point of *stmt* if there is no else clause.</span></span>
*  <span data-ttu-id="70835-271">Wenn *v* den Zustand "definitiv nach dem wahren Ausdruck zugewiesen" am Ende von *expr*hat, wird es definitiv auf der Ablauf Steuerungs Übertragung an *then_stmt*zugewiesen und nicht definitiv auf der Ablauf Steuerungs Übertragung an *else_ stmt* oder zum Endpunkt von *stmt* , wenn keine ELSE-Klausel vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="70835-271">If *v* has the state "definitely assigned after true expression" at the end of *expr*, then it is definitely assigned on the control flow transfer to *then_stmt*, and not definitely assigned on the control flow transfer to either *else_stmt* or to the end-point of *stmt* if there is no else clause.</span></span>
*  <span data-ttu-id="70835-272">Weist *v* den Status "definitiv zugewiesen nach dem falschen Ausdruck" am Ende von *expr*auf, wird es definitiv auf der Ablauf Steuerungs Übertragung an *else_stmt*zugewiesen und nicht definitiv auf der Ablauf Steuerungs Übertragung an then_stmt zugewiesen..</span><span class="sxs-lookup"><span data-stu-id="70835-272">If *v* has the state "definitely assigned after false expression" at the end of *expr*, then it is definitely assigned on the control flow transfer to *else_stmt*, and not definitely assigned on the control flow transfer to *then_stmt*.</span></span> <span data-ttu-id="70835-273">Sie ist definitiv nur dann am Endpunkt von *stmt* zugewiesen, wenn Sie definitiv am Endpunkt *then_stmt*zugewiesen ist.</span><span class="sxs-lookup"><span data-stu-id="70835-273">It is definitely assigned at the end-point of *stmt* if and only if it is definitely assigned at the end-point of *then_stmt*.</span></span>
*  <span data-ttu-id="70835-274">Andernfalls wird *v* als nicht definitiv auf der Ablauf Steuerungs Übertragung an *then_stmt* oder *else_stmt*oder an den Endpunkt von *stmt* zugewiesen, wenn keine ELSE-Klausel vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="70835-274">Otherwise, *v* is considered not definitely assigned on the control flow transfer to either the *then_stmt* or *else_stmt*, or to the end-point of *stmt* if there is no else clause.</span></span>

#### <a name="switch-statements"></a><span data-ttu-id="70835-275">Switch-Anweisungen</span><span class="sxs-lookup"><span data-stu-id="70835-275">Switch statements</span></span>

<span data-ttu-id="70835-276">In einer `switch` Anweisung *stmt* mit einem steuernden Ausdrucks- *expr*:</span><span class="sxs-lookup"><span data-stu-id="70835-276">In a `switch` statement *stmt* with a controlling expression *expr*:</span></span>

*  <span data-ttu-id="70835-277">Der definitive Zuweisungs Status von *v* am Anfang von *expr* ist mit dem Zustand *v* am Anfang von " *stmt*" identisch.</span><span class="sxs-lookup"><span data-stu-id="70835-277">The definite assignment state of *v* at the beginning of *expr* is the same as the state of *v* at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="70835-278">Der definitive Zuweisungs Status von *v* auf der Ablauf Steuerungs Liste der Ablauf Steuerung ist mit dem eindeutigen Zuweisungs Zustand *v* am Ende von *expr*identisch.</span><span class="sxs-lookup"><span data-stu-id="70835-278">The definite assignment state of *v* on the control flow transfer to a reachable switch block statement list is the same as the definite assignment state of *v* at the end of *expr*.</span></span>

#### <a name="while-statements"></a><span data-ttu-id="70835-279">While-Anweisungen</span><span class="sxs-lookup"><span data-stu-id="70835-279">While statements</span></span>

<span data-ttu-id="70835-280">Für eine `while` Anweisung *stmt* in der Form:</span><span class="sxs-lookup"><span data-stu-id="70835-280">For a `while` statement *stmt* of the form:</span></span>
```csharp
while ( expr ) while_body
```

*  <span data-ttu-id="70835-281">*v* hat am Anfang von *expr* denselben eindeutigen Zuweisungs Zustand wie am Anfang von " *stmt*".</span><span class="sxs-lookup"><span data-stu-id="70835-281">*v* has the same definite assignment state at the beginning of *expr* as at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="70835-282">Wenn *v* am Ende von *expr*definitiv zugewiesen ist, wird es definitiv auf der Ablauf Steuerungs Übertragung an *while_body* und an den Endpunkt von *stmt*zugewiesen.</span><span class="sxs-lookup"><span data-stu-id="70835-282">If *v* is definitely assigned at the end of *expr*, then it is definitely assigned on the control flow transfer to *while_body* and to the end point of *stmt*.</span></span>
*  <span data-ttu-id="70835-283">Wenn *v* den Zustand "definitiv nach dem wahren Ausdruck zugewiesen" am Ende von *expr*hat, wird es definitiv auf der Ablauf Steuerungs Übertragung an *while_body*zugewiesen, jedoch nicht definitiv am Endpunkt von *stmt*zugewiesen.</span><span class="sxs-lookup"><span data-stu-id="70835-283">If *v* has the state "definitely assigned after true expression" at the end of *expr*, then it is definitely assigned on the control flow transfer to *while_body*, but not definitely assigned at the end-point of *stmt*.</span></span>
*  <span data-ttu-id="70835-284">Wenn *v* den Zustand "definitiv zugewiesen nach dem falschen Ausdruck" am Ende von *expr*hat, wird es definitiv auf der Ablauf Steuerungs Übertragung an den Endpunkt von *stmt*zugewiesen, aber nicht definitiv auf der Ablauf Steuerungs Übertragung an, *während _body*.</span><span class="sxs-lookup"><span data-stu-id="70835-284">If *v* has the state "definitely assigned after false expression" at the end of *expr*, then it is definitely assigned on the control flow transfer to the end point of *stmt*, but not definitely assigned on the control flow transfer to *while_body*.</span></span>

#### <a name="do-statements"></a><span data-ttu-id="70835-285">Do-Anweisungen</span><span class="sxs-lookup"><span data-stu-id="70835-285">Do statements</span></span>

<span data-ttu-id="70835-286">Für eine `do` Anweisung *stmt* in der Form:</span><span class="sxs-lookup"><span data-stu-id="70835-286">For a `do` statement *stmt* of the form:</span></span>
```csharp
do do_body while ( expr ) ;
```

*  <span data-ttu-id="70835-287">*v* hat denselben eindeutigen Zuweisungs Status für die Ablauf Steuerungs Übertragung von Anfang an *do_body* wie am *Anfang von* *stmt*.</span><span class="sxs-lookup"><span data-stu-id="70835-287">*v* has the same definite assignment state on the control flow transfer from the beginning of *stmt* to *do_body* as at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="70835-288">*v* hat am Anfang von *expr* denselben eindeutigen Zuweisungs Zustand wie am Endpunkt *do_body*.</span><span class="sxs-lookup"><span data-stu-id="70835-288">*v* has the same definite assignment state at the beginning of *expr* as at the end point of *do_body*.</span></span>
*  <span data-ttu-id="70835-289">Wenn *v* am Ende von *expr*definitiv zugewiesen ist, wird es definitiv der Ablauf Steuerungs Übertragung an den Endpunkt von *stmt*zugewiesen.</span><span class="sxs-lookup"><span data-stu-id="70835-289">If *v* is definitely assigned at the end of *expr*, then it is definitely assigned on the control flow transfer to the end point of *stmt*.</span></span>
*  <span data-ttu-id="70835-290">Wenn *v* den Zustand "definitiv zugewiesen nach dem falschen Ausdruck" am Ende von *expr*hat, wird es definitiv der Ablauf Steuerungs Übertragung an den Endpunkt von *stmt*zugewiesen.</span><span class="sxs-lookup"><span data-stu-id="70835-290">If *v* has the state "definitely assigned after false expression" at the end of *expr*, then it is definitely assigned on the control flow transfer to the end point of *stmt*.</span></span>

#### <a name="for-statements"></a><span data-ttu-id="70835-291">For-Anweisungen</span><span class="sxs-lookup"><span data-stu-id="70835-291">For statements</span></span>

<span data-ttu-id="70835-292">Eindeutige Zuweisungs Überprüfung für `for` eine-Anweisung in der Form:</span><span class="sxs-lookup"><span data-stu-id="70835-292">Definite assignment checking for a `for` statement of the form:</span></span>
```csharp
for ( for_initializer ; for_condition ; for_iterator ) embedded_statement
```
<span data-ttu-id="70835-293">wird ausgeführt, als ob die-Anweisung geschrieben wurde:</span><span class="sxs-lookup"><span data-stu-id="70835-293">is done as if the statement were written:</span></span>
```csharp
{
    for_initializer ;
    while ( for_condition ) {
        embedded_statement ;
        for_iterator ;
    }
}
```

<span data-ttu-id="70835-294">Wenn das *for_condition* -Argument `true` in der `for` Anweisung weggelassen wird, wird die Auswertung der eindeutigen Zuweisung so fortgesetzt, als wäre *for_condition* in der obigen Erweiterung durch ersetzt worden.</span><span class="sxs-lookup"><span data-stu-id="70835-294">If the *for_condition* is omitted from the `for` statement, then evaluation of definite assignment proceeds as if *for_condition* were replaced with `true` in the above expansion.</span></span>

#### <a name="break-continue-and-goto-statements"></a><span data-ttu-id="70835-295">Break-, Continue-und GOTO-Anweisungen</span><span class="sxs-lookup"><span data-stu-id="70835-295">Break, continue, and goto statements</span></span>

<span data-ttu-id="70835-296">Der definitive Zuweisungs Status von *v* auf der Ablauf Steuerungs Übertragung, die `break`durch eine- `goto` ,-oder-Anweisung verursacht wurde, `continue`entspricht dem eindeutigen Zuweisungs Zustand von *v* am Anfang der Anweisung.</span><span class="sxs-lookup"><span data-stu-id="70835-296">The definite assignment state of *v* on the control flow transfer caused by a `break`, `continue`, or `goto` statement is the same as the definite assignment state of *v* at the beginning of the statement.</span></span>

#### <a name="throw-statements"></a><span data-ttu-id="70835-297">Throw-Anweisungen</span><span class="sxs-lookup"><span data-stu-id="70835-297">Throw statements</span></span>

<span data-ttu-id="70835-298">Für eine Anweisung *stmt* des Formulars</span><span class="sxs-lookup"><span data-stu-id="70835-298">For a statement *stmt* of the form</span></span>
```csharp
throw expr ;
```

<span data-ttu-id="70835-299">Der definitive Zuweisungs Status von *v* am Anfang von *expr* entspricht dem eindeutigen Zuweisungs Zustand *v* am Anfang von *stmt*.</span><span class="sxs-lookup"><span data-stu-id="70835-299">The definite assignment state of *v* at the beginning of *expr* is the same as the definite assignment state of *v* at the beginning of *stmt*.</span></span>

#### <a name="return-statements"></a><span data-ttu-id="70835-300">Return-Anweisungen</span><span class="sxs-lookup"><span data-stu-id="70835-300">Return statements</span></span>

<span data-ttu-id="70835-301">Für eine Anweisung *stmt* des Formulars</span><span class="sxs-lookup"><span data-stu-id="70835-301">For a statement *stmt* of the form</span></span>
```csharp
return expr ;
```

*  <span data-ttu-id="70835-302">Der definitive Zuweisungs Status von *v* am Anfang von *expr* entspricht dem eindeutigen Zuweisungs Zustand *v* am Anfang von *stmt*.</span><span class="sxs-lookup"><span data-stu-id="70835-302">The definite assignment state of *v* at the beginning of *expr* is the same as the definite assignment state of *v* at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="70835-303">Wenn *v* ein Ausgabeparameter ist, muss ihm definitiv entweder Folgendes zugewiesen werden:</span><span class="sxs-lookup"><span data-stu-id="70835-303">If *v* is an output parameter, then it must be definitely assigned either:</span></span>
    * <span data-ttu-id="70835-304">nach *expr*</span><span class="sxs-lookup"><span data-stu-id="70835-304">after *expr*</span></span>
    * <span data-ttu-id="70835-305">`finally` oder am Ende des-Blocks `try` von`return` oder - `try` `finally` ,der`finally` die-Anweisung einschließt. - `catch` -</span><span class="sxs-lookup"><span data-stu-id="70835-305">or at the end of the `finally` block of a `try`-`finally` or `try`-`catch`-`finally` that encloses the `return` statement.</span></span>

<span data-ttu-id="70835-306">Für eine Anweisung stmt in der Form:</span><span class="sxs-lookup"><span data-stu-id="70835-306">For a statement stmt of the form:</span></span>
```csharp
return ;
```

*  <span data-ttu-id="70835-307">Wenn *v* ein Ausgabeparameter ist, muss ihm definitiv entweder Folgendes zugewiesen werden:</span><span class="sxs-lookup"><span data-stu-id="70835-307">If *v* is an output parameter, then it must be definitely assigned either:</span></span>
    * <span data-ttu-id="70835-308">vor *stmt*</span><span class="sxs-lookup"><span data-stu-id="70835-308">before *stmt*</span></span>
    * <span data-ttu-id="70835-309">`finally` oder am Ende des-Blocks `try` von`return` oder - `try` `finally` ,der`finally` die-Anweisung einschließt. - `catch` -</span><span class="sxs-lookup"><span data-stu-id="70835-309">or at the end of the `finally` block of a `try`-`finally` or `try`-`catch`-`finally` that encloses the `return` statement.</span></span>

#### <a name="try-catch-statements"></a><span data-ttu-id="70835-310">Try-catch-Anweisungen</span><span class="sxs-lookup"><span data-stu-id="70835-310">Try-catch statements</span></span>

<span data-ttu-id="70835-311">Für eine Anweisung *stmt* in der Form:</span><span class="sxs-lookup"><span data-stu-id="70835-311">For a statement *stmt* of the form:</span></span>
```csharp
try try_block
catch(...) catch_block_1
...
catch(...) catch_block_n
```

*  <span data-ttu-id="70835-312">Der definitive Zuweisungs Zustand von *v* am Anfang von *try_block* entspricht dem eindeutigen Zuweisungs Zustand *v* am Anfang von *stmt*.</span><span class="sxs-lookup"><span data-stu-id="70835-312">The definite assignment state of *v* at the beginning of *try_block* is the same as the definite assignment state of *v* at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="70835-313">Der definitive Zuweisungs Zustand von *v* am Anfang von *catch_block_i* (für beliebige *i*) entspricht dem eindeutigen Zuweisungs Zustand *v* am Anfang von *stmt*.</span><span class="sxs-lookup"><span data-stu-id="70835-313">The definite assignment state of *v* at the beginning of *catch_block_i* (for any *i*) is the same as the definite assignment state of *v* at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="70835-314">Der definitive Zuweisungs Zustand *v* am Endpunkt von *stmt* ist definitiv zugewiesen, wenn (und nur wenn) *v* definitiv am Endpunkt von *try_block* und jeder *catch_block_i* zugewiesen ist (für alle *i* von 1 bis n).).</span><span class="sxs-lookup"><span data-stu-id="70835-314">The definite assignment state of *v* at the end-point of *stmt* is definitely assigned if (and only if) *v* is definitely assigned at the end-point of *try_block* and every *catch_block_i* (for every *i* from 1 to *n*).</span></span>

#### <a name="try-finally-statements"></a><span data-ttu-id="70835-315">Try-endlich-Anweisungen</span><span class="sxs-lookup"><span data-stu-id="70835-315">Try-finally statements</span></span>

<span data-ttu-id="70835-316">Für eine `try` Anweisung *stmt* in der Form:</span><span class="sxs-lookup"><span data-stu-id="70835-316">For a `try` statement *stmt* of the form:</span></span>
```csharp
try try_block finally finally_block
```

*  <span data-ttu-id="70835-317">Der definitive Zuweisungs Zustand von *v* am Anfang von *try_block* entspricht dem eindeutigen Zuweisungs Zustand *v* am Anfang von *stmt*.</span><span class="sxs-lookup"><span data-stu-id="70835-317">The definite assignment state of *v* at the beginning of *try_block* is the same as the definite assignment state of *v* at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="70835-318">Der definitive Zuweisungs Zustand von *v* am Anfang von *finally_block* entspricht dem eindeutigen Zuweisungs Zustand *v* am Anfang von *stmt*.</span><span class="sxs-lookup"><span data-stu-id="70835-318">The definite assignment state of *v* at the beginning of *finally_block* is the same as the definite assignment state of *v* at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="70835-319">Der definitive Zuweisungs Zustand *v* am Endpunkt von *stmt* ist definitiv zugewiesen, wenn mindestens einer der folgenden Punkte zutrifft:</span><span class="sxs-lookup"><span data-stu-id="70835-319">The definite assignment state of *v* at the end-point of *stmt* is definitely assigned if (and only if) at least one of the following is true:</span></span>
    * <span data-ttu-id="70835-320">*v* ist definitiv am Endpunkt *try_block* zugewiesen</span><span class="sxs-lookup"><span data-stu-id="70835-320">*v* is definitely assigned at the end-point of *try_block*</span></span>
    * <span data-ttu-id="70835-321">*v* ist definitiv am Endpunkt *finally_block* zugewiesen</span><span class="sxs-lookup"><span data-stu-id="70835-321">*v* is definitely assigned at the end-point of *finally_block*</span></span>

<span data-ttu-id="70835-322">Wenn eine Ablauf Steuerungs Übertragung (z. b. `goto` eine-Anweisung) erfolgt, die innerhalb von *try_block*beginnt und außerhalb von *try_block*endet, wird *v* auch als definitiv auf der Ablauf Steuerungs Übertragung zugewiesen, wenn *v* definitiv zugewiesen am Endpunkt *finally_block*.</span><span class="sxs-lookup"><span data-stu-id="70835-322">If a control flow transfer (for example, a `goto` statement) is made that begins within *try_block*, and ends outside of *try_block*, then *v* is also considered definitely assigned on that control flow transfer if *v* is definitely assigned at the end-point of *finally_block*.</span></span> <span data-ttu-id="70835-323">(Dies ist nicht nur der Fall, wenn –, wenn *v* definitiv aus einem anderen Grund für diese Ablauf Steuerungs Übertragung zugewiesen ist, auch als definitiv zugewiesen angesehen wird.)</span><span class="sxs-lookup"><span data-stu-id="70835-323">(This is not an only if—if *v* is definitely assigned for another reason on this control flow transfer, then it is still considered definitely assigned.)</span></span>

#### <a name="try-catch-finally-statements"></a><span data-ttu-id="70835-324">Try-catch-endlich-Anweisungen</span><span class="sxs-lookup"><span data-stu-id="70835-324">Try-catch-finally statements</span></span>

<span data-ttu-id="70835-325">Definitive Zuweisungs Analyse für `try` eine - `catch` - - AnweisunginderForm:`finally`</span><span class="sxs-lookup"><span data-stu-id="70835-325">Definite assignment analysis for a `try`-`catch`-`finally` statement of the form:</span></span>
```csharp
try try_block
catch(...) catch_block_1
...
catch(...) catch_block_n
finally *finally_block*
```
<span data-ttu-id="70835-326">wird ausgeführt, als ob die-Anweisung `try` eine - - `finally` -Anweisung ist `try` , die eine `catch` -Anweisung einschließt:</span><span class="sxs-lookup"><span data-stu-id="70835-326">is done as if the statement were a `try`-`finally` statement enclosing a `try`-`catch` statement:</span></span>
```csharp
try {
    try try_block
    catch(...) catch_block_1
    ...
    catch(...) catch_block_n
}
finally finally_block
```

<span data-ttu-id="70835-327">Im folgenden Beispiel wird veranschaulicht, wie sich die verschiedenen `try` Blöcke einer-Anweisung ([try-Anweisung](statements.md#the-try-statement)) auf eine definitive Zuweisung auswirken.</span><span class="sxs-lookup"><span data-stu-id="70835-327">The following example demonstrates how the different blocks of a `try` statement ([The try statement](statements.md#the-try-statement)) affect definite assignment.</span></span>
```csharp
class A
{
    static void F() {
        int i, j;
        try {
            goto LABEL;
            // neither i nor j definitely assigned
            i = 1;
            // i definitely assigned
        }

        catch {
            // neither i nor j definitely assigned
            i = 3;
            // i definitely assigned
        }

        finally {
            // neither i nor j definitely assigned
            j = 5;
            // j definitely assigned
            }
        // i and j definitely assigned
        LABEL:;
        // j definitely assigned

    }
}
```

#### <a name="foreach-statements"></a><span data-ttu-id="70835-328">Foreach-Anweisungen</span><span class="sxs-lookup"><span data-stu-id="70835-328">Foreach statements</span></span>

<span data-ttu-id="70835-329">Für eine `foreach` Anweisung *stmt* in der Form:</span><span class="sxs-lookup"><span data-stu-id="70835-329">For a `foreach` statement *stmt* of the form:</span></span>
```csharp
foreach ( type identifier in expr ) embedded_statement
```

*  <span data-ttu-id="70835-330">Der definitive Zuweisungs Status von *v* am Anfang von *expr* ist mit dem Zustand *v* am Anfang von " *stmt*" identisch.</span><span class="sxs-lookup"><span data-stu-id="70835-330">The definite assignment state of *v* at the beginning of *expr* is the same as the state of *v* at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="70835-331">Der definitive Zuweisungs Status *v* auf der Ablauf Steuerungs Übertragung an *embedded_statement* oder an den Endpunkt von *stmt* entspricht dem Zustand *v* am Ende von *expr*.</span><span class="sxs-lookup"><span data-stu-id="70835-331">The definite assignment state of *v* on the control flow transfer to *embedded_statement* or to the end point of *stmt* is the same as the state of *v* at the end of *expr*.</span></span>

#### <a name="using-statements"></a><span data-ttu-id="70835-332">Using-Anweisungen</span><span class="sxs-lookup"><span data-stu-id="70835-332">Using statements</span></span>

<span data-ttu-id="70835-333">Für eine `using` Anweisung *stmt* in der Form:</span><span class="sxs-lookup"><span data-stu-id="70835-333">For a `using` statement *stmt* of the form:</span></span>
```csharp
using ( resource_acquisition ) embedded_statement
```

*  <span data-ttu-id="70835-334">Der definitive Zuweisungs Status von *v* am Anfang von *resource_acquisition* entspricht dem Zustand *v* am Anfang von *stmt*.</span><span class="sxs-lookup"><span data-stu-id="70835-334">The definite assignment state of *v* at the beginning of *resource_acquisition* is the same as the state of *v* at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="70835-335">Der definitive Zuweisungs Zustand *v* auf der Ablauf Steuerungs Übertragung an *embedded_statement* entspricht dem Zustand *v* am Ende von *resource_acquisition*.</span><span class="sxs-lookup"><span data-stu-id="70835-335">The definite assignment state of *v* on the control flow transfer to *embedded_statement* is the same as the state of *v* at the end of *resource_acquisition*.</span></span>

#### <a name="lock-statements"></a><span data-ttu-id="70835-336">Lock-Anweisungen</span><span class="sxs-lookup"><span data-stu-id="70835-336">Lock statements</span></span>

<span data-ttu-id="70835-337">Für eine `lock` Anweisung *stmt* in der Form:</span><span class="sxs-lookup"><span data-stu-id="70835-337">For a `lock` statement *stmt* of the form:</span></span>
```csharp
lock ( expr ) embedded_statement
```

*  <span data-ttu-id="70835-338">Der definitive Zuweisungs Status von *v* am Anfang von *expr* ist mit dem Zustand *v* am Anfang von " *stmt*" identisch.</span><span class="sxs-lookup"><span data-stu-id="70835-338">The definite assignment state of *v* at the beginning of *expr* is the same as the state of *v* at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="70835-339">Der definitive Zuweisungs Status von *v* auf der Ablauf Steuerungs Übertragung an *embedded_statement* entspricht dem Zustand *v* am Ende von *expr*.</span><span class="sxs-lookup"><span data-stu-id="70835-339">The definite assignment state of *v* on the control flow transfer to *embedded_statement* is the same as the state of *v* at the end of *expr*.</span></span>

#### <a name="yield-statements"></a><span data-ttu-id="70835-340">Yield-Anweisungen</span><span class="sxs-lookup"><span data-stu-id="70835-340">Yield statements</span></span>

<span data-ttu-id="70835-341">Für eine `yield return` Anweisung *stmt* in der Form:</span><span class="sxs-lookup"><span data-stu-id="70835-341">For a `yield return` statement *stmt* of the form:</span></span>
```csharp
yield return expr ;
```

*  <span data-ttu-id="70835-342">Der definitive Zuweisungs Status von *v* am Anfang von *expr* ist mit dem Zustand *v* am Anfang von " *stmt*" identisch.</span><span class="sxs-lookup"><span data-stu-id="70835-342">The definite assignment state of *v* at the beginning of *expr* is the same as the state of *v* at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="70835-343">Der definitive Zuweisungs Status von *v* am Ende von *stmt* ist mit dem Zustand *v* am Ende von *expr*identisch.</span><span class="sxs-lookup"><span data-stu-id="70835-343">The definite assignment state of *v* at the end of *stmt* is the same as the state of *v* at the end of *expr*.</span></span>
*  <span data-ttu-id="70835-344">Eine `yield break` -Anweisung hat keine Auswirkung auf den eindeutigen Zuweisungs Zustand.</span><span class="sxs-lookup"><span data-stu-id="70835-344">A `yield break` statement has no effect on the definite assignment state.</span></span>

#### <a name="general-rules-for-simple-expressions"></a><span data-ttu-id="70835-345">Allgemeine Regeln für einfache Ausdrücke</span><span class="sxs-lookup"><span data-stu-id="70835-345">General rules for simple expressions</span></span>

<span data-ttu-id="70835-346">Die folgende Regel gilt für diese Arten von Ausdrücken: Literale ([Literale](expressions.md#literals)), einfache Namen ([einfache Namen](expressions.md#simple-names)), Element Zugriffs Ausdrücke ([Member Access](expressions.md#member-access)), nicht indizierte Basis Zugriffs Ausdrücke ([Basis Zugriff](expressions.md#base-access)), `typeof`Ausdrücke ([typeof-Operator](expressions.md#the-typeof-operator)), Standardwert Ausdrücke ([Standardwert Ausdrücke](expressions.md#default-value-expressions)) und `nameof` Ausdrücke ([nameof-Ausdrücke](expressions.md#nameof-expressions)).</span><span class="sxs-lookup"><span data-stu-id="70835-346">The following rule applies to these kinds of expressions: literals ([Literals](expressions.md#literals)), simple names ([Simple names](expressions.md#simple-names)), member access expressions ([Member access](expressions.md#member-access)), non-indexed base access expressions ([Base access](expressions.md#base-access)), `typeof` expressions ([The typeof operator](expressions.md#the-typeof-operator)), default value expressions ([Default value expressions](expressions.md#default-value-expressions)) and `nameof` expressions ([Nameof expressions](expressions.md#nameof-expressions)).</span></span>

*  <span data-ttu-id="70835-347">Der definitive Zuweisungs Zustand von *v* am Ende eines solchen Ausdrucks entspricht dem eindeutigen Zuweisungs Zustand von *v* am Anfang des Ausdrucks.</span><span class="sxs-lookup"><span data-stu-id="70835-347">The definite assignment state of *v* at the end of such an expression is the same as the definite assignment state of *v* at the beginning of the expression.</span></span>

#### <a name="general-rules-for-expressions-with-embedded-expressions"></a><span data-ttu-id="70835-348">Allgemeine Regeln für Ausdrücke mit eingebetteten Ausdrücken</span><span class="sxs-lookup"><span data-stu-id="70835-348">General rules for expressions with embedded expressions</span></span>

<span data-ttu-id="70835-349">Die folgenden Regeln gelten für diese Arten von Ausdrücken: Klammern in Klammern ([Ausdrücke in Klammern](expressions.md#parenthesized-expressions)), Element Zugriffs Ausdrücke ([Element Zugriff](expressions.md#element-access)), Basis Zugriffs Ausdrücke mit Indizierung ([Basis Zugriff](expressions.md#base-access)), Inkrement und Dekrementausdrücke ([postfix-Inkrement-und Dekrementoperatoren](expressions.md#postfix-increment-and-decrement-operators), [Präfix Inkrement-und Dekrementoperatoren](expressions.md#prefix-increment-and-decrement-operators)), Umwandlungs `-`Ausdrücke `~`(Umwandlungs[Ausdrücke](expressions.md#cast-expressions)), unärer `+`,,, `*`Ausdrücke, Binär `+`, `-`, `*`, ,`/` ,`<<`, ,`<`,, ,`>`, `%` `>>` `<=` `>=` `==`, ,,`is` ,`^` ,, Ausdrücke ([arithmetische Operatoren](expressions.md#arithmetic-operators), [Shift-Operatoren](expressions.md#shift-operators), relational `|` `&` `as` `!=` [ Operatoren](expressions.md#relational-and-type-testing-operators), [logische Operatoren](expressions.md#logical-operators)), zusammengesetzte Zuweisungs Ausdrücke ( `checked` [Verbund Zuweisung](expressions.md#compound-assignment)) und `unchecked` Ausdrücke (die aktivierten und deaktivierten[Operatoren](expressions.md#the-checked-and-unchecked-operators)), plus Array und Delegat Erstellungs Ausdrücke ([der New-Operator](expressions.md#the-new-operator)).</span><span class="sxs-lookup"><span data-stu-id="70835-349">The following rules apply to these kinds of expressions: parenthesized expressions ([Parenthesized expressions](expressions.md#parenthesized-expressions)), element access expressions ([Element access](expressions.md#element-access)), base access expressions with indexing ([Base access](expressions.md#base-access)), increment and decrement expressions ([Postfix increment and decrement operators](expressions.md#postfix-increment-and-decrement-operators), [Prefix increment and decrement operators](expressions.md#prefix-increment-and-decrement-operators)), cast expressions ([Cast expressions](expressions.md#cast-expressions)), unary `+`, `-`, `~`, `*` expressions, binary `+`, `-`, `*`, `/`, `%`, `<<`, `>>`, `<`, `<=`, `>`, `>=`, `==`, `!=`, `is`, `as`, `&`, `|`, `^` expressions ([Arithmetic operators](expressions.md#arithmetic-operators), [Shift operators](expressions.md#shift-operators), [Relational and type-testing operators](expressions.md#relational-and-type-testing-operators), [Logical operators](expressions.md#logical-operators)), compound assignment expressions ([Compound assignment](expressions.md#compound-assignment)), `checked` and `unchecked` expressions ([The checked and unchecked operators](expressions.md#the-checked-and-unchecked-operators)), plus array and delegate creation expressions ([The new operator](expressions.md#the-new-operator)).</span></span>

<span data-ttu-id="70835-350">Jeder dieser Ausdrücke verfügt über einen oder mehrere unter Ausdrücke, die in einer festgelegten Reihenfolge bedingungslos ausgewertet werden.</span><span class="sxs-lookup"><span data-stu-id="70835-350">Each of these expressions has one or more sub-expressions that are unconditionally evaluated in a fixed order.</span></span> <span data-ttu-id="70835-351">Der binäre `%` Operator wertet z. b. die linke Seite des Operators und die Rechte Seite aus.</span><span class="sxs-lookup"><span data-stu-id="70835-351">For example, the binary `%` operator evaluates the left hand side of the operator, then the right hand side.</span></span> <span data-ttu-id="70835-352">Ein Index Vorgang wertet den indizierten Ausdruck aus und wertet dann jeden Index Ausdruck in der Reihenfolge von links nach rechts aus.</span><span class="sxs-lookup"><span data-stu-id="70835-352">An indexing operation evaluates the indexed expression, and then evaluates each of the index expressions, in order from left to right.</span></span> <span data-ttu-id="70835-353">Für einen Expression- *expr*, der unter Ausdrücke *E1, E2,..., en*aufweist, die in dieser Reihenfolge ausgewertet werden:</span><span class="sxs-lookup"><span data-stu-id="70835-353">For an expression *expr*, which has sub-expressions *e1, e2, ..., eN*, evaluated in that order:</span></span>

*  <span data-ttu-id="70835-354">Der definitive Zuweisungs Zustand von *v* am Anfang von *E1* entspricht dem eindeutigen Zuweisungs Zustand am Anfang von *expr*.</span><span class="sxs-lookup"><span data-stu-id="70835-354">The definite assignment state of *v* at the beginning of *e1* is the same as the definite assignment state at the beginning of *expr*.</span></span>
*  <span data-ttu-id="70835-355">Der definitive Zuweisungs Zustand von *v* am Anfang von *Ei* (*i* größer als 1) entspricht dem eindeutigen Zuweisungs Zustand am Ende des vorherigen unter Ausdrucks.</span><span class="sxs-lookup"><span data-stu-id="70835-355">The definite assignment state of *v* at the beginning of *ei* (*i* greater than one) is the same as the definite assignment state at the end of the previous sub-expression.</span></span>
*  <span data-ttu-id="70835-356">Der definitive Zuweisungs Status von *v* am Ende von *expr* entspricht dem eindeutigen Zuweisungs Zustand am Ende von *en* .</span><span class="sxs-lookup"><span data-stu-id="70835-356">The definite assignment state of *v* at the end of *expr* is the same as the definite assignment state at the end of *eN*</span></span>

#### <a name="invocation-expressions-and-object-creation-expressions"></a><span data-ttu-id="70835-357">Ausdrücke zum Aufrufen und zum Erstellen von Objekten</span><span class="sxs-lookup"><span data-stu-id="70835-357">Invocation expressions and object creation expressions</span></span>

<span data-ttu-id="70835-358">Für einen Aufruf Ausdruck " *expr* " in der Form:</span><span class="sxs-lookup"><span data-stu-id="70835-358">For an invocation expression *expr* of the form:</span></span>
```csharp
primary_expression ( arg1 , arg2 , ... , argN )
```
<span data-ttu-id="70835-359">oder ein Objekt Erstellungs Ausdruck in der Form:</span><span class="sxs-lookup"><span data-stu-id="70835-359">or an object creation expression of the form:</span></span>
```csharp
new type ( arg1 , arg2 , ... , argN )
```

*  <span data-ttu-id="70835-360">Bei einem Aufruf Ausdruck ist der definitive Zuweisungs Zustand von *v* vor *primary_expression* mit dem Zustand *v* vor *expr*identisch.</span><span class="sxs-lookup"><span data-stu-id="70835-360">For an invocation expression, the definite assignment state of *v* before *primary_expression* is the same as the state of *v* before *expr*.</span></span>
*  <span data-ttu-id="70835-361">Bei einem Aufruf Ausdruck ist der definitive Zuweisungs Zustand von *v* vor *arg1* mit dem Zustand *v* nach *primary_expression*identisch.</span><span class="sxs-lookup"><span data-stu-id="70835-361">For an invocation expression, the definite assignment state of *v* before *arg1* is the same as the state of *v* after *primary_expression*.</span></span>
*  <span data-ttu-id="70835-362">Bei einem Objekt Erstellungs Ausdruck ist der definitive Zuweisungs Zustand von *v* vor *arg1* mit dem Zustand *v* vor *expr*identisch.</span><span class="sxs-lookup"><span data-stu-id="70835-362">For an object creation expression, the definite assignment state of *v* before *arg1* is the same as the state of *v* before *expr*.</span></span>
*  <span data-ttu-id="70835-363">Für jedes Argument *Argi*wird der definitive Zuweisungs Zustand *v* nach *Argi* durch die normalen ausdrucksregeln bestimmt, wobei alle `ref` -oder `out` -Modifizierer ignoriert werden.</span><span class="sxs-lookup"><span data-stu-id="70835-363">For each argument *argi*, the definite assignment state of *v* after *argi* is determined by the normal expression rules, ignoring any `ref` or `out` modifiers.</span></span>
*  <span data-ttu-id="70835-364">Für jedes Argument *Argi* für jeden *, der größer als* 1 ist, ist der definitive Zuweisungs Zustand *v* vor *Argi* mit dem Zustand von *v* nach dem vorherigen *arg*identisch.</span><span class="sxs-lookup"><span data-stu-id="70835-364">For each argument *argi* for any *i* greater than one, the definite assignment state of *v* before *argi* is the same as the state of *v* after the previous *arg*.</span></span>
*  <span data-ttu-id="70835-365">Wenn die Variable *v* als `out` Argument (d. h. ein Argument des Formulars `out v`) in einem der Argumente weitergegeben wird, dann wird der Zustand von *v* nach *expr* definitiv zugewiesen.</span><span class="sxs-lookup"><span data-stu-id="70835-365">If the variable *v* is passed as an `out` argument (i.e., an argument of the form `out v`) in any of the arguments, then the state of *v* after *expr* is definitely assigned.</span></span> <span data-ttu-id="70835-366">Sonst der Zustand von *v* nach *expr* ist mit dem Zustand *v* nach dem *argN*identisch.</span><span class="sxs-lookup"><span data-stu-id="70835-366">Otherwise; the state of *v* after *expr* is the same as the state of *v* after *argN*.</span></span>
*  <span data-ttu-id="70835-367">Für Arrayinitialisierer ([Array Erstellungs Ausdrücke](expressions.md#array-creation-expressions)), Objektinitialisierer ([Objektinitialisierer](expressions.md#object-initializers)), sammlungsinitialisierer (Auflistungsinitialisierer[) und](expressions.md#collection-initializers)anonyme Objektinitialisierer ([Anonyme Objekt Erstellung) Ausdrücke](expressions.md#anonymous-object-creation-expressions)), wird der definitive Zuweisungs Zustand durch die Erweiterung bestimmt, auf die diese Konstrukte festgelegt sind.</span><span class="sxs-lookup"><span data-stu-id="70835-367">For array initializers ([Array creation expressions](expressions.md#array-creation-expressions)), object initializers ([Object initializers](expressions.md#object-initializers)), collection initializers ([Collection initializers](expressions.md#collection-initializers)) and anonymous object initializers ([Anonymous object creation expressions](expressions.md#anonymous-object-creation-expressions)), the definite assignment state is determined by the expansion that these constructs are defined in terms of.</span></span>

#### <a name="simple-assignment-expressions"></a><span data-ttu-id="70835-368">Einfache Zuweisungs Ausdrücke</span><span class="sxs-lookup"><span data-stu-id="70835-368">Simple assignment expressions</span></span>

<span data-ttu-id="70835-369">Für einen Ausdrucks- *expr* in der `w = expr_rhs`Form:</span><span class="sxs-lookup"><span data-stu-id="70835-369">For an expression *expr* of the form `w = expr_rhs`:</span></span>

*  <span data-ttu-id="70835-370">Der definitive Zuweisungs Zustand von *v* vor *expr_rhs* entspricht dem eindeutigen Zuweisungs Zustand von *v* vor *expr*.</span><span class="sxs-lookup"><span data-stu-id="70835-370">The definite assignment state of *v* before *expr_rhs* is the same as the definite assignment state of *v* before *expr*.</span></span>
*  <span data-ttu-id="70835-371">Der eindeutige Zuweisungs Zustand von *v* nach *expr* wird durch Folgendes bestimmt:</span><span class="sxs-lookup"><span data-stu-id="70835-371">The definite assignment state of *v* after *expr* is determined by:</span></span>
   * <span data-ttu-id="70835-372">Wenn " *w* " dieselbe Variable wie " *v*" ist, wird der definitive Zuweisungs Zustand " *v* " nach der *expr* definitiv zugewiesen.</span><span class="sxs-lookup"><span data-stu-id="70835-372">If *w* is the same variable as *v*, then the definite assignment state of *v* after *expr* is definitely assigned.</span></span>
   * <span data-ttu-id="70835-373">Andernfalls, wenn die Zuweisung innerhalb des Instanzkonstruktors eines Struktur Typs erfolgt, wenn *w* ein Eigenschaften Zugriff ist, der eine automatisch implementierte Eigenschaft *P* auf der zu erstellenden Instanz festlegt und *v* das verborgene dahinter liegende Feld von *P*, dann ist der definitive Zuweisungs Status von *v* nach *expr* definitiv zugewiesen.</span><span class="sxs-lookup"><span data-stu-id="70835-373">Otherwise, if the assignment occurs within the instance constructor of a struct type, if *w* is a property access designating an automatically implemented property *P* on the instance being constructed and *v* is the hidden backing field of *P*, then the definite assignment state of *v* after *expr* is definitely assigned.</span></span>
   * <span data-ttu-id="70835-374">Andernfalls entspricht der eindeutige Zuweisungs Zustand von *v* nach *expr* dem eindeutigen Zuweisungs Zustand *v* nach *expr_rhs*.</span><span class="sxs-lookup"><span data-stu-id="70835-374">Otherwise, the definite assignment state of *v* after *expr* is the same as the definite assignment state of *v* after *expr_rhs*.</span></span>

#### <a name="-conditional-and-expressions"></a><span data-ttu-id="70835-375">& & (bedingte und) Ausdrücke</span><span class="sxs-lookup"><span data-stu-id="70835-375">&& (conditional AND) expressions</span></span>

<span data-ttu-id="70835-376">Für einen Ausdrucks- *expr* in der `expr_first && expr_second`Form:</span><span class="sxs-lookup"><span data-stu-id="70835-376">For an expression *expr* of the form `expr_first && expr_second`:</span></span>

*  <span data-ttu-id="70835-377">Der definitive Zuweisungs Zustand von *v* vor *expr_first* entspricht dem eindeutigen Zuweisungs Zustand von *v* vor *expr*.</span><span class="sxs-lookup"><span data-stu-id="70835-377">The definite assignment state of *v* before *expr_first* is the same as the definite assignment state of *v* before *expr*.</span></span>
*  <span data-ttu-id="70835-378">Der definitive Zuweisungs Zustand von *v* vor *expr_second* ist definitiv zugewiesen, wenn der Zustand von *v* nach *expr_first* entweder definitiv zugewiesen oder "nach dem wahren Ausdruck definitiv zugewiesen" ist.</span><span class="sxs-lookup"><span data-stu-id="70835-378">The definite assignment state of *v* before *expr_second* is definitely assigned if the state of *v* after *expr_first* is either definitely assigned or "definitely assigned after true expression".</span></span> <span data-ttu-id="70835-379">Andernfalls ist Sie nicht definitiv zugewiesen.</span><span class="sxs-lookup"><span data-stu-id="70835-379">Otherwise, it is not definitely assigned.</span></span>
*  <span data-ttu-id="70835-380">Der eindeutige Zuweisungs Zustand von *v* nach *expr* wird durch Folgendes bestimmt:</span><span class="sxs-lookup"><span data-stu-id="70835-380">The definite assignment state of *v* after *expr* is determined by:</span></span>
    * <span data-ttu-id="70835-381">Wenn *expr_first* ein konstanter `false`Ausdruck mit dem Wert ist, entspricht der eindeutige Zuweisungs Zustand von *v* nach *expr* dem eindeutigen Zuweisungs Zustand *v* nach *expr_first*.</span><span class="sxs-lookup"><span data-stu-id="70835-381">If *expr_first* is a constant expression with the value `false`, then the definite assignment state of *v* after *expr* is the same as the definite assignment state of *v* after *expr_first*.</span></span>
    * <span data-ttu-id="70835-382">Andernfalls, wenn der Zustand von *v* nach *expr_first* definitiv zugewiesen ist, wird der Status von *v* nach dem *exponl* definitiv zugewiesen.</span><span class="sxs-lookup"><span data-stu-id="70835-382">Otherwise, if the state of *v* after *expr_first* is definitely assigned, then the state of *v* after *expr* is definitely assigned.</span></span>
    * <span data-ttu-id="70835-383">Andernfalls, wenn der Zustand von *v* nach *expr_second* definitiv zugewiesen ist und der Zustand von *v* nach *expr_first* "definitiv zugewiesen nach false-Ausdruck" lautet, ist der Status von " *v* " nach *expr* definitiv vorgesehen.</span><span class="sxs-lookup"><span data-stu-id="70835-383">Otherwise, if the state of *v* after *expr_second* is definitely assigned, and the state of *v* after *expr_first* is "definitely assigned after false expression", then the state of *v* after *expr* is definitely assigned.</span></span>
    * <span data-ttu-id="70835-384">Andernfalls, wenn der Zustand von *v* nach *expr_second* definitiv zugewiesen oder "definitiv nach dem wahren Ausdruck zugewiesen" ist, *dann wird der* Zustand von *v* nach dem Ausdruck "true" nach "true" zugewiesen.</span><span class="sxs-lookup"><span data-stu-id="70835-384">Otherwise, if the state of *v* after *expr_second* is definitely assigned or "definitely assigned after true expression", then the state of *v* after *expr* is "definitely assigned after true expression".</span></span>
    * <span data-ttu-id="70835-385">Andernfalls, wenn der Zustand von *v* nach *expr_first* "definitiv zugewiesen nach false-Ausdruck" und der Zustand von *v* nach *expr_second* "definitiv zugewiesen nach false-Ausdruck", dann der Zustand *v* nach  *expr* ist "definitiv nach false-Ausdruck zugewiesen".</span><span class="sxs-lookup"><span data-stu-id="70835-385">Otherwise, if the state of *v* after *expr_first* is "definitely assigned after false expression", and the state of *v* after *expr_second* is "definitely assigned after false expression", then the state of *v* after *expr* is "definitely assigned after false expression".</span></span>
    * <span data-ttu-id="70835-386">Andernfalls ist der Zustand von *v* nach *expr* nicht definitiv zugewiesen.</span><span class="sxs-lookup"><span data-stu-id="70835-386">Otherwise, the state of *v* after *expr* is not definitely assigned.</span></span>

<span data-ttu-id="70835-387">Im Beispiel</span><span class="sxs-lookup"><span data-stu-id="70835-387">In the example</span></span>
```csharp
class A
{
    static void F(int x, int y) {
        int i;
        if (x >= 0 && (i = y) >= 0) {
            // i definitely assigned
        }
        else {
            // i not definitely assigned
        }
        // i not definitely assigned
    }
}
```
<span data-ttu-id="70835-388">die Variable `i` wird als definitiv in einer der eingebetteten Anweisungen `if` einer-Anweisung zugewiesen, jedoch nicht in der anderen.</span><span class="sxs-lookup"><span data-stu-id="70835-388">the variable `i` is considered definitely assigned in one of the embedded statements of an `if` statement but not in the other.</span></span> <span data-ttu-id="70835-389">In der `if` -Anweisung in `F`der-Methode `i` ist die-Variable definitiv in der ersten eingebetteten-Anweisung zugewiesen, `(i = y)` da die Ausführung des Ausdrucks immer der Ausführung dieser eingebetteten Anweisung vorangestellt wird.</span><span class="sxs-lookup"><span data-stu-id="70835-389">In the `if` statement in method `F`, the variable `i` is definitely assigned in the first embedded statement because execution of the expression `(i = y)` always precedes execution of this embedded statement.</span></span> <span data-ttu-id="70835-390">Im Gegensatz dazu ist die `i` Variable in der zweiten eingebetteten Anweisung nicht definitiv zugewiesen, da `x >= 0` möglicherweise false getestet hat, was dazu führt `i` , dass die Variable nicht zugewiesen wird.</span><span class="sxs-lookup"><span data-stu-id="70835-390">In contrast, the variable `i` is not definitely assigned in the second embedded statement, since `x >= 0` might have tested false, resulting in the variable `i` being unassigned.</span></span>

#### <a name="-conditional-or-expressions"></a><span data-ttu-id="70835-391">|| (bedingte oder)-Ausdrücke</span><span class="sxs-lookup"><span data-stu-id="70835-391">|| (conditional OR) expressions</span></span>

<span data-ttu-id="70835-392">Für einen Ausdrucks- *expr* in der `expr_first || expr_second`Form:</span><span class="sxs-lookup"><span data-stu-id="70835-392">For an expression *expr* of the form `expr_first || expr_second`:</span></span>

*  <span data-ttu-id="70835-393">Der definitive Zuweisungs Zustand von *v* vor *expr_first* entspricht dem eindeutigen Zuweisungs Zustand von *v* vor *expr*.</span><span class="sxs-lookup"><span data-stu-id="70835-393">The definite assignment state of *v* before *expr_first* is the same as the definite assignment state of *v* before *expr*.</span></span>
*  <span data-ttu-id="70835-394">Der definitive Zuweisungs Zustand *v* vor *expr_second* ist definitiv zugewiesen, wenn der Zustand von *v* nach *expr_first* entweder definitiv zugewiesen oder "definitiv nach false-Ausdruck zugewiesen" ist.</span><span class="sxs-lookup"><span data-stu-id="70835-394">The definite assignment state of *v* before *expr_second* is definitely assigned if the state of *v* after *expr_first* is either definitely assigned or "definitely assigned after false expression".</span></span> <span data-ttu-id="70835-395">Andernfalls ist Sie nicht definitiv zugewiesen.</span><span class="sxs-lookup"><span data-stu-id="70835-395">Otherwise, it is not definitely assigned.</span></span>
*  <span data-ttu-id="70835-396">Die definitive Zuweisungsanweisung von *v* nach *expr* wird durch Folgendes bestimmt:</span><span class="sxs-lookup"><span data-stu-id="70835-396">The definite assignment statement of *v* after *expr* is determined by:</span></span>
    * <span data-ttu-id="70835-397">Wenn *expr_first* ein konstanter `true`Ausdruck mit dem Wert ist, entspricht der eindeutige Zuweisungs Zustand von *v* nach *expr* dem eindeutigen Zuweisungs Zustand *v* nach *expr_first*.</span><span class="sxs-lookup"><span data-stu-id="70835-397">If *expr_first* is a constant expression with the value `true`, then the definite assignment state of *v* after *expr* is the same as the definite assignment state of *v* after *expr_first*.</span></span>
    * <span data-ttu-id="70835-398">Andernfalls, wenn der Zustand von *v* nach *expr_first* definitiv zugewiesen ist, wird der Status von *v* nach dem *exponl* definitiv zugewiesen.</span><span class="sxs-lookup"><span data-stu-id="70835-398">Otherwise, if the state of *v* after *expr_first* is definitely assigned, then the state of *v* after *expr* is definitely assigned.</span></span>
    * <span data-ttu-id="70835-399">Andernfalls, wenn der Zustand von *v* nach *expr_second* definitiv zugewiesen ist und der Status von *v* after *expr_first* "definitiv nach dem wahren Ausdruck zugewiesen" lautet, ist der Status von *v* nach der *expr* definitiv vorgesehen.</span><span class="sxs-lookup"><span data-stu-id="70835-399">Otherwise, if the state of *v* after *expr_second* is definitely assigned, and the state of *v* after *expr_first* is "definitely assigned after true expression", then the state of *v* after *expr* is definitely assigned.</span></span>
    * <span data-ttu-id="70835-400">Andernfalls, wenn der Zustand von *v* nach *expr_second* definitiv zugewiesen ist oder "definitiv nach false-Ausdruck zugewiesen" ist, wird der Status von *v* nach *expr* "definitiv nach dem falschen Ausdruck zugewiesen" angezeigt.</span><span class="sxs-lookup"><span data-stu-id="70835-400">Otherwise, if the state of *v* after *expr_second* is definitely assigned or "definitely assigned after false expression", then the state of *v* after *expr* is "definitely assigned after false expression".</span></span>
    * <span data-ttu-id="70835-401">Andernfalls, wenn der Zustand von *v* nach *expr_first* "definitiv nach dem wahren Ausdruck zugewiesen" und der Zustand von *v* nach *expr_second* "definitiv zugewiesen nach dem true-Ausdruck", dann der Status von *v* nach *expr* ist "definitiv nach dem wahren Ausdruck zugewiesen".</span><span class="sxs-lookup"><span data-stu-id="70835-401">Otherwise, if the state of *v* after *expr_first* is "definitely assigned after true expression", and the state of *v* after *expr_second* is "definitely assigned after true expression", then the state of *v* after *expr* is "definitely assigned after true expression".</span></span>
    * <span data-ttu-id="70835-402">Andernfalls ist der Zustand von *v* nach *expr* nicht definitiv zugewiesen.</span><span class="sxs-lookup"><span data-stu-id="70835-402">Otherwise, the state of *v* after *expr* is not definitely assigned.</span></span>

<span data-ttu-id="70835-403">Im Beispiel</span><span class="sxs-lookup"><span data-stu-id="70835-403">In the example</span></span>
```csharp
class A
{
    static void G(int x, int y) {
        int i;
        if (x >= 0 || (i = y) >= 0) {
            // i not definitely assigned
        }
        else {
            // i definitely assigned
        }
        // i not definitely assigned
    }
}
```
<span data-ttu-id="70835-404">die Variable `i` wird als definitiv in einer der eingebetteten Anweisungen `if` einer-Anweisung zugewiesen, jedoch nicht in der anderen.</span><span class="sxs-lookup"><span data-stu-id="70835-404">the variable `i` is considered definitely assigned in one of the embedded statements of an `if` statement but not in the other.</span></span> <span data-ttu-id="70835-405">In der `if` -Anweisung in `G`der-Methode `i` wird die-Variable definitiv in der zweiten eingebetteten-Anweisung zugewiesen, `(i = y)` da die Ausführung des Ausdrucks immer der Ausführung dieser eingebetteten Anweisung vorangestellt wird.</span><span class="sxs-lookup"><span data-stu-id="70835-405">In the `if` statement in method `G`, the variable `i` is definitely assigned in the second embedded statement because execution of the expression `(i = y)` always precedes execution of this embedded statement.</span></span> <span data-ttu-id="70835-406">Im Gegensatz dazu ist die `i` Variable in der ersten eingebetteten Anweisung nicht definitiv zugewiesen, da `x >= 0` möglicherweise true getestet hat, was dazu führt `i` , dass die Variable nicht zugewiesen wird.</span><span class="sxs-lookup"><span data-stu-id="70835-406">In contrast, the variable `i` is not definitely assigned in the first embedded statement, since `x >= 0` might have tested true, resulting in the variable `i` being unassigned.</span></span>

#### <a name="-logical-negation-expressions"></a><span data-ttu-id="70835-407">!</span><span class="sxs-lookup"><span data-stu-id="70835-407">!</span></span> <span data-ttu-id="70835-408">(logische Negations Ausdrücke)</span><span class="sxs-lookup"><span data-stu-id="70835-408">(logical negation) expressions</span></span>

<span data-ttu-id="70835-409">Für einen Ausdrucks- *expr* in der `! expr_operand`Form:</span><span class="sxs-lookup"><span data-stu-id="70835-409">For an expression *expr* of the form `! expr_operand`:</span></span>

*  <span data-ttu-id="70835-410">Der definitive Zuweisungs Zustand von *v* vor *expr_operand* entspricht dem eindeutigen Zuweisungs Zustand von *v* vor *expr*.</span><span class="sxs-lookup"><span data-stu-id="70835-410">The definite assignment state of *v* before *expr_operand* is the same as the definite assignment state of *v* before *expr*.</span></span>
*  <span data-ttu-id="70835-411">Der eindeutige Zuweisungs Zustand von *v* nach *expr* wird durch Folgendes bestimmt:</span><span class="sxs-lookup"><span data-stu-id="70835-411">The definite assignment state of *v* after *expr* is determined by:</span></span>
    * <span data-ttu-id="70835-412">Wenn der Zustand *v* nach \* expr_operand \* definitiv zugewiesen ist, wird der Status von *v* nach dem *exponl* definitiv zugewiesen.</span><span class="sxs-lookup"><span data-stu-id="70835-412">If the state of *v* after \*expr_operand \*is definitely assigned, then the state of *v* after *expr* is definitely assigned.</span></span>
    * <span data-ttu-id="70835-413">Wenn der Zustand *v* nach \* expr_operand \* nicht definitiv zugewiesen ist, wird der Status von *v* nach *expr* nicht definitiv zugewiesen.</span><span class="sxs-lookup"><span data-stu-id="70835-413">If the state of *v* after \*expr_operand \*is not definitely assigned, then the state of *v* after *expr* is not definitely assigned.</span></span>
    * <span data-ttu-id="70835-414">Wenn der Zustand *v* after \* expr_operand \* "definitiv nach false-Ausdruck zugewiesen *" lautet, wird der* Status von *v* nach dem Ausdruck "true" nach dem Ausdruck "true" zugewiesen.</span><span class="sxs-lookup"><span data-stu-id="70835-414">If the state of *v* after \*expr_operand \*is "definitely assigned after false expression", then the state of *v* after *expr* is "definitely assigned after true expression".</span></span>
    * <span data-ttu-id="70835-415">Wenn der Zustand *v* after \* expr_operand \* "definitiv nach dem true-Ausdruck zugewiesen" lautet, wird der Status von *v* nach der *expr* "definitiv nach dem falschen Ausdruck zugewiesen" angezeigt.</span><span class="sxs-lookup"><span data-stu-id="70835-415">If the state of *v* after \*expr_operand \*is "definitely assigned after true expression", then the state of *v* after *expr* is "definitely assigned after false expression".</span></span>

#### <a name="-null-coalescing-expressions"></a><span data-ttu-id="70835-416">??</span><span class="sxs-lookup"><span data-stu-id="70835-416">??</span></span> <span data-ttu-id="70835-417">(null Coalescing) Ausdrücke</span><span class="sxs-lookup"><span data-stu-id="70835-417">(null coalescing) expressions</span></span>

<span data-ttu-id="70835-418">Für einen Ausdrucks- *expr* in der `expr_first ?? expr_second`Form:</span><span class="sxs-lookup"><span data-stu-id="70835-418">For an expression *expr* of the form `expr_first ?? expr_second`:</span></span>

*  <span data-ttu-id="70835-419">Der definitive Zuweisungs Zustand von *v* vor *expr_first* entspricht dem eindeutigen Zuweisungs Zustand von *v* vor *expr*.</span><span class="sxs-lookup"><span data-stu-id="70835-419">The definite assignment state of *v* before *expr_first* is the same as the definite assignment state of *v* before *expr*.</span></span>
*  <span data-ttu-id="70835-420">Der definitive Zuweisungs Zustand von *v* vor *expr_second* entspricht dem eindeutigen Zuweisungs Zustand von *v* nach *expr_first*.</span><span class="sxs-lookup"><span data-stu-id="70835-420">The definite assignment state of *v* before *expr_second* is the same as the definite assignment state of *v* after *expr_first*.</span></span>
*  <span data-ttu-id="70835-421">Die definitive Zuweisungsanweisung von *v* nach *expr* wird durch Folgendes bestimmt:</span><span class="sxs-lookup"><span data-stu-id="70835-421">The definite assignment statement of *v* after *expr* is determined by:</span></span>
    * <span data-ttu-id="70835-422">Wenn *expr_first* ein konstanter Ausdruck ([Konstante Ausdrücke](expressions.md#constant-expressions)) mit dem Wert NULL ist, ist der Zustand *von v* nach *expr* mit dem Zustand von *v* nach *expr_second*identisch.</span><span class="sxs-lookup"><span data-stu-id="70835-422">If *expr_first* is a constant expression ([Constant expressions](expressions.md#constant-expressions)) with value null, then the state of *v* after *expr* is the same as the state of *v* after *expr_second*.</span></span>
*  <span data-ttu-id="70835-423">Andernfalls ist der Zustand von *v* nach *expr* mit dem eindeutigen Zuweisungs Zustand *v* nach *expr_first*identisch.</span><span class="sxs-lookup"><span data-stu-id="70835-423">Otherwise, the state of *v* after *expr* is the same as the definite assignment state of *v* after *expr_first*.</span></span>

#### <a name="-conditional-expressions"></a><span data-ttu-id="70835-424">?: (bedingte) Ausdrücke</span><span class="sxs-lookup"><span data-stu-id="70835-424">?: (conditional) expressions</span></span>

<span data-ttu-id="70835-425">Für einen Ausdrucks- *expr* in der `expr_cond ? expr_true : expr_false`Form:</span><span class="sxs-lookup"><span data-stu-id="70835-425">For an expression *expr* of the form `expr_cond ? expr_true : expr_false`:</span></span>

*  <span data-ttu-id="70835-426">Der definitive Zuweisungs Zustand von *v* vor *expr_cond* entspricht dem Zustand von *v* vor *expr*.</span><span class="sxs-lookup"><span data-stu-id="70835-426">The definite assignment state of *v* before *expr_cond* is the same as the state of *v* before *expr*.</span></span>
*  <span data-ttu-id="70835-427">Der definitive Zuweisungs Zustand *v* vor *expr_true* ist definitiv nur dann zugewiesen, wenn eine der folgenden Punkte Folgendes enthält:</span><span class="sxs-lookup"><span data-stu-id="70835-427">The definite assignment state of *v* before *expr_true* is definitely assigned if and only if one of the following holds:</span></span>
    * <span data-ttu-id="70835-428">*expr_cond* ist ein konstanter Ausdruck mit dem Wert`false`</span><span class="sxs-lookup"><span data-stu-id="70835-428">*expr_cond* is a constant expression with the value `false`</span></span>
    * <span data-ttu-id="70835-429">der Status von *v* nach dem *expr_cond* -Wert ist definitiv zugewiesen oder "nach true-Ausdruck definitiv zugewiesen".</span><span class="sxs-lookup"><span data-stu-id="70835-429">the state of *v* after *expr_cond* is definitely assigned or "definitely assigned after true expression".</span></span>
*  <span data-ttu-id="70835-430">Der definitive Zuweisungs Zustand *v* vor *expr_false* ist definitiv nur dann zugewiesen, wenn eine der folgenden Punkte Folgendes enthält:</span><span class="sxs-lookup"><span data-stu-id="70835-430">The definite assignment state of *v* before *expr_false* is definitely assigned if and only if one of the following holds:</span></span>
    * <span data-ttu-id="70835-431">*expr_cond* ist ein konstanter Ausdruck mit dem Wert`true`</span><span class="sxs-lookup"><span data-stu-id="70835-431">*expr_cond* is a constant expression with the value `true`</span></span>
*  <span data-ttu-id="70835-432">der Status von *v* nach dem *expr_cond* -Wert ist definitiv zugewiesen oder "definitiv zugewiesen nach false-Ausdruck".</span><span class="sxs-lookup"><span data-stu-id="70835-432">the state of *v* after *expr_cond* is definitely assigned or "definitely assigned after false expression".</span></span>
*  <span data-ttu-id="70835-433">Der eindeutige Zuweisungs Zustand von *v* nach *expr* wird durch Folgendes bestimmt:</span><span class="sxs-lookup"><span data-stu-id="70835-433">The definite assignment state of *v* after *expr* is determined by:</span></span>
    * <span data-ttu-id="70835-434">Wenn *expr_cond* ein konstanter Ausdruck ([Konstante Ausdrücke](expressions.md#constant-expressions)) mit `true` Wert ist, ist der Zustand von *v* nach *expr* mit dem Zustand von *v* nach *expr_true*identisch.</span><span class="sxs-lookup"><span data-stu-id="70835-434">If *expr_cond* is a constant expression ([Constant expressions](expressions.md#constant-expressions)) with value `true` then the state of *v* after *expr* is the same as the state of *v* after *expr_true*.</span></span>
    * <span data-ttu-id="70835-435">Wenn *expr_cond* ein konstanter Ausdruck ([Konstante Ausdrücke](expressions.md#constant-expressions) `false` ) mit Wert ist, dann ist der Zustand von *v* nach *expr* mit dem Zustand von *v nach* *expr_false*identisch.</span><span class="sxs-lookup"><span data-stu-id="70835-435">Otherwise, if *expr_cond* is a constant expression ([Constant expressions](expressions.md#constant-expressions)) with value `false` then the state of *v* after *expr* is the same as the state of *v* after *expr_false*.</span></span>
    * <span data-ttu-id="70835-436">Andernfalls, wenn der Zustand von *v* nach *expr_true* definitiv zugewiesen ist und der Status von *v* nach dem *expr_false* definitiv zugewiesen ist, dann wird der Status von *v* nach der *expr* definitiv zugewiesen.</span><span class="sxs-lookup"><span data-stu-id="70835-436">Otherwise, if the state of *v* after *expr_true* is definitely assigned and the state of *v* after *expr_false* is definitely assigned, then the state of *v* after *expr* is definitely assigned.</span></span>
    * <span data-ttu-id="70835-437">Andernfalls ist der Zustand von *v* nach *expr* nicht definitiv zugewiesen.</span><span class="sxs-lookup"><span data-stu-id="70835-437">Otherwise, the state of *v* after *expr* is not definitely assigned.</span></span>

#### <a name="anonymous-functions"></a><span data-ttu-id="70835-438">Anonyme Funktionen</span><span class="sxs-lookup"><span data-stu-id="70835-438">Anonymous functions</span></span>

<span data-ttu-id="70835-439">Für *lambda_expression* -oder *anonymous_method_expression* - *expr* mit einem Textkörper ( *Block* -oder *Ausdrucks* *Text*):</span><span class="sxs-lookup"><span data-stu-id="70835-439">For a *lambda_expression* or *anonymous_method_expression* *expr* with a body (either *block* or *expression*) *body*:</span></span>

*  <span data-ttu-id="70835-440">Der definitive Zuweisungs Zustand einer äußeren Variablen *v* vor dem *Text* ist mit dem Zustand *v* vor *expr*identisch.</span><span class="sxs-lookup"><span data-stu-id="70835-440">The definite assignment state of an outer variable *v* before *body* is the same as the state of *v* before *expr*.</span></span> <span data-ttu-id="70835-441">Das heißt, dass der definitive Zuweisungs Status äußerer Variablen vom Kontext der anonymen Funktion geerbt wird.</span><span class="sxs-lookup"><span data-stu-id="70835-441">That is, definite assignment state of outer variables is inherited from the context of the anonymous function.</span></span>
*  <span data-ttu-id="70835-442">Der eindeutige Zuweisungs Zustand einer äußeren Variable *v* nach *expr* ist mit dem Zustand *v* vor *expr*identisch.</span><span class="sxs-lookup"><span data-stu-id="70835-442">The definite assignment state of an outer variable *v* after *expr* is the same as the state of *v* before *expr*.</span></span>

<span data-ttu-id="70835-443">Das Beispiel</span><span class="sxs-lookup"><span data-stu-id="70835-443">The example</span></span>
```csharp
delegate bool Filter(int i);

void F() {
    int max;

    // Error, max is not definitely assigned
    Filter f = (int n) => n < max;

    max = 5;
    DoWork(f);
}
```
<span data-ttu-id="70835-444">generiert einen Kompilierzeitfehler, `max` da nicht definitiv zugewiesen ist, wo die anonyme Funktion deklariert wird.</span><span class="sxs-lookup"><span data-stu-id="70835-444">generates a compile-time error since `max` is not definitely assigned where the anonymous function is declared.</span></span> <span data-ttu-id="70835-445">Das Beispiel</span><span class="sxs-lookup"><span data-stu-id="70835-445">The example</span></span>
```csharp
delegate void D();

void F() {
    int n;
    D d = () => { n = 1; };

    d();

    // Error, n is not definitely assigned
    Console.WriteLine(n);
}
```
<span data-ttu-id="70835-446">generiert außerdem einen Kompilierzeitfehler, da die Zuweisung `n` zu in der anonymen Funktion keine Auswirkung auf den eindeutigen Zuweisungs Zustand `n` von außerhalb der anonymen Funktion hat.</span><span class="sxs-lookup"><span data-stu-id="70835-446">also generates a compile-time error since the assignment to `n` in the anonymous function has no affect on the definite assignment state of `n` outside the anonymous function.</span></span>

## <a name="variable-references"></a><span data-ttu-id="70835-447">Variablen Verweise</span><span class="sxs-lookup"><span data-stu-id="70835-447">Variable references</span></span>

<span data-ttu-id="70835-448">Ein *variable_reference* ist ein *Ausdruck* , der als Variable klassifiziert wird.</span><span class="sxs-lookup"><span data-stu-id="70835-448">A *variable_reference* is an *expression* that is classified as a variable.</span></span> <span data-ttu-id="70835-449">Ein *variable_reference* bezeichnet einen Speicherort, auf den sowohl zum Abrufen des aktuellen Werts als auch zum Speichern eines neuen Werts zugegriffen werden kann.</span><span class="sxs-lookup"><span data-stu-id="70835-449">A *variable_reference* denotes a storage location that can be accessed both to fetch the current value and to store a new value.</span></span>

```antlr
variable_reference
    : expression
    ;
```

<span data-ttu-id="70835-450">In C und C++wird ein *variable_reference* als *Lvalue*bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="70835-450">In C and C++, a *variable_reference* is known as an *lvalue*.</span></span>

## <a name="atomicity-of-variable-references"></a><span data-ttu-id="70835-451">Atomizität von Variablen verweisen</span><span class="sxs-lookup"><span data-stu-id="70835-451">Atomicity of variable references</span></span>

<span data-ttu-id="70835-452">Lese-und Schreibvorgänge der folgenden Datentypen sind atomarisch `char`: `byte` `bool`, `sbyte`, `short`, `ushort`, `uint`, `int`, `float`,, und Verweis Typen.</span><span class="sxs-lookup"><span data-stu-id="70835-452">Reads and writes of the following data types are atomic: `bool`, `char`, `byte`, `sbyte`, `short`, `ushort`, `uint`, `int`, `float`, and reference types.</span></span> <span data-ttu-id="70835-453">Außerdem sind Lese-und Schreibvorgänge von Enumerationstypen mit einem zugrunde liegenden Typ in der vorherigen Liste ebenfalls atomarisch.</span><span class="sxs-lookup"><span data-stu-id="70835-453">In addition, reads and writes of enum types with an underlying type in the previous list are also atomic.</span></span> <span data-ttu-id="70835-454">Lese-und Schreibvorgänge anderer Typen, `long`einschließlich `ulong`, `double`, und `decimal`sowie benutzerdefinierte Typen, sind nicht unbedingt atomarisch.</span><span class="sxs-lookup"><span data-stu-id="70835-454">Reads and writes of other types, including `long`, `ulong`, `double`, and `decimal`, as well as user-defined types, are not guaranteed to be atomic.</span></span> <span data-ttu-id="70835-455">Abgesehen von den Bibliotheksfunktionen, die für diesen Zweck entworfen wurden, gibt es keine Garantie für atomarische Lese-und Schreibvorgänge, z. b. im Fall von Inkrement oder Dekrement.</span><span class="sxs-lookup"><span data-stu-id="70835-455">Aside from the library functions designed for that purpose, there is no guarantee of atomic read-modify-write, such as in the case of increment or decrement.</span></span>

