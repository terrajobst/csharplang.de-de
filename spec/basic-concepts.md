---
ms.openlocfilehash: 1c3d05674f8f7b69e70e0d9e06021537fc45f7ed
ms.sourcegitcommit: 3fc033b6e98ed7ecdf46a85c79b00a3a3ddcf963
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 01/18/2019
ms.locfileid: "47229662"
---
# <a name="basic-concepts"></a><span data-ttu-id="e25fa-101">Grundlegende Konzepte</span><span class="sxs-lookup"><span data-stu-id="e25fa-101">Basic concepts</span></span>

## <a name="application-startup"></a><span data-ttu-id="e25fa-102">Anwendungsstart</span><span class="sxs-lookup"><span data-stu-id="e25fa-102">Application Startup</span></span>

<span data-ttu-id="e25fa-103">Eine Assembly, ein ***Einstiegspunkt*** heißt ein ***Anwendung***.</span><span class="sxs-lookup"><span data-stu-id="e25fa-103">An assembly that has an ***entry point*** is called an ***application***.</span></span> <span data-ttu-id="e25fa-104">Wenn eine Anwendung wird ausgeführt werden, ein neues ***Anwendungsdomäne*** erstellt wird.</span><span class="sxs-lookup"><span data-stu-id="e25fa-104">When an application is run, a new ***application domain*** is created.</span></span> <span data-ttu-id="e25fa-105">Mehrere verschiedene Instanziierungen von einer Anwendung möglicherweise gleichzeitig auf demselben Computer vorhanden, und jede hat eigene Anwendungsdomäne.</span><span class="sxs-lookup"><span data-stu-id="e25fa-105">Several different instantiations of an application may exist on the same machine at the same time, and each has its own application domain.</span></span>

<span data-ttu-id="e25fa-106">Eine Anwendungsdomäne kann Anwendungsisolation durch fungiert als Container für den Anwendungszustand.</span><span class="sxs-lookup"><span data-stu-id="e25fa-106">An application domain enables application isolation by acting as a container for application state.</span></span> <span data-ttu-id="e25fa-107">Eine Anwendungsdomäne fungiert als Container und Begrenzung der Typen, die in der Anwendung und die Klassenbibliotheken verwendeten definiert.</span><span class="sxs-lookup"><span data-stu-id="e25fa-107">An application domain acts as a container and boundary for the types defined in the application and the class libraries it uses.</span></span> <span data-ttu-id="e25fa-108">In einer Anwendungsdomäne geladene Typen unterscheiden sich von den gleichen Typ, der in einer anderen Anwendungsdomäne geladen und Instanzen von Objekten zwischen Anwendungsdomänen nicht direkt freigegeben werden.</span><span class="sxs-lookup"><span data-stu-id="e25fa-108">Types loaded into one application domain are distinct from the same type loaded into another application domain, and instances of objects are not directly shared between application domains.</span></span> <span data-ttu-id="e25fa-109">Beispielsweise jede Anwendungsdomäne verfügt über eine eigene Kopie statischer Variablen für diese Typen und für einen Typ ein statischer Konstruktor wird höchstens einmal pro Anwendungsdomäne ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="e25fa-109">For instance, each application domain has its own copy of static variables for these types, and a static constructor for a type is run at most once per application domain.</span></span> <span data-ttu-id="e25fa-110">Implementierungen können implementierungsspezifische Richtlinie oder Mechanismen für die Erstellung und Zerstörung von Anwendungsdomänen bereit.</span><span class="sxs-lookup"><span data-stu-id="e25fa-110">Implementations are free to provide implementation-specific policy or mechanisms for the creation and destruction of application domains.</span></span>

<span data-ttu-id="e25fa-111">***Starten der Anwendung*** tritt auf, wenn die ausführungsumgebung eine angegebene Methode aufruft, die als Einstiegspunkt der Anwendung bezeichnet wird.</span><span class="sxs-lookup"><span data-stu-id="e25fa-111">***Application startup*** occurs when the execution environment calls a designated method, which is referred to as the application's entry point.</span></span> <span data-ttu-id="e25fa-112">Diese Einstiegspunktmethode wird stets der Name `Main`, und kann einen der folgenden Signaturen aufweisen:</span><span class="sxs-lookup"><span data-stu-id="e25fa-112">This entry point method is always named `Main`, and can have one of the following signatures:</span></span>

```csharp
static void Main() {...}

static void Main(string[] args) {...}

static int Main() {...}

static int Main(string[] args) {...}
```

<span data-ttu-id="e25fa-113">Wie gezeigt, kann optional der Einstiegspunkt Zurückgeben einer `int` Wert.</span><span class="sxs-lookup"><span data-stu-id="e25fa-113">As shown, the entry point may optionally return an `int` value.</span></span> <span data-ttu-id="e25fa-114">Dadurch zurückgegeben Wert wird verwendet, Beenden der Anwendung ([Beenden der Anwendung](basic-concepts.md#application-termination)).</span><span class="sxs-lookup"><span data-stu-id="e25fa-114">This return value is used in application termination ([Application termination](basic-concepts.md#application-termination)).</span></span>

<span data-ttu-id="e25fa-115">Der Einstiegspunkt kann optional einen formalen Parameter aufweisen.</span><span class="sxs-lookup"><span data-stu-id="e25fa-115">The entry point may optionally have one formal parameter.</span></span> <span data-ttu-id="e25fa-116">Der Parameter kann einen beliebigen Namen aufweisen, aber der Typ des Parameters muss `string[]`.</span><span class="sxs-lookup"><span data-stu-id="e25fa-116">The parameter may have any name, but the type of the parameter must be `string[]`.</span></span> <span data-ttu-id="e25fa-117">Wenn der formale Parameter vorhanden ist, wird die ausführungsumgebung erstellt und übergibt eine `string[]` Argument mit den Befehlszeilenargumenten, die angegeben, wenn die Anwendung gestartet wurde.</span><span class="sxs-lookup"><span data-stu-id="e25fa-117">If the formal parameter is present, the execution environment creates and passes a `string[]` argument containing the command-line arguments that were specified when the application was started.</span></span> <span data-ttu-id="e25fa-118">Die `string[]` Argument ist nie null, aber es möglicherweise eine Länge von 0 (null) auf, wenn keine Befehlszeilenargumente angegeben wurden.</span><span class="sxs-lookup"><span data-stu-id="e25fa-118">The `string[]` argument is never null, but it may have a length of zero if no command-line arguments were specified.</span></span>

<span data-ttu-id="e25fa-119">Da C# das Überladen von Methoden unterstützt, kann eine Klasse oder Struktur mehrere Definitionen einer Methode enthalten, jeweils eine andere Signatur ist.</span><span class="sxs-lookup"><span data-stu-id="e25fa-119">Since C# supports method overloading, a class or struct may contain multiple definitions of some method, provided each has a different signature.</span></span> <span data-ttu-id="e25fa-120">Mit einem einzelnen Programm, keine Klasse oder Struktur kann jedoch enthalten mehr als eine Methode mit dem Namen `Main` , deren Definition kann es als Einstiegspunkt für die Anwendung verwendet werden kann.</span><span class="sxs-lookup"><span data-stu-id="e25fa-120">However, within a single program, no class or struct may contain more than one method called `Main` whose definition qualifies it to be used as an application entry point.</span></span> <span data-ttu-id="e25fa-121">Andere überladenen Versionen der `Main` sind zulässig, aber sie haben mehr als einen Parameter oder ihr einziger Parameter ist als Typ `string[]`.</span><span class="sxs-lookup"><span data-stu-id="e25fa-121">Other overloaded versions of `Main` are permitted, however, provided they have more than one parameter, or their only parameter is other than type `string[]`.</span></span>

<span data-ttu-id="e25fa-122">Eine Anwendung kann aus mehreren Klassen oder Strukturen bestehen.</span><span class="sxs-lookup"><span data-stu-id="e25fa-122">An application can be made up of multiple classes or structs.</span></span> <span data-ttu-id="e25fa-123">Es ist möglich, mehr als eine dieser Klassen oder Strukturen, die eine Methode namens enthalten `Main` , deren Definition kann es als Einstiegspunkt für die Anwendung verwendet werden kann.</span><span class="sxs-lookup"><span data-stu-id="e25fa-123">It is possible for more than one of these classes or structs to contain a method called `Main` whose definition qualifies it to be used as an application entry point.</span></span> <span data-ttu-id="e25fa-124">In solchen Fällen muss ein externer Mechanismus (z. B. eine Befehlszeilen-Compiler-Option) verwendet werden, wählen Sie eines der folgenden `Main` Methoden als Einstiegspunkt.</span><span class="sxs-lookup"><span data-stu-id="e25fa-124">In such cases, an external mechanism (such as a command-line compiler option) must be used to select one of these `Main` methods as the entry point.</span></span>

<span data-ttu-id="e25fa-125">In C# muss jede Methode als Member einer Klasse oder Struktur definiert werden.</span><span class="sxs-lookup"><span data-stu-id="e25fa-125">In C#, every method must be defined as a member of a class or struct.</span></span> <span data-ttu-id="e25fa-126">Normalerweise die deklarierte Zugriffsart ([deklariert Barrierefreiheit](basic-concepts.md#declared-accessibility)) einer Methode richtet sich nach den Zugriffsmodifizierern ([Zugriffsmodifizierer](classes.md#access-modifiers)) in der Deklaration verwendet werden soll, und ebenso der deklarierte angegeben Zugriff auf einen Typ richtet sich nach der Zugriffsmodifizierer, die in der Deklaration angegeben.</span><span class="sxs-lookup"><span data-stu-id="e25fa-126">Ordinarily, the declared accessibility ([Declared accessibility](basic-concepts.md#declared-accessibility)) of a method is determined by the access modifiers ([Access modifiers](classes.md#access-modifiers)) specified in its declaration, and similarly the declared accessibility of a type is determined by the access modifiers specified in its declaration.</span></span> <span data-ttu-id="e25fa-127">In der Reihenfolge für eine bestimmte Methode eines angegebenen Typs aufgerufen werden können müssen sowohl den Typ und das Element zugegriffen werden.</span><span class="sxs-lookup"><span data-stu-id="e25fa-127">In order for a given method of a given type to be callable, both the type and the member must be accessible.</span></span> <span data-ttu-id="e25fa-128">Allerdings ist der Einstiegspunkt der Anwendung ein besonderer Fall.</span><span class="sxs-lookup"><span data-stu-id="e25fa-128">However, the application entry point is a special case.</span></span> <span data-ttu-id="e25fa-129">Insbesondere kann die ausführungsumgebung Einstiegspunkt der Anwendung, unabhängig von die deklarierte Zugriffsart und unabhängig von die deklarierte Zugriffsart von seiner einschließenden Typdeklarationen zugreifen.</span><span class="sxs-lookup"><span data-stu-id="e25fa-129">Specifically, the execution environment can access the application's entry point regardless of its declared accessibility and regardless of the declared accessibility of its enclosing type declarations.</span></span>

<span data-ttu-id="e25fa-130">Die Einstiegspunktmethode für die Anwendung möglicherweise nicht in der Deklaration einer generischen Klasse.</span><span class="sxs-lookup"><span data-stu-id="e25fa-130">The application entry point method may not be in a generic class declaration.</span></span>

<span data-ttu-id="e25fa-131">In jeder anderen Hinsicht Verhalten sich die einstiegspunktmethoden aus, wie diejenigen, die keine Eingangspunkte sind.</span><span class="sxs-lookup"><span data-stu-id="e25fa-131">In all other respects, entry point methods behave like those that are not entry points.</span></span>

## <a name="application-termination"></a><span data-ttu-id="e25fa-132">Beenden der Anwendung</span><span class="sxs-lookup"><span data-stu-id="e25fa-132">Application termination</span></span>

<span data-ttu-id="e25fa-133">***Beenden der Anwendung*** übergibt die Steuerung an die ausführungsumgebung.</span><span class="sxs-lookup"><span data-stu-id="e25fa-133">***Application termination*** returns control to the execution environment.</span></span>

<span data-ttu-id="e25fa-134">Wenn der Rückgabetyp der Anwendung ***Einstiegspunkt*** Methode `int`, der zurückgegebene Wert dient als der Anwendung ***Beendigungsstatuscode***.</span><span class="sxs-lookup"><span data-stu-id="e25fa-134">If the return type of the application's ***entry point*** method is `int`, the value returned serves as the application's ***termination status code***.</span></span> <span data-ttu-id="e25fa-135">Dieser Code dient zum Zulassen der Kommunikation von Erfolg oder Fehler für die ausführungsumgebung.</span><span class="sxs-lookup"><span data-stu-id="e25fa-135">The purpose of this code is to allow communication of success or failure to the execution environment.</span></span>

<span data-ttu-id="e25fa-136">Ist der Rückgabetyp der der Einstiegspunktmethode `void`, erreichen die rechte geschweifte Klammer (`}`) der beendet werden, die Methode oder Ausführen einer `return` -Anweisung, die keine Ausdruck hat einen Statuscode der Beendigung des führt `0`.</span><span class="sxs-lookup"><span data-stu-id="e25fa-136">If the return type of the entry point method is `void`, reaching the right brace (`}`) which terminates that method, or executing a `return` statement that has no expression, results in a termination status code of `0`.</span></span>

<span data-ttu-id="e25fa-137">Vor der Beendigung einer Anwendung, Destruktoren für alle Objekte, die noch nicht über Garbage Collection bereinigt wurden aufgerufen werden, wenn eine solche Bereinigung unterdrückt wurde (durch einen Aufruf an die Bibliotheksmethode `GC.SuppressFinalize`, z. B.).</span><span class="sxs-lookup"><span data-stu-id="e25fa-137">Prior to an application's termination, destructors for all of its objects that have not yet been garbage collected are called, unless such cleanup has been suppressed (by a call to the library method `GC.SuppressFinalize`, for example).</span></span>

## <a name="declarations"></a><span data-ttu-id="e25fa-138">Deklarationen</span><span class="sxs-lookup"><span data-stu-id="e25fa-138">Declarations</span></span>

<span data-ttu-id="e25fa-139">Deklarationen in einem C#-Programm definieren Sie die einzelnen Elemente des Programms.</span><span class="sxs-lookup"><span data-stu-id="e25fa-139">Declarations in a C# program define the constituent elements of the program.</span></span> <span data-ttu-id="e25fa-140">C#-Programme werden mithilfe von Namespaces organisiert ([Namespaces](namespaces.md)), Typ enthalten kann Deklarationen und geschachtelten Namespace-Deklarationen.</span><span class="sxs-lookup"><span data-stu-id="e25fa-140">C# programs are organized using namespaces ([Namespaces](namespaces.md)), which can contain type declarations and nested namespace declarations.</span></span> <span data-ttu-id="e25fa-141">Typdeklarationen ([Typdeklarationen](namespaces.md#type-declarations)) werden verwendet, um Klassen zu definieren ([Klassen](classes.md)), Strukturen ([Strukturen](structs.md)), Schnittstellen ([Schnittstellen](interfaces.md) ), Enumerationen ([Enumerationen](enums.md)), und Delegaten ([Delegaten](delegates.md)).</span><span class="sxs-lookup"><span data-stu-id="e25fa-141">Type declarations ([Type declarations](namespaces.md#type-declarations)) are used to define classes ([Classes](classes.md)), structs ([Structs](structs.md)), interfaces ([Interfaces](interfaces.md)), enums ([Enums](enums.md)), and delegates ([Delegates](delegates.md)).</span></span> <span data-ttu-id="e25fa-142">Die Arten von Membern, die in einer Typdeklaration zulässig, abhängig von der Form der Deklaration des ab.</span><span class="sxs-lookup"><span data-stu-id="e25fa-142">The kinds of members permitted in a type declaration depend on the form of the type declaration.</span></span> <span data-ttu-id="e25fa-143">Klassendeklarationen können z. B. Deklarationen, die für Konstanten enthalten ([Konstanten](classes.md#constants)), Felder ([Felder](classes.md#fields)), Methoden ([Methoden](classes.md#methods)), Eigenschaften ([ Eigenschaften](classes.md#properties)), Ereignisse ([Ereignisse](classes.md#events)), Indexer ([Indexer](classes.md#indexers)), Operatoren ([Operatoren](classes.md#operators)), Instanzkonstruktoren ([ Instanzkonstruktoren](classes.md#instance-constructors)), statische Konstruktoren ([statische Konstruktoren](classes.md#static-constructors)), Destruktoren ([Destruktoren](classes.md#destructors)), und geschachtelte Typen ([geschachtelte Typen](classes.md#nested-types)).</span><span class="sxs-lookup"><span data-stu-id="e25fa-143">For instance, class declarations can contain declarations for constants ([Constants](classes.md#constants)), fields ([Fields](classes.md#fields)), methods ([Methods](classes.md#methods)), properties ([Properties](classes.md#properties)), events ([Events](classes.md#events)), indexers ([Indexers](classes.md#indexers)), operators ([Operators](classes.md#operators)), instance constructors ([Instance constructors](classes.md#instance-constructors)), static constructors ([Static constructors](classes.md#static-constructors)), destructors ([Destructors](classes.md#destructors)), and nested types ([Nested types](classes.md#nested-types)).</span></span>

<span data-ttu-id="e25fa-144">Eine Deklaration definiert einen Namen in der ***Deklarationsabschnitt*** , der die Deklaration angehört.</span><span class="sxs-lookup"><span data-stu-id="e25fa-144">A declaration defines a name in the ***declaration space*** to which the declaration belongs.</span></span> <span data-ttu-id="e25fa-145">Mit Ausnahme von überladenen Membern ([Signaturen und überladen](basic-concepts.md#signatures-and-overloading)), es ist ein Fehler während der Kompilierung, um zwei oder mehr Deklarationen zu erhalten, die Member mit demselben Namen in einem Deklarationsabschnitt einführen.</span><span class="sxs-lookup"><span data-stu-id="e25fa-145">Except for overloaded members ([Signatures and overloading](basic-concepts.md#signatures-and-overloading)), it is a compile-time error to have two or more declarations that introduce members with the same name in a declaration space.</span></span> <span data-ttu-id="e25fa-146">Es ist nicht möglich, dass eine Deklarationsabschnitt auf verschiedene Arten von Membern mit dem gleichen Namen enthalten.</span><span class="sxs-lookup"><span data-stu-id="e25fa-146">It is never possible for a declaration space to contain different kinds of members with the same name.</span></span> <span data-ttu-id="e25fa-147">Beispielsweise kann ein Deklarationsabschnitt nie ein Feld und eine Methode mit dem gleichen Namen enthalten.</span><span class="sxs-lookup"><span data-stu-id="e25fa-147">For example, a declaration space can never contain a field and a method by the same name.</span></span>

<span data-ttu-id="e25fa-148">Es gibt verschiedene Arten von Deklaration Leerzeichen, wie im folgenden beschrieben.</span><span class="sxs-lookup"><span data-stu-id="e25fa-148">There are several different types of declaration spaces, as described in the following.</span></span>

*  <span data-ttu-id="e25fa-149">In allen Quelldateien von einem Programm *Namespace_member_declaration*mit ohne einschließenden *Namespace_declaration* sind Mitglieder einer einzelnen kombinierten Deklarationsabschnitts wird aufgerufen, die ***globale Deklarationsabschnitt***.</span><span class="sxs-lookup"><span data-stu-id="e25fa-149">Within all source files of a program, *namespace_member_declaration*s with no enclosing *namespace_declaration* are members of a single combined declaration space called the ***global declaration space***.</span></span>
*  <span data-ttu-id="e25fa-150">In allen Quelldateien von einem Programm *Namespace_member_declaration*e in *Namespace_declaration*s, die den gleichen Namen für den vollqualifizierten Namespace haben sind Mitglieder einer einzelnen kombinierten Deklaration Speicherplatz.</span><span class="sxs-lookup"><span data-stu-id="e25fa-150">Within all source files of a program, *namespace_member_declaration*s within *namespace_declaration*s that have the same fully qualified namespace name are members of a single combined declaration space.</span></span>
*  <span data-ttu-id="e25fa-151">Jede Klasse, Struktur oder Schnittstellendeklaration erstellt einen neuen Deklarationsabschnitt.</span><span class="sxs-lookup"><span data-stu-id="e25fa-151">Each class, struct, or interface declaration creates a new declaration space.</span></span> <span data-ttu-id="e25fa-152">Namen werden in diesen Deklarationsabschnitt über eingeführt *Class_member_declaration*s, *Struct_member_declaration*s, *Interface_member_declaration*s, oder *Type_parameter*s.</span><span class="sxs-lookup"><span data-stu-id="e25fa-152">Names are introduced into this declaration space through *class_member_declaration*s, *struct_member_declaration*s, *interface_member_declaration*s, or *type_parameter*s.</span></span> <span data-ttu-id="e25fa-153">Mit Ausnahme von überladenen Instanzkonstruktor darf keine Deklarationen und statischen Konstruktor Deklarationen, eine Klasse oder Struktur eine Memberdeklaration mit dem gleichen Namen wie die Klasse oder Struktur enthalten.</span><span class="sxs-lookup"><span data-stu-id="e25fa-153">Except for overloaded instance constructor declarations and static constructor declarations, a class or struct cannot contain a member declaration with the same name as the class or struct.</span></span> <span data-ttu-id="e25fa-154">Eine Klasse, Struktur oder Schnittstelle ermöglicht die Deklaration der überladenen Methoden und Indexer.</span><span class="sxs-lookup"><span data-stu-id="e25fa-154">A class, struct, or interface permits the declaration of overloaded methods and indexers.</span></span> <span data-ttu-id="e25fa-155">Darüber hinaus ermöglicht einer Klasse oder Struktur, die Deklaration der der überladenen Instanzkonstruktoren und Operatoren.</span><span class="sxs-lookup"><span data-stu-id="e25fa-155">Furthermore, a class or struct permits the declaration of overloaded instance constructors and operators.</span></span> <span data-ttu-id="e25fa-156">Z. B. eine Klasse, Struktur oder Schnittstelle darf mehrere Methodendeklarationen mit demselben Namen, sofern diese Methodendeklarationen in deren Signatur unterscheiden ([Signaturen und überladen](basic-concepts.md#signatures-and-overloading)).</span><span class="sxs-lookup"><span data-stu-id="e25fa-156">For example, a class, struct, or interface may contain multiple method declarations with the same name, provided these method declarations differ in their signature ([Signatures and overloading](basic-concepts.md#signatures-and-overloading)).</span></span> <span data-ttu-id="e25fa-157">Beachten Sie, dass Basisklassen tragen nicht zum Deklarationsbereich einer Klasse Basisschnittstellen tragen nicht zum Deklarationsbereich einer Schnittstelle.</span><span class="sxs-lookup"><span data-stu-id="e25fa-157">Note that base classes do not contribute to the declaration space of a class, and base interfaces do not contribute to the declaration space of an interface.</span></span> <span data-ttu-id="e25fa-158">Daher ist eine abgeleitete Klasse oder Schnittstelle zulässig, um ein Element mit dem gleichen Namen wie für einen geerbten Member zu deklarieren.</span><span class="sxs-lookup"><span data-stu-id="e25fa-158">Thus, a derived class or interface is allowed to declare a member with the same name as an inherited member.</span></span> <span data-ttu-id="e25fa-159">Solcher Member gilt als ***ausblenden*** geerbten Members.</span><span class="sxs-lookup"><span data-stu-id="e25fa-159">Such a member is said to ***hide*** the inherited member.</span></span>
*  <span data-ttu-id="e25fa-160">Jede Delegatdeklaration erstellt einen neuen Deklarationsabschnitt.</span><span class="sxs-lookup"><span data-stu-id="e25fa-160">Each delegate declaration creates a new declaration space.</span></span> <span data-ttu-id="e25fa-161">Namen werden durch formale Parameter in diesen eingeführt (*Fixed_parameter*s und *Parameter_array*s) und *Type_parameter*s.</span><span class="sxs-lookup"><span data-stu-id="e25fa-161">Names are introduced into this declaration space through formal parameters (*fixed_parameter*s and *parameter_array*s) and *type_parameter*s.</span></span>
*  <span data-ttu-id="e25fa-162">Alle Enumerationsdeklarationen erstellt einen neuen Deklarationsabschnitt.</span><span class="sxs-lookup"><span data-stu-id="e25fa-162">Each enumeration declaration creates a new declaration space.</span></span> <span data-ttu-id="e25fa-163">Namen werden in diesen Deklarationsabschnitt über eingeführt *Enum_member_declarations*.</span><span class="sxs-lookup"><span data-stu-id="e25fa-163">Names are introduced into this declaration space through *enum_member_declarations*.</span></span>
*  <span data-ttu-id="e25fa-164">Jede Deklaration der Methode, Indexerdeklaration, Operatordeklaration, Instanz Konstruktordeklaration verwendet und anonyme Funktion erstellt einen neuen Deklarationsabschnitt wird aufgerufen, eine ***Deklaration lokaler Variablen Speicherplatz***.</span><span class="sxs-lookup"><span data-stu-id="e25fa-164">Each method declaration, indexer declaration, operator declaration, instance constructor declaration and anonymous function creates a new declaration space called a ***local variable declaration space***.</span></span> <span data-ttu-id="e25fa-165">Namen werden durch formale Parameter in diesen eingeführt (*Fixed_parameter*s und *Parameter_array*s) und *Type_parameter*s.</span><span class="sxs-lookup"><span data-stu-id="e25fa-165">Names are introduced into this declaration space through formal parameters (*fixed_parameter*s and *parameter_array*s) and *type_parameter*s.</span></span> <span data-ttu-id="e25fa-166">Der Text der Funktionsmember der Member oder eine anonyme Funktion, sofern vorhanden, gilt in der Deklaration lokaler Variablen Speicherplatz geschachtelt werden.</span><span class="sxs-lookup"><span data-stu-id="e25fa-166">The body of the function member or anonymous function, if any, is considered to be nested within the local variable declaration space.</span></span> <span data-ttu-id="e25fa-167">Es ist ein Fehler für eine Deklaration lokaler Variablen und einer geschachtelten lokalen Variablendeklaration Speicherplatz Elemente mit dem gleichen Namen enthalten.</span><span class="sxs-lookup"><span data-stu-id="e25fa-167">It is an error for a local variable declaration space and a nested local variable declaration space to contain elements with the same name.</span></span> <span data-ttu-id="e25fa-168">Daher ist es in einer geschachtelten Deklarationsabschnitt nicht möglich, eine lokale Variable oder Konstante mit dem gleichen Namen wie eine lokale Variable oder Konstante in einem einschließenden Deklarationsbereich deklarieren.</span><span class="sxs-lookup"><span data-stu-id="e25fa-168">Thus, within a nested declaration space it is not possible to declare a local variable or constant with the same name as a local variable or constant in an enclosing declaration space.</span></span> <span data-ttu-id="e25fa-169">Es ist möglich, dass zwei Deklaration Leerzeichen Elemente mit dem gleichen Namen enthalten, solange weder Deklarationsabschnitt der anderen enthält.</span><span class="sxs-lookup"><span data-stu-id="e25fa-169">It is possible for two declaration spaces to contain elements with the same name as long as neither declaration space contains the other.</span></span>
*  <span data-ttu-id="e25fa-170">Jede *Block* oder *Switch_block* , sowie ein *für*, *Foreach* und *mit* -Anweisung erstellt eine Deklaration lokaler Variablen den Speicherplatz für lokale Variablen und lokalen Konstanten.</span><span class="sxs-lookup"><span data-stu-id="e25fa-170">Each *block* or *switch_block* , as well as a *for*, *foreach* and *using* statement, creates a local variable declaration space for local variables and local constants .</span></span> <span data-ttu-id="e25fa-171">Namen werden in diesen Deklarationsabschnitt über eingeführt *Local_variable_declaration*s und *Local_constant_declaration*s.</span><span class="sxs-lookup"><span data-stu-id="e25fa-171">Names are introduced into this declaration space through *local_variable_declaration*s and *local_constant_declaration*s.</span></span> <span data-ttu-id="e25fa-172">Beachten Sie, dass es sich bei der Deklaration lokaler Variablen Speicherplatz, die von diesen Funktionen für ihre Parameter deklariert Blöcke, die auftreten, als "oder" innerhalb des Texts einer Funktionsmember der Member oder eine anonyme Funktion geschachtelt sind.</span><span class="sxs-lookup"><span data-stu-id="e25fa-172">Note that blocks that occur as or within the body of a function member or anonymous function are nested within the local variable declaration space declared by those functions for their parameters.</span></span> <span data-ttu-id="e25fa-173">Daher ist es ein Fehler, z. B. eine Methode mit einer lokalen Variablen und Parameter mit dem gleichen Namen haben.</span><span class="sxs-lookup"><span data-stu-id="e25fa-173">Thus it is an error to have e.g. a method with a local variable and a parameter of the same name.</span></span>
*  <span data-ttu-id="e25fa-174">Jede *Block* oder *Switch_block* erstellt einen separaten Deklarationsabschnitt für Bezeichnungen.</span><span class="sxs-lookup"><span data-stu-id="e25fa-174">Each *block* or *switch_block* creates a separate declaration space for labels.</span></span> <span data-ttu-id="e25fa-175">Namen werden in diesen Deklarationsabschnitt über eingeführt *Labeled_statement*s und die Namen sind auf die verwiesen wird durch *Goto_statement*s.</span><span class="sxs-lookup"><span data-stu-id="e25fa-175">Names are introduced into this declaration space through *labeled_statement*s, and the names are referenced through *goto_statement*s.</span></span> <span data-ttu-id="e25fa-176">Die ***Bezeichnung Deklarationsabschnitt*** eines Blocks enthält keine geschachtelten Blöcke.</span><span class="sxs-lookup"><span data-stu-id="e25fa-176">The ***label declaration space*** of a block includes any nested blocks.</span></span> <span data-ttu-id="e25fa-177">Daher ist es in einem geschachtelten Block nicht möglich, eine Bezeichnung mit dem gleichen Namen wie eine Bezeichnung in einem einschließenden Block deklarieren.</span><span class="sxs-lookup"><span data-stu-id="e25fa-177">Thus, within a nested block it is not possible to declare a label with the same name as a label in an enclosing block.</span></span>

<span data-ttu-id="e25fa-178">Die Reihenfolge im Text in der Namen deklariert werden, ist im Allgemeinen ohne Bedeutung.</span><span class="sxs-lookup"><span data-stu-id="e25fa-178">The textual order in which names are declared is generally of no significance.</span></span> <span data-ttu-id="e25fa-179">Insbesondere ist die Reihenfolge im Text nicht für die Deklaration und Verwendung von Namespaces, Konstanten, Methoden, Eigenschaften, Ereignisse, Indexer, Operatoren, Instanzkonstruktoren, Destruktoren, statische Konstruktoren und Typen von großer Bedeutung.</span><span class="sxs-lookup"><span data-stu-id="e25fa-179">In particular, textual order is not significant for the declaration and use of namespaces, constants, methods, properties, events, indexers, operators, instance constructors, destructors, static constructors, and types.</span></span> <span data-ttu-id="e25fa-180">Reihenfolge der Deklaration ist wichtig, es gibt folgende Möglichkeiten:</span><span class="sxs-lookup"><span data-stu-id="e25fa-180">Declaration order is significant in the following ways:</span></span>

*  <span data-ttu-id="e25fa-181">Die Reihenfolge der Deklaration für die Steuerelementfeld-Deklarationen und Deklarationen von lokalen Variablen bestimmt die Reihenfolge, in der ihre Initialisierer (sofern vorhanden) ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="e25fa-181">Declaration order for field declarations and local variable declarations determines the order in which their initializers (if any) are executed.</span></span>
*  <span data-ttu-id="e25fa-182">Lokale Variablen müssen definiert werden, bevor sie verwendet werden ([Bereiche](basic-concepts.md#scopes)).</span><span class="sxs-lookup"><span data-stu-id="e25fa-182">Local variables must be defined before they are used ([Scopes](basic-concepts.md#scopes)).</span></span>
*  <span data-ttu-id="e25fa-183">Die Reihenfolge der Deklaration für Enum-Deklarationen ([Enumerationsmember](enums.md#enum-members)) ist wichtig, wenn *Constant_expression* -Werte weggelassen werden.</span><span class="sxs-lookup"><span data-stu-id="e25fa-183">Declaration order for enum member declarations ([Enum members](enums.md#enum-members)) is significant when *constant_expression* values are omitted.</span></span>

<span data-ttu-id="e25fa-184">Deklarationsbereich eines Namespace ist "ohne feste Begrenzung", und zwei Deklarationen mit demselben vollqualifizierten Namen zum selben Deklarationsabschnitt beitragen.</span><span class="sxs-lookup"><span data-stu-id="e25fa-184">The declaration space of a namespace is "open ended", and two namespace declarations with the same fully qualified name contribute to the same declaration space.</span></span> <span data-ttu-id="e25fa-185">Beispiel:</span><span class="sxs-lookup"><span data-stu-id="e25fa-185">For example</span></span>
```csharp
namespace Megacorp.Data
{
    class Customer
    {
        ...
    }
}

namespace Megacorp.Data
{
    class Order
    {
        ...
    }
}
```

<span data-ttu-id="e25fa-186">die beiden oben genannten Namespacedeklarationen beitragen zum selben Deklarationsabschnitt, deklarieren zwei Klassen mit den vollqualifizierten Namen in diesem Fall `Megacorp.Data.Customer` und `Megacorp.Data.Order`.</span><span class="sxs-lookup"><span data-stu-id="e25fa-186">The two namespace declarations above contribute to the same declaration space, in this case declaring two classes with the fully qualified names `Megacorp.Data.Customer` and `Megacorp.Data.Order`.</span></span> <span data-ttu-id="e25fa-187">Da die beiden Deklarationen zum selben Deklarationsabschnitt beitragen möchten, haben sie würde ein Kompilierungsfehler verursacht, wenn jeweils eine Deklaration einer Klasse mit dem gleichen Namen enthalten.</span><span class="sxs-lookup"><span data-stu-id="e25fa-187">Because the two declarations contribute to the same declaration space, it would have caused a compile-time error if each contained a declaration of a class with the same name.</span></span>

<span data-ttu-id="e25fa-188">Wie oben angegeben ist schließt der Deklaration eines Blocks keine geschachtelten Blöcke.</span><span class="sxs-lookup"><span data-stu-id="e25fa-188">As specified above, the declaration space of a block includes any nested blocks.</span></span> <span data-ttu-id="e25fa-189">Im folgenden Beispiel die `F` und `G` Methoden führen zu einem Fehler während der Kompilierung, da der Name `i` im äußeren-Block deklariert wird und nicht im inneren Block erneut deklariert werden.</span><span class="sxs-lookup"><span data-stu-id="e25fa-189">Thus, in the following example, the `F` and `G` methods result in a compile-time error because the name `i` is declared in the outer block and cannot be redeclared in the inner block.</span></span> <span data-ttu-id="e25fa-190">Allerdings die `H` und `I` Methoden sind gültig, da die beiden `i`des werden in separaten nicht geschachtelten Blöcken deklariert.</span><span class="sxs-lookup"><span data-stu-id="e25fa-190">However, the `H` and `I` methods are valid since the two `i`'s are declared in separate non-nested blocks.</span></span>

```csharp
class A
{
    void F() {
        int i = 0;
        if (true) {
            int i = 1;            
        }
    }

    void G() {
        if (true) {
            int i = 0;
        }
        int i = 1;                
    }

    void H() {
        if (true) {
            int i = 0;
        }
        if (true) {
            int i = 1;
        }
    }

    void I() {
        for (int i = 0; i < 10; i++)
            H();
        for (int i = 0; i < 10; i++)
            H();
    }
}
```

## <a name="members"></a><span data-ttu-id="e25fa-191">Member</span><span class="sxs-lookup"><span data-stu-id="e25fa-191">Members</span></span>

<span data-ttu-id="e25fa-192">Namespaces und Typen haben ***Mitglieder***.</span><span class="sxs-lookup"><span data-stu-id="e25fa-192">Namespaces and types have ***members***.</span></span> <span data-ttu-id="e25fa-193">Die Elemente einer Entität sind allgemein verfügbar ist, durch die Verwendung von einem qualifizierten Namen, die beginnt mit einem Verweis auf die Entität, gefolgt von einem "`.`" token, gefolgt vom Namen des Members.</span><span class="sxs-lookup"><span data-stu-id="e25fa-193">The members of an entity are generally available through the use of a qualified name that starts with a reference to the entity, followed by a "`.`" token, followed by the name of the member.</span></span>

<span data-ttu-id="e25fa-194">Member eines Typs deklariert werden entweder in der Typdeklaration oder ***geerbt*** von der Basisklasse des Typs.</span><span class="sxs-lookup"><span data-stu-id="e25fa-194">Members of a type are either declared in the type declaration or ***inherited*** from the base class of the type.</span></span> <span data-ttu-id="e25fa-195">Wenn ein Typ von einer Basisklasse erbt, werden alle Member der Basisklasse, mit Ausnahme der Instanzkonstruktoren, Destruktoren und statischen Konstruktoren, die Member des abgeleiteten Typs.</span><span class="sxs-lookup"><span data-stu-id="e25fa-195">When a type inherits from a base class, all members of the base class, except instance constructors, destructors and static constructors, become members of the derived type.</span></span> <span data-ttu-id="e25fa-196">Die deklarierte Zugriffsart eines Members der Basisklasse nicht gesteuert, ob das Element geerbt wird, Vererbung erstreckt sich auch auf ein Element, das einen Instanzenkonstruktor, statischen Konstruktor oder Destruktor ist nicht.</span><span class="sxs-lookup"><span data-stu-id="e25fa-196">The declared accessibility of a base class member does not control whether the member is inherited—inheritance extends to any member that isn't an instance constructor, static constructor, or destructor.</span></span> <span data-ttu-id="e25fa-197">Allerdings ein geerbter Member kann nicht zugegriffen werden in einem abgeleiteten Typ, entweder aufgrund von die deklarierte Zugriffsart ([deklariert Barrierefreiheit](basic-concepts.md#declared-accessibility)) oder weil es mit einer Deklaration in den Typ selbst ausgeblendet wird ([durch Ausblenden Vererbung](basic-concepts.md#hiding-through-inheritance)).</span><span class="sxs-lookup"><span data-stu-id="e25fa-197">However, an inherited member may not be accessible in a derived type, either because of its declared accessibility ([Declared accessibility](basic-concepts.md#declared-accessibility)) or because it is hidden by a declaration in the type itself ([Hiding through inheritance](basic-concepts.md#hiding-through-inheritance)).</span></span>

### <a name="namespace-members"></a><span data-ttu-id="e25fa-198">Namespace-Elemente</span><span class="sxs-lookup"><span data-stu-id="e25fa-198">Namespace members</span></span>

<span data-ttu-id="e25fa-199">Namespaces und Typen, die ohne einschließenden Namespace verfügen, sind Sie Mitglied der ***globalen Namespace***.</span><span class="sxs-lookup"><span data-stu-id="e25fa-199">Namespaces and types that have no enclosing namespace are members of the ***global namespace***.</span></span> <span data-ttu-id="e25fa-200">Dies entspricht direkt den Namen, die im Bereich globale Deklaration deklariert.</span><span class="sxs-lookup"><span data-stu-id="e25fa-200">This corresponds directly to the names declared in the global declaration space.</span></span>

<span data-ttu-id="e25fa-201">Namespaces und Typen, die innerhalb eines Namespace deklariert sind Member dieses Namespace.</span><span class="sxs-lookup"><span data-stu-id="e25fa-201">Namespaces and types declared within a namespace are members of that namespace.</span></span> <span data-ttu-id="e25fa-202">Dies entspricht direkt den Namen, die im Deklarationsbereich des Namespaces deklariert.</span><span class="sxs-lookup"><span data-stu-id="e25fa-202">This corresponds directly to the names declared in the declaration space of the namespace.</span></span>

<span data-ttu-id="e25fa-203">Namespaces haben uneingeschränkten Zugriff.</span><span class="sxs-lookup"><span data-stu-id="e25fa-203">Namespaces have no access restrictions.</span></span> <span data-ttu-id="e25fa-204">Es ist nicht möglich, privat, geschützt oder intern Namespaces zu deklarieren und Namespace-Namen sind immer öffentlich zugegriffen werden kann.</span><span class="sxs-lookup"><span data-stu-id="e25fa-204">It is not possible to declare private, protected, or internal namespaces, and namespace names are always publicly accessible.</span></span>

### <a name="struct-members"></a><span data-ttu-id="e25fa-205">Strukturmember</span><span class="sxs-lookup"><span data-stu-id="e25fa-205">Struct members</span></span>

<span data-ttu-id="e25fa-206">Die Member einer Struktur werden die Elemente, die in der Struktur deklariert und die von der Struktur der direkten Basisklasse geerbten Member `System.ValueType` und indirekte Basisklasse `object`.</span><span class="sxs-lookup"><span data-stu-id="e25fa-206">The members of a struct are the members declared in the struct and the members inherited from the struct's direct base class `System.ValueType` and the indirect base class `object`.</span></span>

<span data-ttu-id="e25fa-207">Die Elemente eines einfachen Typs entsprechen direkt auf die Member der Struktur Typ mit einem Alias versehen vom einfachen Typ auf:</span><span class="sxs-lookup"><span data-stu-id="e25fa-207">The members of a simple type correspond directly to the members of the struct type aliased by the simple type:</span></span>

*  <span data-ttu-id="e25fa-208">Die Elemente der `sbyte` sind die Mitglieder der `System.SByte` Struktur.</span><span class="sxs-lookup"><span data-stu-id="e25fa-208">The members of `sbyte` are the members of the `System.SByte` struct.</span></span>
*  <span data-ttu-id="e25fa-209">Die Elemente der `byte` sind die Mitglieder der `System.Byte` Struktur.</span><span class="sxs-lookup"><span data-stu-id="e25fa-209">The members of `byte` are the members of the `System.Byte` struct.</span></span>
*  <span data-ttu-id="e25fa-210">Die Elemente der `short` sind die Mitglieder der `System.Int16` Struktur.</span><span class="sxs-lookup"><span data-stu-id="e25fa-210">The members of `short` are the members of the `System.Int16` struct.</span></span>
*  <span data-ttu-id="e25fa-211">Die Elemente der `ushort` sind die Mitglieder der `System.UInt16` Struktur.</span><span class="sxs-lookup"><span data-stu-id="e25fa-211">The members of `ushort` are the members of the `System.UInt16` struct.</span></span>
*  <span data-ttu-id="e25fa-212">Die Elemente der `int` sind die Mitglieder der `System.Int32` Struktur.</span><span class="sxs-lookup"><span data-stu-id="e25fa-212">The members of `int` are the members of the `System.Int32` struct.</span></span>
*  <span data-ttu-id="e25fa-213">Die Elemente der `uint` sind die Mitglieder der `System.UInt32` Struktur.</span><span class="sxs-lookup"><span data-stu-id="e25fa-213">The members of `uint` are the members of the `System.UInt32` struct.</span></span>
*  <span data-ttu-id="e25fa-214">Die Elemente der `long` sind die Mitglieder der `System.Int64` Struktur.</span><span class="sxs-lookup"><span data-stu-id="e25fa-214">The members of `long` are the members of the `System.Int64` struct.</span></span>
*  <span data-ttu-id="e25fa-215">Die Elemente der `ulong` sind die Mitglieder der `System.UInt64` Struktur.</span><span class="sxs-lookup"><span data-stu-id="e25fa-215">The members of `ulong` are the members of the `System.UInt64` struct.</span></span>
*  <span data-ttu-id="e25fa-216">Die Elemente der `char` sind die Mitglieder der `System.Char` Struktur.</span><span class="sxs-lookup"><span data-stu-id="e25fa-216">The members of `char` are the members of the `System.Char` struct.</span></span>
*  <span data-ttu-id="e25fa-217">Die Elemente der `float` sind die Mitglieder der `System.Single` Struktur.</span><span class="sxs-lookup"><span data-stu-id="e25fa-217">The members of `float` are the members of the `System.Single` struct.</span></span>
*  <span data-ttu-id="e25fa-218">Die Elemente der `double` sind die Mitglieder der `System.Double` Struktur.</span><span class="sxs-lookup"><span data-stu-id="e25fa-218">The members of `double` are the members of the `System.Double` struct.</span></span>
*  <span data-ttu-id="e25fa-219">Die Elemente der `decimal` sind die Mitglieder der `System.Decimal` Struktur.</span><span class="sxs-lookup"><span data-stu-id="e25fa-219">The members of `decimal` are the members of the `System.Decimal` struct.</span></span>
*  <span data-ttu-id="e25fa-220">Die Elemente der `bool` sind die Mitglieder der `System.Boolean` Struktur.</span><span class="sxs-lookup"><span data-stu-id="e25fa-220">The members of `bool` are the members of the `System.Boolean` struct.</span></span>

### <a name="enumeration-members"></a><span data-ttu-id="e25fa-221">Enumerationsmember</span><span class="sxs-lookup"><span data-stu-id="e25fa-221">Enumeration members</span></span>

<span data-ttu-id="e25fa-222">Die Member einer Enumeration sind die Konstanten, die in der Enumeration und die von der Enumeration direkte Basisklasse geerbten Member `System.Enum` und der indirekten Basisklassen `System.ValueType` und `object`.</span><span class="sxs-lookup"><span data-stu-id="e25fa-222">The members of an enumeration are the constants declared in the enumeration and the members inherited from the enumeration's direct base class `System.Enum` and the indirect base classes `System.ValueType` and `object`.</span></span>

### <a name="class-members"></a><span data-ttu-id="e25fa-223">Klassenmember</span><span class="sxs-lookup"><span data-stu-id="e25fa-223">Class members</span></span>

<span data-ttu-id="e25fa-224">Die Member einer Klasse sind Member, die in der Klasse deklariert und die von der Basisklasse geerbten Member (mit Ausnahme der Klasse `object` der hat keine Basisklasse).</span><span class="sxs-lookup"><span data-stu-id="e25fa-224">The members of a class are the members declared in the class and the members inherited from the base class (except for class `object` which has no base class).</span></span> <span data-ttu-id="e25fa-225">Die von der Basisklasse geerbten Member enthalten, die Konstanten, Felder, Methoden, Eigenschaften, Ereignisse, Indexer, Operatoren und Typen von der Basisklasse, jedoch nicht die Instanzkonstruktoren, Destruktoren und statische Konstruktoren der Basisklasse.</span><span class="sxs-lookup"><span data-stu-id="e25fa-225">The members inherited from the base class include the constants, fields, methods, properties, events, indexers, operators, and types of the base class, but not the instance constructors, destructors and static constructors of the base class.</span></span> <span data-ttu-id="e25fa-226">Unabhängig von ihrem Zugriff werden die Member der Basisklasse geerbt.</span><span class="sxs-lookup"><span data-stu-id="e25fa-226">Base class members are inherited without regard to their accessibility.</span></span>

<span data-ttu-id="e25fa-227">Eine Klassendeklaration kann Deklarationen von Konstanten, Felder, Methoden, Eigenschaften, Ereignisse, Indexer, Operatoren, Instanzkonstruktoren, Destruktoren, statische Konstruktoren und Typen enthalten.</span><span class="sxs-lookup"><span data-stu-id="e25fa-227">A class declaration may contain declarations of constants, fields, methods, properties, events, indexers, operators, instance constructors, destructors, static constructors and types.</span></span>

<span data-ttu-id="e25fa-228">Die Elemente der `object` und `string` entsprechen direkt der Member der Klassentypen sie alias:</span><span class="sxs-lookup"><span data-stu-id="e25fa-228">The members of `object` and `string` correspond directly to the members of the class types they alias:</span></span>

*  <span data-ttu-id="e25fa-229">Die Elemente der `object` sind die Mitglieder der `System.Object` Klasse.</span><span class="sxs-lookup"><span data-stu-id="e25fa-229">The members of `object` are the members of the `System.Object` class.</span></span>
*  <span data-ttu-id="e25fa-230">Die Elemente der `string` sind die Mitglieder der `System.String` Klasse.</span><span class="sxs-lookup"><span data-stu-id="e25fa-230">The members of `string` are the members of the `System.String` class.</span></span>

### <a name="interface-members"></a><span data-ttu-id="e25fa-231">Schnittstellenmember</span><span class="sxs-lookup"><span data-stu-id="e25fa-231">Interface members</span></span>

<span data-ttu-id="e25fa-232">Die Member einer Schnittstelle sind die Elemente in der Benutzeroberfläche und in der Schnittstelle alle Basisschnittstellen deklariert.</span><span class="sxs-lookup"><span data-stu-id="e25fa-232">The members of an interface are the members declared in the interface and in all base interfaces of the interface.</span></span> <span data-ttu-id="e25fa-233">Die Elemente in der Klasse `object` sind nicht streng genommen, Mitglied einer beliebigen Schnittstelle ([Schnittstellenmember](interfaces.md#interface-members)).</span><span class="sxs-lookup"><span data-stu-id="e25fa-233">The members in class `object` are not, strictly speaking, members of any interface ([Interface members](interfaces.md#interface-members)).</span></span> <span data-ttu-id="e25fa-234">Allerdings die Elemente in der Klasse `object` stehen über die Suche nach Membern in einen Schnittstellentyp ([Membersuche](expressions.md#member-lookup)).</span><span class="sxs-lookup"><span data-stu-id="e25fa-234">However, the members in class `object` are available via member lookup in any interface type ([Member lookup](expressions.md#member-lookup)).</span></span>

### <a name="array-members"></a><span data-ttu-id="e25fa-235">Array-Elemente</span><span class="sxs-lookup"><span data-stu-id="e25fa-235">Array members</span></span>

<span data-ttu-id="e25fa-236">Die Elemente eines Arrays sind die Elemente, die von der Klasse geerbt `System.Array`.</span><span class="sxs-lookup"><span data-stu-id="e25fa-236">The members of an array are the members inherited from class `System.Array`.</span></span>

### <a name="delegate-members"></a><span data-ttu-id="e25fa-237">Mitglieder von Delegaten</span><span class="sxs-lookup"><span data-stu-id="e25fa-237">Delegate members</span></span>

<span data-ttu-id="e25fa-238">Die Member eines Delegaten sind die Elemente, die von der Klasse geerbt `System.Delegate`.</span><span class="sxs-lookup"><span data-stu-id="e25fa-238">The members of a delegate are the members inherited from class `System.Delegate`.</span></span>

## <a name="member-access"></a><span data-ttu-id="e25fa-239">Memberzugriff</span><span class="sxs-lookup"><span data-stu-id="e25fa-239">Member access</span></span>

<span data-ttu-id="e25fa-240">Deklarationen von Elementen ermöglichen die Steuerung des Zugriffs für Member.</span><span class="sxs-lookup"><span data-stu-id="e25fa-240">Declarations of members allow control over member access.</span></span> <span data-ttu-id="e25fa-241">Der Zugriff auf ein Element wird hergestellt, indem die deklarierte Zugriffsart ([deklariert Barrierefreiheit](basic-concepts.md#declared-accessibility)) des Elements zusammen mit den Zugriff des direkt enthaltenden Typs, sofern vorhanden.</span><span class="sxs-lookup"><span data-stu-id="e25fa-241">The accessibility of a member is established by the declared accessibility ([Declared accessibility](basic-concepts.md#declared-accessibility)) of the member combined with the accessibility of the immediately containing type, if any.</span></span>

<span data-ttu-id="e25fa-242">Wenn Zugriff auf einen bestimmten Member zulässig ist, das Element wird als ***zugänglich***.</span><span class="sxs-lookup"><span data-stu-id="e25fa-242">When access to a particular member is allowed, the member is said to be ***accessible***.</span></span> <span data-ttu-id="e25fa-243">Im Gegensatz dazu beim Zugriff auf einen bestimmten Member nicht zulässig, der Member gilt als ***kann nicht zugegriffen werden***.</span><span class="sxs-lookup"><span data-stu-id="e25fa-243">Conversely, when access to a particular member is disallowed, the member is said to be ***inaccessible***.</span></span> <span data-ttu-id="e25fa-244">Zugriff auf einen Member ist zulässig, wenn die Textposition, in denen der Zugriff erfolgt, in der Zugriffsdomäne enthalten ist ([Barrierefreiheit Domänen](basic-concepts.md#accessibility-domains)) des Elements.</span><span class="sxs-lookup"><span data-stu-id="e25fa-244">Access to a member is permitted when the textual location in which the access takes place is included in the accessibility domain ([Accessibility domains](basic-concepts.md#accessibility-domains)) of the member.</span></span>

### <a name="declared-accessibility"></a><span data-ttu-id="e25fa-245">Deklarierter Zugriff</span><span class="sxs-lookup"><span data-stu-id="e25fa-245">Declared accessibility</span></span>

<span data-ttu-id="e25fa-246">Die ***deklariert Barrierefreiheit*** eines Elements kann einen der folgenden sein:</span><span class="sxs-lookup"><span data-stu-id="e25fa-246">The ***declared accessibility*** of a member can be one of the following:</span></span>

*  <span data-ttu-id="e25fa-247">Öffentlich, die dazu ausgewählt ist eine `public` Modifizierer in der Memberdeklaration.</span><span class="sxs-lookup"><span data-stu-id="e25fa-247">Public, which is selected by including a `public` modifier in the member declaration.</span></span> <span data-ttu-id="e25fa-248">Die intuitive Bedeutung von `public` ist "Zugriff nicht eingeschränkt".</span><span class="sxs-lookup"><span data-stu-id="e25fa-248">The intuitive meaning of `public` is "access not limited".</span></span>
*  <span data-ttu-id="e25fa-249">Geschützt, die dazu ausgewählt ist eine `protected` Modifizierer in der Memberdeklaration.</span><span class="sxs-lookup"><span data-stu-id="e25fa-249">Protected, which is selected by including a `protected` modifier in the member declaration.</span></span> <span data-ttu-id="e25fa-250">Die intuitive Bedeutung von `protected` "den Zugriff auf die enthaltende Klasse oder auf Typen beschränkt stammt von der enthaltenden Klasse".</span><span class="sxs-lookup"><span data-stu-id="e25fa-250">The intuitive meaning of `protected` is "access limited to the containing class or types derived from the containing class".</span></span>
*  <span data-ttu-id="e25fa-251">Intern fest, die dazu ausgewählt wird ein `internal` Modifizierer in der Memberdeklaration.</span><span class="sxs-lookup"><span data-stu-id="e25fa-251">Internal, which is selected by including an `internal` modifier in the member declaration.</span></span> <span data-ttu-id="e25fa-252">Die intuitive Bedeutung von `internal` "Zugriff auf dieses Programm beschränkt" ist.</span><span class="sxs-lookup"><span data-stu-id="e25fa-252">The intuitive meaning of `internal` is "access limited to this program".</span></span>
*  <span data-ttu-id="e25fa-253">Geschützte interne (das heißt geschützt oder intern), die ausgewählt ist, indem auch ein `protected` und ein `internal` Modifizierer in der Memberdeklaration.</span><span class="sxs-lookup"><span data-stu-id="e25fa-253">Protected internal (meaning protected or internal), which is selected by including both a `protected` and an `internal` modifier in the member declaration.</span></span> <span data-ttu-id="e25fa-254">Die intuitive Bedeutung von `protected internal` ist "den Zugriff auf dieses Programm beschränkt oder von der enthaltenden Klasse abgeleiteten Typen".</span><span class="sxs-lookup"><span data-stu-id="e25fa-254">The intuitive meaning of `protected internal` is "access limited to this program or types derived from the containing class".</span></span>
*  <span data-ttu-id="e25fa-255">Private, die dazu ausgewählt ist eine `private` Modifizierer in der Memberdeklaration.</span><span class="sxs-lookup"><span data-stu-id="e25fa-255">Private, which is selected by including a `private` modifier in the member declaration.</span></span> <span data-ttu-id="e25fa-256">Die intuitive Bedeutung von `private` ist "Zugriff auf den enthaltenden Typ eingeschränkt".</span><span class="sxs-lookup"><span data-stu-id="e25fa-256">The intuitive meaning of `private` is "access limited to the containing type".</span></span>

<span data-ttu-id="e25fa-257">Platzieren Sie je nach Kontext, in dem Deklaration eines Elements verwendet, nur bestimmte Arten von deklarierte Zugriffsart sind zulässig.</span><span class="sxs-lookup"><span data-stu-id="e25fa-257">Depending on the context in which a member declaration takes place, only certain types of declared accessibility are permitted.</span></span> <span data-ttu-id="e25fa-258">Darüber hinaus bei der Deklaration eines Elements keine Zugriffsmodifizierer enthalten ist, bestimmt der Kontext, in dem die Deklaration erfolgt, die Barrierefreiheit deklariert.</span><span class="sxs-lookup"><span data-stu-id="e25fa-258">Furthermore, when a member declaration does not include any access modifiers, the context in which the declaration takes place determines the default declared accessibility.</span></span>

*  <span data-ttu-id="e25fa-259">Namespaces verfügen implizit über `public` Barrierefreiheit deklariert.</span><span class="sxs-lookup"><span data-stu-id="e25fa-259">Namespaces implicitly have `public` declared accessibility.</span></span> <span data-ttu-id="e25fa-260">Keine Zugriffsmodifizierer sind für Namespace-Deklarationen zulässig.</span><span class="sxs-lookup"><span data-stu-id="e25fa-260">No access modifiers are allowed on namespace declarations.</span></span>
*  <span data-ttu-id="e25fa-261">Typen in Namespaces oder einer Kompilierungseinheiten deklariert haben `public` oder `internal` deklariert, Barrierefreiheit und sind standardmäßig `internal` Barrierefreiheit deklariert.</span><span class="sxs-lookup"><span data-stu-id="e25fa-261">Types declared in compilation units or namespaces can have `public` or `internal` declared accessibility and default to `internal` declared accessibility.</span></span>
*  <span data-ttu-id="e25fa-262">Klassenmember können mindestens einer der fünf Arten von deklarierte Zugriffsart und standardmäßig `private` Barrierefreiheit deklariert.</span><span class="sxs-lookup"><span data-stu-id="e25fa-262">Class members can have any of the five kinds of declared accessibility and default to `private` declared accessibility.</span></span> <span data-ttu-id="e25fa-263">(Beachten Sie, dass ein Typ deklariert, wie ein Member einer Klasse, die eines der fünf Arten von deklarierte Zugriffsart verfügen kann, während ein Typ deklarierter ein Member eines Namespaces kann nur über verfügen `public` oder `internal` Barrierefreiheit deklariert.)</span><span class="sxs-lookup"><span data-stu-id="e25fa-263">(Note that a type declared as a member of a class can have any of the five kinds of declared accessibility, whereas a type declared as a member of a namespace can have only `public` or `internal` declared accessibility.)</span></span>
*  <span data-ttu-id="e25fa-264">Strukturmember können haben `public`, `internal`, oder `private` deklariert, Barrierefreiheit und sind standardmäßig `private` Barrierefreiheit deklariert, da Strukturen implizit versiegelt sind.</span><span class="sxs-lookup"><span data-stu-id="e25fa-264">Struct members can have `public`, `internal`, or `private` declared accessibility and default to `private` declared accessibility because structs are implicitly sealed.</span></span> <span data-ttu-id="e25fa-265">Strukturmember in einer Struktur (die durch diese Struktur nicht vererbt wird) eingeführt wurden keine `protected` oder `protected internal` Barrierefreiheit deklariert.</span><span class="sxs-lookup"><span data-stu-id="e25fa-265">Struct members introduced in a struct (that is, not inherited by that struct) cannot have `protected` or `protected internal` declared accessibility.</span></span> <span data-ttu-id="e25fa-266">(Beachten Sie, dass ein Typ deklariert, wie ein Member einer Struktur kann `public`, `internal`, oder `private` Barrierefreiheit, deklariert, während ein Typ deklarierter ein Member eines Namespaces kann nur über verfügen `public` oder `internal` Barrierefreiheit deklariert.)</span><span class="sxs-lookup"><span data-stu-id="e25fa-266">(Note that a type declared as a member of a struct can have `public`, `internal`, or `private` declared accessibility, whereas a type declared as a member of a namespace can have only `public` or `internal` declared accessibility.)</span></span>
*  <span data-ttu-id="e25fa-267">Schnittstellenmember verfügen implizit über `public` Barrierefreiheit deklariert.</span><span class="sxs-lookup"><span data-stu-id="e25fa-267">Interface members implicitly have `public` declared accessibility.</span></span> <span data-ttu-id="e25fa-268">Auf Schnittstellenmember-Deklarationen sind keine Zugriffsmodifizierer zulässig.</span><span class="sxs-lookup"><span data-stu-id="e25fa-268">No access modifiers are allowed on interface member declarations.</span></span>
*  <span data-ttu-id="e25fa-269">Enumerationsmember verfügen implizit über `public` Barrierefreiheit deklariert.</span><span class="sxs-lookup"><span data-stu-id="e25fa-269">Enumeration members implicitly have `public` declared accessibility.</span></span> <span data-ttu-id="e25fa-270">Deklaration von Enumerationsmembern sind keine Zugriffsmodifizierer zulässig.</span><span class="sxs-lookup"><span data-stu-id="e25fa-270">No access modifiers are allowed on enumeration member declarations.</span></span>

### <a name="accessibility-domains"></a><span data-ttu-id="e25fa-271">Barrierefreiheit-Domänen</span><span class="sxs-lookup"><span data-stu-id="e25fa-271">Accessibility domains</span></span>

<span data-ttu-id="e25fa-272">Die ***Zugriffsdomäne*** eines Elements enthält (die möglicherweise nicht zusammenhängende) Abschnitte des Programmtexts, in dem Zugriff auf das Element ist zulässig.</span><span class="sxs-lookup"><span data-stu-id="e25fa-272">The ***accessibility domain*** of a member consists of the (possibly disjoint) sections of program text in which access to the member is permitted.</span></span> <span data-ttu-id="e25fa-273">Rahmen, die Zugriffsdomäne eines Members zu definieren, ein Member gilt als ***auf oberster Ebene*** wenn er nicht innerhalb eines Typs deklariert ist, und ein Member gilt als ***geschachtelte*** wenn er in einem anderen Typ deklariert wird.</span><span class="sxs-lookup"><span data-stu-id="e25fa-273">For purposes of defining the accessibility domain of a member, a member is said to be ***top-level*** if it is not declared within a type, and a member is said to be ***nested*** if it is declared within another type.</span></span> <span data-ttu-id="e25fa-274">Darüber hinaus die ***Programm Text*** eines Programms ist wie alle Text des Programms alle Quelldateien im Programm und der Programmtext von einem Typ definiert ist, wie alle Text im Programm definiert die *Type_declaration*s dieses Typs (einschließlich, möglicherweise Typen, die innerhalb des Typs geschachtelt sind).</span><span class="sxs-lookup"><span data-stu-id="e25fa-274">Furthermore, the ***program text*** of a program is defined as all program text contained in all source files of the program, and the program text of a type is defined as all program text contained in the *type_declaration*s of that type (including, possibly, types that are nested within the type).</span></span>

<span data-ttu-id="e25fa-275">Die Zugriffsdomäne eines vordefinierten Typs (z. B. `object`, `int`, oder `double`) gibt es keine Einschränkungen.</span><span class="sxs-lookup"><span data-stu-id="e25fa-275">The accessibility domain of a predefined type (such as `object`, `int`, or `double`) is unlimited.</span></span>

<span data-ttu-id="e25fa-276">Die Zugriffsdomäne von oberster Ebene von nicht gebundenen Typ `T` ([gebunden und Typen von nicht gebundenen](types.md#bound-and-unbound-types)) in einem Programm deklariert wird `P` ist wie folgt definiert:</span><span class="sxs-lookup"><span data-stu-id="e25fa-276">The accessibility domain of a top-level unbound type `T` ([Bound and unbound types](types.md#bound-and-unbound-types)) that is declared in a program `P` is defined as follows:</span></span>

*  <span data-ttu-id="e25fa-277">Wenn die deklarierte Zugriffsart von `T` ist `public`, die Zugriffsdomäne von `T` ist der Programmtext von `P` und jedes Programm, das Verweise `P`.</span><span class="sxs-lookup"><span data-stu-id="e25fa-277">If the declared accessibility of `T` is `public`, the accessibility domain of `T` is the program text of `P` and any program that references `P`.</span></span>
*  <span data-ttu-id="e25fa-278">Wenn die deklarierte Zugriffsart von `T` den Wert `internal` hat, entspricht die Zugriffsdomäne von `T` dem Programmtext von `P`.</span><span class="sxs-lookup"><span data-stu-id="e25fa-278">If the declared accessibility of `T` is `internal`, the accessibility domain of `T` is the program text of `P`.</span></span>

<span data-ttu-id="e25fa-279">Aus diesen Definitionen folgt, dass die Zugriffsdomäne eines Typs der obersten Ebene nicht gebundenen immer mindestens der Programmtext des Programms in der eingeben, die deklariert wird.</span><span class="sxs-lookup"><span data-stu-id="e25fa-279">From these definitions it follows that the accessibility domain of a top-level unbound type is always at least the program text of the program in which that type is declared.</span></span>

<span data-ttu-id="e25fa-280">Die Zugriffsdomäne eines konstruierten Typs `T<A1, ..., An>` der Schnittmenge zwischen der Zugriffsdomäne des ungebundenen generischen Typs `T` und den auf Zugriffsdomänen der Typargumente `A1, ..., An`.</span><span class="sxs-lookup"><span data-stu-id="e25fa-280">The accessibility domain for a constructed type `T<A1, ..., An>` is the intersection of the accessibility domain of the unbound generic type `T` and the accessibility domains of the type arguments `A1, ..., An`.</span></span>

<span data-ttu-id="e25fa-281">Die Zugriffsdomäne eines geschachtelten Members `M` in einem Typ deklariert `T` innerhalb eines Programms `P` ist wie folgt definiert (wobei `M` selbst ein Typ sein kann):</span><span class="sxs-lookup"><span data-stu-id="e25fa-281">The accessibility domain of a nested member `M` declared in a type `T` within a program `P` is defined as follows (noting that `M` itself may possibly be a type):</span></span>

*  <span data-ttu-id="e25fa-282">Wenn die deklarierte Zugriffsart von `M` den Wert `public` hat, entspricht die Zugriffsdomäne von `M` der von `T`.</span><span class="sxs-lookup"><span data-stu-id="e25fa-282">If the declared accessibility of `M` is `public`, the accessibility domain of `M` is the accessibility domain of `T`.</span></span>
*  <span data-ttu-id="e25fa-283">Wenn die deklarierte Zugriffsart von `M` ist `protected internal`ermöglichen `D` werden die Vereinigung der Programmtext des `P` und der Programmtext jedes Typs abgeleitete `T`, der deklariert wird, außerhalb `P`.</span><span class="sxs-lookup"><span data-stu-id="e25fa-283">If the declared accessibility of `M` is `protected internal`, let `D` be the union of the program text of `P` and the program text of any type derived from `T`, which is declared outside `P`.</span></span> <span data-ttu-id="e25fa-284">Die Zugriffsdomäne von `M` der Schnittmenge zwischen der Zugriffsdomäne von `T` mit `D`.</span><span class="sxs-lookup"><span data-stu-id="e25fa-284">The accessibility domain of `M` is the intersection of the accessibility domain of `T` with `D`.</span></span>
*  <span data-ttu-id="e25fa-285">Wenn die deklarierte Zugriffsart von `M` ist `protected`ermöglichen `D` werden die Vereinigung der Programmtext des `T` und der Programmtext jedes Typs abgeleitete `T`.</span><span class="sxs-lookup"><span data-stu-id="e25fa-285">If the declared accessibility of `M` is `protected`, let `D` be the union of the program text of `T` and the program text of any type derived from `T`.</span></span> <span data-ttu-id="e25fa-286">Die Zugriffsdomäne von `M` der Schnittmenge zwischen der Zugriffsdomäne von `T` mit `D`.</span><span class="sxs-lookup"><span data-stu-id="e25fa-286">The accessibility domain of `M` is the intersection of the accessibility domain of `T` with `D`.</span></span>
*  <span data-ttu-id="e25fa-287">Wenn die deklarierte Zugriffsart von `M` den Wert `internal` hat, entspricht die Zugriffsdomäne von `M` der Schnittmenge zwischen der Zugriffsdomäne von `T` und dem Programmtext von `P`.</span><span class="sxs-lookup"><span data-stu-id="e25fa-287">If the declared accessibility of `M` is `internal`, the accessibility domain of `M` is the intersection of the accessibility domain of `T` with the program text of `P`.</span></span>
*  <span data-ttu-id="e25fa-288">Wenn die deklarierte Zugriffsart von `M` den Wert `private` hat, entspricht die Zugriffsdomäne von `M` dem Programmtext von `T`.</span><span class="sxs-lookup"><span data-stu-id="e25fa-288">If the declared accessibility of `M` is `private`, the accessibility domain of `M` is the program text of `T`.</span></span>

<span data-ttu-id="e25fa-289">Aus diesen Definitionen folgt, dass die Zugriffsdomäne eines geschachtelten Members immer mindestens der Programmtext des Typs in der das Element deklariert wird.</span><span class="sxs-lookup"><span data-stu-id="e25fa-289">From these definitions it follows that the accessibility domain of a nested member is always at least the program text of the type in which the member is declared.</span></span> <span data-ttu-id="e25fa-290">Darüber hinaus ergibt sich, dass es sich bei die Zugriffsdomäne eines Members nie mehr als die Zugriffsdomäne des Typs ist in der das Element deklariert wird.</span><span class="sxs-lookup"><span data-stu-id="e25fa-290">Furthermore, it follows that the accessibility domain of a member is never more inclusive than the accessibility domain of the type in which the member is declared.</span></span>

<span data-ttu-id="e25fa-291">Intuitiv ausgedrückt Wenn ein Typ oder Member `M` wird zugegriffen, die folgenden Schritte werden ausgewertet, um sicherzustellen, dass der Zugriff zulässig ist:</span><span class="sxs-lookup"><span data-stu-id="e25fa-291">In intuitive terms, when a type or member `M` is accessed, the following steps are evaluated to ensure that the access is permitted:</span></span>

*  <span data-ttu-id="e25fa-292">Wenn zunächst `M` ist innerhalb eines Typs deklariert (im Unterschied zu einer Kompilierungseinheit oder einen Namespace), ein Fehler während der Kompilierung tritt auf, wenn dieses Typs nicht zugänglich ist.</span><span class="sxs-lookup"><span data-stu-id="e25fa-292">First, if `M` is declared within a type (as opposed to a compilation unit or a namespace), a compile-time error occurs if that type is not accessible.</span></span>
*  <span data-ttu-id="e25fa-293">Wenn danach `M` ist `public`, der Zugriff zulässig ist.</span><span class="sxs-lookup"><span data-stu-id="e25fa-293">Then, if `M` is `public`, the access is permitted.</span></span>
*  <span data-ttu-id="e25fa-294">Andernfalls gilt: Wenn `M` ist `protected internal`, der Zugriff zulässig ist, tritt innerhalb des Programms in der `M` deklariert ist, oder wenn er innerhalb einer Klasse erfolgt, abgeleitete Klasse, in der `M` wird deklariert und erfolgt über die abgeleitete Klassentyp ([z. B. den Zugriff auf Member für geschützte](basic-concepts.md#protected-access-for-instance-members)).</span><span class="sxs-lookup"><span data-stu-id="e25fa-294">Otherwise, if `M` is `protected internal`, the access is permitted if it occurs within the program in which `M` is declared, or if it occurs within a class derived from the class in which `M` is declared and takes place through the derived class type ([Protected access for instance members](basic-concepts.md#protected-access-for-instance-members)).</span></span>
*  <span data-ttu-id="e25fa-295">Andernfalls gilt: Wenn `M` ist `protected`, der Zugriff zulässig ist, tritt in der Klasse in der `M` deklariert ist, oder wenn er innerhalb einer Klasse erfolgt, abgeleitete Klasse, in der `M` wird deklariert und erfolgt über die abgeleitete Klassentyp ([z. B. den Zugriff auf Member für geschützte](basic-concepts.md#protected-access-for-instance-members)).</span><span class="sxs-lookup"><span data-stu-id="e25fa-295">Otherwise, if `M` is `protected`, the access is permitted if it occurs within the class in which `M` is declared, or if it occurs within a class derived from the class in which `M` is declared and takes place through the derived class type ([Protected access for instance members](basic-concepts.md#protected-access-for-instance-members)).</span></span>
*  <span data-ttu-id="e25fa-296">Andernfalls gilt: Wenn `M` ist `internal`, der Zugriff zulässig ist, tritt innerhalb des Programms in der `M` deklariert wird.</span><span class="sxs-lookup"><span data-stu-id="e25fa-296">Otherwise, if `M` is `internal`, the access is permitted if it occurs within the program in which `M` is declared.</span></span>
*  <span data-ttu-id="e25fa-297">Andernfalls gilt: Wenn `M` ist `private`, der Zugriff zulässig ist, tritt innerhalb des Typs in der `M` deklariert wird.</span><span class="sxs-lookup"><span data-stu-id="e25fa-297">Otherwise, if `M` is `private`, the access is permitted if it occurs within the type in which `M` is declared.</span></span>
*  <span data-ttu-id="e25fa-298">Hingegen den Typ oder Member kann nicht zugegriffen werden, und ein Fehler während der Kompilierung auftritt.</span><span class="sxs-lookup"><span data-stu-id="e25fa-298">Otherwise, the type or member is inaccessible, and a compile-time error occurs.</span></span>

<span data-ttu-id="e25fa-299">Im Beispiel</span><span class="sxs-lookup"><span data-stu-id="e25fa-299">In the example</span></span>
```csharp
public class A
{
    public static int X;
    internal static int Y;
    private static int Z;
}

internal class B
{
    public static int X;
    internal static int Y;
    private static int Z;

    public class C
    {
        public static int X;
        internal static int Y;
        private static int Z;
    }

    private class D
    {
        public static int X;
        internal static int Y;
        private static int Z;
    }
}
```
<span data-ttu-id="e25fa-300">die Klassen und Member haben die folgenden Eingabehilfen-Domänen:</span><span class="sxs-lookup"><span data-stu-id="e25fa-300">the classes and members have the following accessibility domains:</span></span>

*  <span data-ttu-id="e25fa-301">Die Zugriffsdomäne von `A` und `A.X` ist unbegrenzt.</span><span class="sxs-lookup"><span data-stu-id="e25fa-301">The accessibility domain of `A` and `A.X` is unlimited.</span></span>
*  <span data-ttu-id="e25fa-302">Die Zugriffsdomäne von `A.Y`, `B`, `B.X`, `B.Y`, `B.C`, `B.C.X`, und `B.C.Y` ist der Programmtext des Programms enthält.</span><span class="sxs-lookup"><span data-stu-id="e25fa-302">The accessibility domain of `A.Y`, `B`, `B.X`, `B.Y`, `B.C`, `B.C.X`, and `B.C.Y` is the program text of the containing program.</span></span>
*  <span data-ttu-id="e25fa-303">Die Zugriffsdomäne von `A.Z` ist der Programmtext von `A`.</span><span class="sxs-lookup"><span data-stu-id="e25fa-303">The accessibility domain of `A.Z` is the program text of `A`.</span></span>
*  <span data-ttu-id="e25fa-304">Die Zugriffsdomäne von `B.Z` und `B.D` ist der Programmtext von `B`, einschließlich den Programmtext von `B.C` und `B.D`.</span><span class="sxs-lookup"><span data-stu-id="e25fa-304">The accessibility domain of `B.Z` and `B.D` is the program text of `B`, including the program text of `B.C` and `B.D`.</span></span>
*  <span data-ttu-id="e25fa-305">Die Zugriffsdomäne von `B.C.Z` ist der Programmtext von `B.C`.</span><span class="sxs-lookup"><span data-stu-id="e25fa-305">The accessibility domain of `B.C.Z` is the program text of `B.C`.</span></span>
*  <span data-ttu-id="e25fa-306">Die Zugriffsdomäne von `B.D.X` und `B.D.Y` ist der Programmtext von `B`, einschließlich den Programmtext von `B.C` und `B.D`.</span><span class="sxs-lookup"><span data-stu-id="e25fa-306">The accessibility domain of `B.D.X` and `B.D.Y` is the program text of `B`, including the program text of `B.C` and `B.D`.</span></span>
*  <span data-ttu-id="e25fa-307">Die Zugriffsdomäne von `B.D.Z` ist der Programmtext von `B.D`.</span><span class="sxs-lookup"><span data-stu-id="e25fa-307">The accessibility domain of `B.D.Z` is the program text of `B.D`.</span></span>

<span data-ttu-id="e25fa-308">Wie im Beispiel wird veranschaulicht, ist die Zugriffsdomäne eines Members nie größer als die des enthaltenden Typs.</span><span class="sxs-lookup"><span data-stu-id="e25fa-308">As the example illustrates, the accessibility domain of a member is never larger than that of a containing type.</span></span> <span data-ttu-id="e25fa-309">Beispielsweise, obwohl alle `X` Mitglieder haben Zugriff public deklariert, gut `A.X` haben Sie auf Zugriffsdomänen, die von einem enthaltenden Typ eingeschränkt werden.</span><span class="sxs-lookup"><span data-stu-id="e25fa-309">For example, even though all `X` members have public declared accessibility, all but `A.X` have accessibility domains that are constrained by a containing type.</span></span>

<span data-ttu-id="e25fa-310">Siehe [Mitglieder](basic-concepts.md#members), alle Member einer Basisklasse, mit Ausnahme von z. B. Konstruktoren, Destruktoren und statische Konstruktoren von abgeleiteten Typen vererbt werden.</span><span class="sxs-lookup"><span data-stu-id="e25fa-310">As described in [Members](basic-concepts.md#members), all members of a base class, except for instance constructors, destructors and static constructors, are inherited by derived types.</span></span> <span data-ttu-id="e25fa-311">Dies schließt auch Private Member einer Basisklasse.</span><span class="sxs-lookup"><span data-stu-id="e25fa-311">This includes even private members of a base class.</span></span> <span data-ttu-id="e25fa-312">Die Zugriffsdomäne eines privaten Members enthält jedoch nur der Programmtext des Typs in der das Element deklariert wird.</span><span class="sxs-lookup"><span data-stu-id="e25fa-312">However, the accessibility domain of a private member includes only the program text of the type in which the member is declared.</span></span> <span data-ttu-id="e25fa-313">Im Beispiel</span><span class="sxs-lookup"><span data-stu-id="e25fa-313">In the example</span></span>
```csharp
class A
{
    int x;

    static void F(B b) {
        b.x = 1;        // Ok
    }
}

class B: A
{
    static void F(B b) {
        b.x = 1;        // Error, x not accessible
    }
}
```
<span data-ttu-id="e25fa-314">die `B` -Klasse erbt die privaten Member `x` aus der `A` Klasse.</span><span class="sxs-lookup"><span data-stu-id="e25fa-314">the `B` class inherits the private member `x` from the `A` class.</span></span> <span data-ttu-id="e25fa-315">Da der Member privat ist, ist es nur zugegriffen werden kann die *Class_body* von `A`.</span><span class="sxs-lookup"><span data-stu-id="e25fa-315">Because the member is private, it is only accessible within the *class_body* of `A`.</span></span> <span data-ttu-id="e25fa-316">Daher den Zugriff auf `b.x` erfolgreich die `A.F` -Methode, aber nicht erfolgreich. die `B.F` Methode.</span><span class="sxs-lookup"><span data-stu-id="e25fa-316">Thus, the access to `b.x` succeeds in the `A.F` method, but fails in the `B.F` method.</span></span>

### <a name="protected-access-for-instance-members"></a><span data-ttu-id="e25fa-317">Geschützter Zugriff auf Instanzmember</span><span class="sxs-lookup"><span data-stu-id="e25fa-317">Protected access for instance members</span></span>

<span data-ttu-id="e25fa-318">Bei der ein `protected` Instanzmember erfolgt außerhalb von dem Programmtext von der Klasse, in dem sie deklariert ist, und wann eine `protected internal` Instanzmember erfolgt außerhalb der Programmtext des Programms in der sie deklariert ist, der Zugriff erfolgen muss innerhalb einer Deklaration der Klasse, die von der Klasse abgeleitet ist, in dem sie deklariert ist.</span><span class="sxs-lookup"><span data-stu-id="e25fa-318">When a `protected` instance member is accessed outside the program text of the class in which it is declared, and when a `protected internal` instance member is accessed outside the program text of the program in which it is declared, the access must take place within a class declaration that derives from the class in which it is declared.</span></span> <span data-ttu-id="e25fa-319">Darüber hinaus muss der Zugriff durch eine Instanz der abgeleiteten Typ oder ein Klassentyp, der daraus erstellte stattfinden.</span><span class="sxs-lookup"><span data-stu-id="e25fa-319">Furthermore, the access is required to take place through an instance of that derived class type or a class type constructed from it.</span></span> <span data-ttu-id="e25fa-320">Diese Einschränkung wird verhindert, dass eine abgeleitete Klasse den Zugriff auf geschützte Member der andere abgeleiteten Klassen, selbst wenn die Elemente, die von derselben Basisklasse geerbt werden.</span><span class="sxs-lookup"><span data-stu-id="e25fa-320">This restriction prevents one derived class from accessing protected members of other derived classes, even when the members are inherited from the same base class.</span></span>

<span data-ttu-id="e25fa-321">Lassen Sie `B` eine Basisklasse, die eine geschützte Instanzmember deklariert sein `M`, und lassen Sie `D` werden eine abgeleitete Klasse `B`.</span><span class="sxs-lookup"><span data-stu-id="e25fa-321">Let `B` be a base class that declares a protected instance member `M`, and let `D` be a class that derives from `B`.</span></span> <span data-ttu-id="e25fa-322">In der *Class_body* von `D`, den Zugriff auf `M` kann einen der folgenden Formen annehmen:</span><span class="sxs-lookup"><span data-stu-id="e25fa-322">Within the *class_body* of `D`, access to `M` can take one of the following forms:</span></span>

*  <span data-ttu-id="e25fa-323">Einen nicht qualifizierten *Type_name* oder *Primary_expression* des Formulars `M`.</span><span class="sxs-lookup"><span data-stu-id="e25fa-323">An unqualified *type_name* or *primary_expression* of the form `M`.</span></span>
*  <span data-ttu-id="e25fa-324">Ein *Primary_expression* des Formulars `E.M`, den Typ des bereitgestellten `E` ist `T` oder eine abgeleitete Klasse `T`, wobei `T` ist der Klassentyp `D`, oder ein Klassentyp erstellt von `D`</span><span class="sxs-lookup"><span data-stu-id="e25fa-324">A *primary_expression* of the form `E.M`, provided the type of `E` is `T` or a class derived from `T`, where `T` is the class type `D`, or a class type constructed from `D`</span></span>
*  <span data-ttu-id="e25fa-325">Ein *Primary_expression* des Formulars `base.M`.</span><span class="sxs-lookup"><span data-stu-id="e25fa-325">A *primary_expression* of the form `base.M`.</span></span>

<span data-ttu-id="e25fa-326">Zusätzlich zu diese Formen des Zugriffs, kann eine abgeleitete Klasse zugreifen, einen geschützte Instanzenkonstruktor einer Basisklasse in eine *Constructor_initializer* ([Konstruktorinitialisierer](classes.md#constructor-initializers)).</span><span class="sxs-lookup"><span data-stu-id="e25fa-326">In addition to these forms of access, a derived class can access a protected instance constructor of a base class in a *constructor_initializer* ([Constructor initializers](classes.md#constructor-initializers)).</span></span>

<span data-ttu-id="e25fa-327">Im Beispiel</span><span class="sxs-lookup"><span data-stu-id="e25fa-327">In the example</span></span>
```csharp
public class A
{
    protected int x;

    static void F(A a, B b) {
        a.x = 1;        // Ok
        b.x = 1;        // Ok
    }
}

public class B: A
{
    static void F(A a, B b) {
        a.x = 1;        // Error, must access through instance of B
        b.x = 1;        // Ok
    }
}
```
<span data-ttu-id="e25fa-328">in `A`, es ist möglich, für den Zugriff auf `x` durch Instanzen der `A` und `B`, da in beiden Fällen der Zugriff durch eine Instanz der stattfindet `A` oder eine abgeleitete Klasse `A`.</span><span class="sxs-lookup"><span data-stu-id="e25fa-328">within `A`, it is possible to access `x` through instances of both `A` and `B`, since in either case the access takes place through an instance of `A` or a class derived from `A`.</span></span> <span data-ttu-id="e25fa-329">Allerdings in `B`, es ist nicht möglich, den Zugriff auf `x` durch eine Instanz der `A`, da `A` nicht von abgeleitet `B`.</span><span class="sxs-lookup"><span data-stu-id="e25fa-329">However, within `B`, it is not possible to access `x` through an instance of `A`, since `A` does not derive from `B`.</span></span>

<span data-ttu-id="e25fa-330">Im Beispiel</span><span class="sxs-lookup"><span data-stu-id="e25fa-330">In the example</span></span>
```csharp
class C<T>
{
    protected T x;
}

class D<T>: C<T>
{
    static void F() {
        D<T> dt = new D<T>();
        D<int> di = new D<int>();
        D<string> ds = new D<string>();
        dt.x = default(T);
        di.x = 123;
        ds.x = "test";
    }
}
```
<span data-ttu-id="e25fa-331">die drei Zuweisungen zu `x` sind zulässig, da sie alle über Instanzen von Klassentypen, die über den generischen Typ erstellt erfolgen.</span><span class="sxs-lookup"><span data-stu-id="e25fa-331">the three assignments to `x` are permitted because they all take place through instances of class types constructed from the generic type.</span></span>

### <a name="accessibility-constraints"></a><span data-ttu-id="e25fa-332">Barrierefreiheit-Einschränkungen</span><span class="sxs-lookup"><span data-stu-id="e25fa-332">Accessibility constraints</span></span>

<span data-ttu-id="e25fa-333">Verschiedene Konstrukte in C# müssen einen Typ ist ***mindestens dieselben zugriffsmöglichkeiten wie*** ein Element oder einen anderen Typ.</span><span class="sxs-lookup"><span data-stu-id="e25fa-333">Several constructs in the C# language require a type to be ***at least as accessible as*** a member or another type.</span></span> <span data-ttu-id="e25fa-334">Ein Typ `T` gilt mindestens dieselben zugriffsmöglichkeiten wie ein Member oder Typ `M` Wenn die Zugriffsdomäne von `T` ist eine Obermenge der Zugriffsdomäne von `M`.</span><span class="sxs-lookup"><span data-stu-id="e25fa-334">A type `T` is said to be at least as accessible as a member or type `M` if the accessibility domain of `T` is a superset of the accessibility domain of `M`.</span></span> <span data-ttu-id="e25fa-335">Das heißt, `T` ist mindestens dieselben zugriffsmöglichkeiten wie `M` Wenn `T` zugegriffen werden in allen Kontexten, in dem `M` zugegriffen werden kann.</span><span class="sxs-lookup"><span data-stu-id="e25fa-335">In other words, `T` is at least as accessible as `M` if `T` is accessible in all contexts in which `M` is accessible.</span></span>

<span data-ttu-id="e25fa-336">Die folgenden Einschränkungen für die Barrierefreiheit vorhanden sein:</span><span class="sxs-lookup"><span data-stu-id="e25fa-336">The following accessibility constraints exist:</span></span>

*  <span data-ttu-id="e25fa-337">Die direkte Basisklasse eines Klassentyps muss mindesten dieselben Zugriffsmöglichkeiten wie der Klassentyp selbst bieten.</span><span class="sxs-lookup"><span data-stu-id="e25fa-337">The direct base class of a class type must be at least as accessible as the class type itself.</span></span>
*  <span data-ttu-id="e25fa-338">Die explizite Basisschnittstelle eines Schnittstellentyps muss mindesten dieselben Zugriffsmöglichkeiten bieten wie der Schnittstellentyp selbst.</span><span class="sxs-lookup"><span data-stu-id="e25fa-338">The explicit base interfaces of an interface type must be at least as accessible as the interface type itself.</span></span>
*  <span data-ttu-id="e25fa-339">Die Rückgabe- und Parametertypen eines Delegattyps müssen mindestens dieselben Zugriffsmöglichkeiten wie der Delegattyp selbst bieten.</span><span class="sxs-lookup"><span data-stu-id="e25fa-339">The return type and parameter types of a delegate type must be at least as accessible as the delegate type itself.</span></span>
*  <span data-ttu-id="e25fa-340">Der Typ einer Konstante muss mindestens dieselben Zugriffsmöglichkeiten wie die Konstante selbst bieten.</span><span class="sxs-lookup"><span data-stu-id="e25fa-340">The type of a constant must be at least as accessible as the constant itself.</span></span>
*  <span data-ttu-id="e25fa-341">Der Typ eines Felds muss mindestens dieselben Zugriffsmöglichkeiten bieten wie das Feld selbst.</span><span class="sxs-lookup"><span data-stu-id="e25fa-341">The type of a field must be at least as accessible as the field itself.</span></span>
*  <span data-ttu-id="e25fa-342">Die Rückgabe- und Parametertypen einer Methode müssen mindestens dieselben Zugriffsmöglichkeiten bieten wie die Methode selbst.</span><span class="sxs-lookup"><span data-stu-id="e25fa-342">The return type and parameter types of a method must be at least as accessible as the method itself.</span></span>
*  <span data-ttu-id="e25fa-343">Der Typ einer Eigenschaft muss mindestens dieselben Zugriffsmöglichkeiten bieten wie die Eigenschaft selbst.</span><span class="sxs-lookup"><span data-stu-id="e25fa-343">The type of a property must be at least as accessible as the property itself.</span></span>
*  <span data-ttu-id="e25fa-344">Der Typ eines Ereignisses muss mindestens dieselben Zugriffsmöglichkeiten bieten wie das Ereignis selbst.</span><span class="sxs-lookup"><span data-stu-id="e25fa-344">The type of an event must be at least as accessible as the event itself.</span></span>
*  <span data-ttu-id="e25fa-345">Der Typ und die Parametertypen eines Indexers müssen mindestens dieselben Zugriffsmöglichkeiten bieten wie der Indexer selbst.</span><span class="sxs-lookup"><span data-stu-id="e25fa-345">The type and parameter types of an indexer must be at least as accessible as the indexer itself.</span></span>
*  <span data-ttu-id="e25fa-346">Die Rückgabe- und Parametertypen eines Operators müssen mindestens dieselben Zugriffsmöglichkeiten bieten wie der Operator selbst.</span><span class="sxs-lookup"><span data-stu-id="e25fa-346">The return type and parameter types of an operator must be at least as accessible as the operator itself.</span></span>
*  <span data-ttu-id="e25fa-347">Die Parametertypen eines Instanzkonstruktors müssen mindestens dieselben zugriffsmöglichkeiten bieten wie der Instanzkonstruktor selbst sein.</span><span class="sxs-lookup"><span data-stu-id="e25fa-347">The parameter types of an instance constructor must be at least as accessible as the instance constructor itself.</span></span>

<span data-ttu-id="e25fa-348">Im Beispiel</span><span class="sxs-lookup"><span data-stu-id="e25fa-348">In the example</span></span>
```csharp
class A {...}

public class B: A {...}
```
<span data-ttu-id="e25fa-349">die `B` Klasse führt zu einem Fehler während der Kompilierung auf, da `A` ist nicht mindestens dieselben zugriffsmöglichkeiten wie `B`.</span><span class="sxs-lookup"><span data-stu-id="e25fa-349">the `B` class results in a compile-time error because `A` is not at least as accessible as `B`.</span></span>

<span data-ttu-id="e25fa-350">Ebenso im Beispiel</span><span class="sxs-lookup"><span data-stu-id="e25fa-350">Likewise, in the example</span></span>
```csharp
class A {...}

public class B
{
    A F() {...}

    internal A G() {...}

    public A H() {...}
}
```
<span data-ttu-id="e25fa-351">die `H` -Methode in der `B` führt zu einem Fehler während der Kompilierung, weil der Rückgabetyp `A` ist nicht mindestens dieselben zugriffsmöglichkeiten bieten wie die Methode.</span><span class="sxs-lookup"><span data-stu-id="e25fa-351">the `H` method in `B` results in a compile-time error because the return type `A` is not at least as accessible as the method.</span></span>

## <a name="signatures-and-overloading"></a><span data-ttu-id="e25fa-352">Signaturen und überladen</span><span class="sxs-lookup"><span data-stu-id="e25fa-352">Signatures and overloading</span></span>

<span data-ttu-id="e25fa-353">Methoden, Instanzkonstruktoren, Indexer und Operatoren sind gekennzeichnet durch die ***Signaturen***:</span><span class="sxs-lookup"><span data-stu-id="e25fa-353">Methods, instance constructors, indexers, and operators are characterized by their ***signatures***:</span></span>

*  <span data-ttu-id="e25fa-354">Die Signatur einer Methode besteht aus den Namen der Methode, die Anzahl von Typparametern und der Typ und die Art (Wert, Verweis oder Ausgabe) aller seiner formalen Parameter, die in der Reihenfolge von links nach rechts betrachtet.</span><span class="sxs-lookup"><span data-stu-id="e25fa-354">The signature of a method consists of the name of the method, the number of type parameters and the type and kind (value, reference, or output) of each of its formal parameters, considered in the order left to right.</span></span> <span data-ttu-id="e25fa-355">Für diese Zwecke wird einen Typparameter der Methode, die in den Typ eines formalen Parameters auftritt, nicht mit dem Namen, aber anhand ihrer Ordnungsposition in der Liste der Typargumente der Methode identifiziert.</span><span class="sxs-lookup"><span data-stu-id="e25fa-355">For these purposes, any type parameter of the method that occurs in the type of a formal parameter is identified not by its name, but by its ordinal position in the type argument list of the method.</span></span> <span data-ttu-id="e25fa-356">Die Signatur einer Methode beinhalten insbesondere nicht den Rückgabetyp der `params` Modifizierer, der für den äußeren rechten Parameter noch optionale Einschränkungen für Typparameter angegeben werden kann.</span><span class="sxs-lookup"><span data-stu-id="e25fa-356">The signature of a method specifically does not include the return type, the `params` modifier that may be specified for the right-most parameter, nor the optional type parameter constraints.</span></span>
*  <span data-ttu-id="e25fa-357">Die Signatur eines Instanzkonstruktors besteht aus den Typ und die Art (Wert, Verweis oder Ausgabe) aller seiner formalen Parameter, die in der Reihenfolge von links nach rechts betrachtet.</span><span class="sxs-lookup"><span data-stu-id="e25fa-357">The signature of an instance constructor consists of the type and kind (value, reference, or output) of each of its formal parameters, considered in the order left to right.</span></span> <span data-ttu-id="e25fa-358">Die Signatur eines Instanzkonstruktors schließt insbesondere nicht die `params` Modifizierer, der für den äußersten-Parameter angegeben werden kann.</span><span class="sxs-lookup"><span data-stu-id="e25fa-358">The signature of an instance constructor specifically does not include the `params` modifier that may be specified for the right-most parameter.</span></span>
*  <span data-ttu-id="e25fa-359">Die Signatur eines Indexers besteht aus den Typ der einzelnen formalen Parameter, in der Reihenfolge von links nach rechts betrachtet.</span><span class="sxs-lookup"><span data-stu-id="e25fa-359">The signature of an indexer consists of the type of each of its formal parameters, considered in the order left to right.</span></span> <span data-ttu-id="e25fa-360">Die Signatur eines Indexers speziell enthält keinen Typ des Elements, und umfasst auch die `params` Modifizierer, der für den äußersten-Parameter angegeben werden kann.</span><span class="sxs-lookup"><span data-stu-id="e25fa-360">The signature of an indexer specifically does not include the element type, nor does it include the `params` modifier that may be specified for the right-most parameter.</span></span>
*  <span data-ttu-id="e25fa-361">Die Signatur eines Operators besteht aus den Namen des Operators und den Typ der einzelnen formalen Parameter, in der Reihenfolge von links nach rechts betrachtet.</span><span class="sxs-lookup"><span data-stu-id="e25fa-361">The signature of an operator consists of the name of the operator and the type of each of its formal parameters, considered in the order left to right.</span></span> <span data-ttu-id="e25fa-362">Die Signatur eines Operators schließt insbesondere nicht den Ergebnistyp.</span><span class="sxs-lookup"><span data-stu-id="e25fa-362">The signature of an operator specifically does not include the result type.</span></span>

<span data-ttu-id="e25fa-363">Signaturen sind der Aktivierung Mechanismus zum ***überladen*** von Elementen in Klassen, Strukturen und Schnittstellen:</span><span class="sxs-lookup"><span data-stu-id="e25fa-363">Signatures are the enabling mechanism for ***overloading*** of members in classes, structs, and interfaces:</span></span>

*  <span data-ttu-id="e25fa-364">Das Überladen von Methoden ermöglicht, Klasse, Struktur oder Schnittstelle deklariert, dass mehrere Methoden mit dem gleichen Namen, ihre Signaturen bereitgestellten innerhalb dieser Klasse, Struktur oder Schnittstelle eindeutig sind.</span><span class="sxs-lookup"><span data-stu-id="e25fa-364">Overloading of methods permits a class, struct, or interface to declare multiple methods with the same name, provided their signatures are unique within that class, struct, or interface.</span></span>
*  <span data-ttu-id="e25fa-365">Das Überladen von Instanzkonstruktoren ermöglicht einer Klasse oder Struktur, um mehrere Instanzkonstruktoren, zu deklarieren, vorausgesetzt, dass die Signaturen in der Klasse oder Struktur eindeutig sind.</span><span class="sxs-lookup"><span data-stu-id="e25fa-365">Overloading of instance constructors permits a class or struct to declare multiple instance constructors, provided their signatures are unique within that class or struct.</span></span>
*  <span data-ttu-id="e25fa-366">Eine Klasse, Struktur oder Schnittstelle, um mehrere Indexer deklarieren, das Überladen der Indexer ermöglicht werden, vorausgesetzt, dass die Signaturen in dieser Klasse, Struktur oder Schnittstelle eindeutig sind.</span><span class="sxs-lookup"><span data-stu-id="e25fa-366">Overloading of indexers permits a class, struct, or interface to declare multiple indexers, provided their signatures are unique within that class, struct, or interface.</span></span>
*  <span data-ttu-id="e25fa-367">Das Überladen von Operatoren ermöglicht, eine Klasse oder Struktur deklariert, dass mehrere Operatoren mit dem gleichen Namen, ihre Signaturen bereitgestellten eindeutig innerhalb der Klasse oder Struktur sind.</span><span class="sxs-lookup"><span data-stu-id="e25fa-367">Overloading of operators permits a class or struct to declare multiple operators with the same name, provided their signatures are unique within that class or struct.</span></span>

<span data-ttu-id="e25fa-368">Obwohl `out` und `ref` Parametermodifizierern gelten als Teil einer Signatur, die in einem einzelnen Typ deklarierten Member dürfen sich nicht unterscheiden in Signatur über `ref` und `out`.</span><span class="sxs-lookup"><span data-stu-id="e25fa-368">Although `out` and `ref` parameter modifiers are considered part of a signature, members declared in a single type cannot differ in signature solely by `ref` and `out`.</span></span> <span data-ttu-id="e25fa-369">Ein Fehler während der Kompilierung tritt auf, wenn zwei Member deklariert werden in der gleichen Art mit Signaturen, die dieselbe, wenn alle Parameter in den beiden Methoden mit `out` Modifizierer wurden geändert, um `ref` Modifizierer.</span><span class="sxs-lookup"><span data-stu-id="e25fa-369">A compile-time error occurs if two members are declared in the same type with signatures that would be the same if all parameters in both methods with `out` modifiers were changed to `ref` modifiers.</span></span> <span data-ttu-id="e25fa-370">Für andere Zwecke signaturabstimmung (z. B. zum Ausblenden oder überschreiben), `ref` und `out` gelten als Teil der Signatur und passen nicht zueinander.</span><span class="sxs-lookup"><span data-stu-id="e25fa-370">For other purposes of signature matching (e.g., hiding or overriding), `ref` and `out` are considered part of the signature and do not match each other.</span></span> <span data-ttu-id="e25fa-371">(Diese Einschränkung ist, können C# Programme leicht übersetzt werden, führen Sie auf der Common Language Infrastructure (CLI), die keine bietet eine Möglichkeit zum Definieren von Methoden, die ausschließlich in unterscheiden `ref` und `out`.)</span><span class="sxs-lookup"><span data-stu-id="e25fa-371">(This restriction is to allow C#  programs to be easily translated to run on the Common Language Infrastructure (CLI), which does not provide a way to define methods that differ solely in `ref` and `out`.)</span></span>

<span data-ttu-id="e25fa-372">Im Rahmen der Signaturen, die Typen `object` und `dynamic` werden als identisch betrachtet.</span><span class="sxs-lookup"><span data-stu-id="e25fa-372">For the purposes of signatures, the types `object` and `dynamic` are considered the same.</span></span> <span data-ttu-id="e25fa-373">In einem einzelnen Typ deklarierten Member können aus diesem Grund unterscheiden sich nicht in der Signatur über `object` und `dynamic`.</span><span class="sxs-lookup"><span data-stu-id="e25fa-373">Members declared in a single type can therefore not differ in signature solely by `object` and `dynamic`.</span></span>

<span data-ttu-id="e25fa-374">Das folgende Beispiel zeigt eine Reihe von Deklarationen der überladenen Methode zusammen mit ihren Signaturen.</span><span class="sxs-lookup"><span data-stu-id="e25fa-374">The following example shows a set of overloaded method declarations along with their signatures.</span></span>
```csharp
interface ITest
{
    void F();                        // F()

    void F(int x);                   // F(int)

    void F(ref int x);               // F(ref int)

    void F(out int x);               // F(out int)      error

    void F(int x, int y);            // F(int, int)

    int F(string s);                 // F(string)

    int F(int x);                    // F(int)          error

    void F(string[] a);              // F(string[])

    void F(params string[] a);       // F(string[])     error
}
```

<span data-ttu-id="e25fa-375">Beachten Sie, dass jede `ref` und `out` Parametermodifizierern ([Methodenparameter](classes.md#method-parameters)) sind Teil einer Signatur.</span><span class="sxs-lookup"><span data-stu-id="e25fa-375">Note that any `ref` and `out` parameter modifiers ([Method parameters](classes.md#method-parameters)) are part of a signature.</span></span> <span data-ttu-id="e25fa-376">Daher `F(int)` und `F(ref int)` sind eindeutige Signaturen.</span><span class="sxs-lookup"><span data-stu-id="e25fa-376">Thus, `F(int)` and `F(ref int)` are unique signatures.</span></span> <span data-ttu-id="e25fa-377">Allerdings `F(ref int)` und `F(out int)` kann nicht innerhalb der gleichen Schnittstelle deklariert werden, da ihre Signaturen, ausschließlich vom unterscheiden `ref` und `out`.</span><span class="sxs-lookup"><span data-stu-id="e25fa-377">However, `F(ref int)` and `F(out int)` cannot be declared within the same interface because their signatures differ solely by `ref` and `out`.</span></span> <span data-ttu-id="e25fa-378">Beachten Sie auch, die den Rückgabetyp und die `params` Modifizierer sind nicht Teil der Signatur, daher ist es nicht möglich, ausschließlich basierend auf den Rückgabetyp oder Einschluss oder Ausschluss von Überladen der `params` Modifizierer.</span><span class="sxs-lookup"><span data-stu-id="e25fa-378">Also, note that the return type and the `params` modifier are not part of a signature, so it is not possible to overload solely based on return type or on the inclusion or exclusion of the `params` modifier.</span></span> <span data-ttu-id="e25fa-379">Als solche, die Deklarationen der Methoden `F(int)` und `F(params string[])` das oben genannte Ergebnis zu einem Fehler während der Kompilierung.</span><span class="sxs-lookup"><span data-stu-id="e25fa-379">As such, the declarations of the methods `F(int)` and `F(params string[])` identified above result in a compile-time error.</span></span>

## <a name="scopes"></a><span data-ttu-id="e25fa-380">Bereiche</span><span class="sxs-lookup"><span data-stu-id="e25fa-380">Scopes</span></span>

<span data-ttu-id="e25fa-381">Die ***Bereich*** mit einem Namen, ist die Region des Programmtexts, in dem es möglich ist, auf die Entität deklariert, die anhand des Namens ohne Qualifizierung des Namens verweisen.</span><span class="sxs-lookup"><span data-stu-id="e25fa-381">The ***scope*** of a name is the region of program text within which it is possible to refer to the entity declared by the name without qualification of the name.</span></span> <span data-ttu-id="e25fa-382">Bereiche möglich ***geschachtelte***, und einem inneren Gültigkeitsbereich möglicherweise erneut die Bedeutung eines Namens außerhalb des Gültigkeitsbereichs deklariert werden (Dies wird jedoch nicht, entfernt die Einschränkung seitens [Deklarationen](basic-concepts.md#declarations) , dass es in einem geschachtelten Block nicht möglich, eine lokale Variable mit dem gleichen Namen wie eine lokale Variable in einem einschließenden Block deklarieren).</span><span class="sxs-lookup"><span data-stu-id="e25fa-382">Scopes can be ***nested***, and an inner scope may redeclare the meaning of a name from an outer scope (this does not, however, remove the restriction imposed by [Declarations](basic-concepts.md#declarations) that within a nested block it is not possible to declare a local variable with the same name as a local variable in an enclosing block).</span></span> <span data-ttu-id="e25fa-383">Der Name aus dem äußeren Bereich gilt dann als ***ausgeblendeten*** in der Region des Programms Text behandelt, durch den inneren Bereich aus, und Zugriff auf den äußeren Namen ist nur möglich, indem Sie die Namen qualifizieren.</span><span class="sxs-lookup"><span data-stu-id="e25fa-383">The name from the outer scope is then said to be ***hidden*** in the region of program text covered by the inner scope, and access to the outer name is only possible by qualifying the name.</span></span>

*  <span data-ttu-id="e25fa-384">Der Gültigkeitsbereich eines Namespace deklariert werden, indem eine *Namespace_member_declaration* ([Namespace Member](namespaces.md#namespace-members)) mit ohne einschließenden *Namespace_declaration* wird das gesamte Programm Text.</span><span class="sxs-lookup"><span data-stu-id="e25fa-384">The scope of a namespace member declared by a *namespace_member_declaration* ([Namespace members](namespaces.md#namespace-members)) with no enclosing *namespace_declaration* is the entire program text.</span></span>
*  <span data-ttu-id="e25fa-385">Der Gültigkeitsbereich eines Namespace deklariert werden, indem eine *Namespace_member_declaration* innerhalb einer *Namespace_declaration* ist, dessen vollqualifizierter Name `N` ist die *Namespace_body*  von jedem *Namespace_declaration* ist, dessen vollqualifizierter Name `N` oder beginnt mit `N`, gefolgt von einem Punkt.</span><span class="sxs-lookup"><span data-stu-id="e25fa-385">The scope of a namespace member declared by a *namespace_member_declaration* within a *namespace_declaration* whose fully qualified name is `N` is the *namespace_body* of every *namespace_declaration* whose fully qualified name is `N` or starts with `N`, followed by a period.</span></span>
*  <span data-ttu-id="e25fa-386">Den Bereich der Namen von definiert eine *Extern_alias_directive* erstreckt sich über die *Using_directive*s, *Global_attributes* und *Namespace_member_ Deklaration*s des direkt enthaltenden Kompilierung oder Text.</span><span class="sxs-lookup"><span data-stu-id="e25fa-386">The scope of name defined by an *extern_alias_directive* extends over the *using_directive*s, *global_attributes* and *namespace_member_declaration*s of its immediately containing compilation unit or namespace body.</span></span> <span data-ttu-id="e25fa-387">Ein *Extern_alias_directive* trägt sich nicht auf alle neuen Member zu den zugrunde liegenden Deklarationsabschnitt.</span><span class="sxs-lookup"><span data-stu-id="e25fa-387">An *extern_alias_directive* does not contribute any new members to the underlying declaration space.</span></span> <span data-ttu-id="e25fa-388">Das heißt, eine *Extern_alias_directive* ist nicht transitiv, sondern nur die Kompilierung Einheit oder Namespacetext in dem er auftritt, beeinflusst.</span><span class="sxs-lookup"><span data-stu-id="e25fa-388">In other words, an *extern_alias_directive* is not transitive, but, rather, affects only the compilation unit or namespace body in which it occurs.</span></span>
*  <span data-ttu-id="e25fa-389">Bereich mit einem Namen definiert oder importiert, indem eine *Using_directive* ([Using-Direktiven](namespaces.md#using-directives)) erstreckt sich über die *Namespace_member_declaration*s der  *Compilation_unit* oder *Namespace_body* in dem die *Using_directive* auftritt.</span><span class="sxs-lookup"><span data-stu-id="e25fa-389">The scope of a name defined or imported by a *using_directive* ([Using directives](namespaces.md#using-directives)) extends over the *namespace_member_declaration*s of the *compilation_unit* or *namespace_body* in which the *using_directive* occurs.</span></span> <span data-ttu-id="e25fa-390">Ein *Using_directive* möglicherweise Verfügbarmachen von 0 (null) oder mehrere Namen von Namespace, Typ oder Member innerhalb eines bestimmten *Compilation_unit* oder *Namespace_body*, jedoch nicht tragen Sie alle neuen Member zu den zugrunde liegenden Deklarationsabschnitt.</span><span class="sxs-lookup"><span data-stu-id="e25fa-390">A *using_directive* may make zero or more namespace, type or member names available within a particular *compilation_unit* or *namespace_body*, but does not contribute any new members to the underlying declaration space.</span></span> <span data-ttu-id="e25fa-391">Das heißt, eine *Using_directive* ist nicht transitiv, sondern beeinflusst nur den *Compilation_unit* oder *Namespace_body* in dem sie verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="e25fa-391">In other words, a *using_directive* is not transitive but rather affects only the *compilation_unit* or *namespace_body* in which it occurs.</span></span>
*  <span data-ttu-id="e25fa-392">Der Bereich, der einen Typparameter deklariert, indem eine *Type_parameter_list* auf eine *Class_declaration* ([Klasse Deklarationen](classes.md#class-declarations)) ist die *Class_base*, *Type_parameter_constraints_clause*s, und *Class_body* , *Class_declaration*.</span><span class="sxs-lookup"><span data-stu-id="e25fa-392">The scope of a type parameter declared by a *type_parameter_list* on a *class_declaration* ([Class declarations](classes.md#class-declarations)) is the *class_base*, *type_parameter_constraints_clause*s, and *class_body* of that *class_declaration*.</span></span>
*  <span data-ttu-id="e25fa-393">Der Bereich, der einen Typparameter deklariert, indem eine *Type_parameter_list* auf eine *Struct_declaration* ([Strukturdeklarationen](structs.md#struct-declarations)) ist die *Struct_interfaces* , *Type_parameter_constraints_clause*s, und *Struct_body* , *Struct_declaration*.</span><span class="sxs-lookup"><span data-stu-id="e25fa-393">The scope of a type parameter declared by a *type_parameter_list* on a *struct_declaration* ([Struct declarations](structs.md#struct-declarations)) is the *struct_interfaces*, *type_parameter_constraints_clause*s, and *struct_body* of that *struct_declaration*.</span></span>
*  <span data-ttu-id="e25fa-394">Der Bereich, der einen Typparameter deklariert, indem eine *Type_parameter_list* auf ein *Interface_declaration* ([Schnittstellendeklarationen](interfaces.md#interface-declarations)) ist die *Interface_base* , *Type_parameter_constraints_clause*s, und *Interface_body* , *Interface_declaration*.</span><span class="sxs-lookup"><span data-stu-id="e25fa-394">The scope of a type parameter declared by a *type_parameter_list* on an *interface_declaration* ([Interface declarations](interfaces.md#interface-declarations)) is the *interface_base*, *type_parameter_constraints_clause*s, and *interface_body* of that *interface_declaration*.</span></span>
*  <span data-ttu-id="e25fa-395">Der Bereich der einen Typparameter deklariert, indem eine *Type_parameter_list* auf eine *Delegate_declaration* ([delegieren Deklarationen](delegates.md#delegate-declarations)) ist die *Return_type*, *Formal_parameter_list*, und *Type_parameter_constraints_clause*s, *Delegate_declaration*.</span><span class="sxs-lookup"><span data-stu-id="e25fa-395">The scope of a type parameter declared by a *type_parameter_list* on a *delegate_declaration* ([Delegate declarations](delegates.md#delegate-declarations)) is the *return_type*, *formal_parameter_list*, and *type_parameter_constraints_clause*s of that *delegate_declaration*.</span></span>
*  <span data-ttu-id="e25fa-396">Der Bereich eines Elements deklariert wird, indem eine *Class_member_declaration* ([Klasse Text](classes.md#class-body)) ist die *Class_body* in dem die Deklaration erfolgt.</span><span class="sxs-lookup"><span data-stu-id="e25fa-396">The scope of a member declared by a *class_member_declaration* ([Class body](classes.md#class-body)) is the *class_body* in which the declaration occurs.</span></span> <span data-ttu-id="e25fa-397">Darüber hinaus der Bereich eines Klassenmembers erweitert, um die *Class_body* davon abgeleiteten Klassen, die in der Zugriffsdomäne enthalten sind ([Barrierefreiheit Domänen](basic-concepts.md#accessibility-domains)) des Elements.</span><span class="sxs-lookup"><span data-stu-id="e25fa-397">In addition, the scope of a class member extends to the *class_body* of those derived classes that are included in the accessibility domain ([Accessibility domains](basic-concepts.md#accessibility-domains)) of the member.</span></span>
*  <span data-ttu-id="e25fa-398">Der Bereich eines Elements deklariert wird, indem eine *Struct_member_declaration* ([Strukturmember](structs.md#struct-members)) ist die *Struct_body* in dem die Deklaration erfolgt.</span><span class="sxs-lookup"><span data-stu-id="e25fa-398">The scope of a member declared by a *struct_member_declaration* ([Struct members](structs.md#struct-members)) is the *struct_body* in which the declaration occurs.</span></span>
*  <span data-ttu-id="e25fa-399">Der Bereich eines Elements deklariert wird, indem ein *Enum_member_declaration* ([Enumerationsmember](enums.md#enum-members)) ist der *Enum_body* in dem die Deklaration erfolgt.</span><span class="sxs-lookup"><span data-stu-id="e25fa-399">The scope of a member declared by an *enum_member_declaration*  ([Enum members](enums.md#enum-members)) is the *enum_body* in which the declaration occurs.</span></span>
*  <span data-ttu-id="e25fa-400">Der Gültigkeitsbereich eines Parameters in deklarierten eine *Method_declaration* ([Methoden](classes.md#methods)) ist die *Method_body* , *Method_declaration*.</span><span class="sxs-lookup"><span data-stu-id="e25fa-400">The scope of a parameter declared in a *method_declaration* ([Methods](classes.md#methods)) is the *method_body* of that *method_declaration*.</span></span>
*  <span data-ttu-id="e25fa-401">Der Gültigkeitsbereich eines Parameters in deklarierten ein *Indexer_declaration* ([Indexer](classes.md#indexers)) ist die *Accessor_declarations* , *Indexer_declaration*.</span><span class="sxs-lookup"><span data-stu-id="e25fa-401">The scope of a parameter declared in an *indexer_declaration* ([Indexers](classes.md#indexers)) is the *accessor_declarations* of that *indexer_declaration*.</span></span>
*  <span data-ttu-id="e25fa-402">Der Gültigkeitsbereich eines Parameters in deklarierten ein *Operator_declaration* ([Operatoren](classes.md#operators)) ist die *Block* , *Operator_declaration*.</span><span class="sxs-lookup"><span data-stu-id="e25fa-402">The scope of a parameter declared in an *operator_declaration* ([Operators](classes.md#operators)) is the *block* of that *operator_declaration*.</span></span>
*  <span data-ttu-id="e25fa-403">Der Gültigkeitsbereich eines Parameters in deklarierten eine *Constructor_declaration* ([Instanzkonstruktoren](classes.md#instance-constructors)) ist die *Constructor_initializer* und *Block* , *Constructor_declaration*.</span><span class="sxs-lookup"><span data-stu-id="e25fa-403">The scope of a parameter declared in a *constructor_declaration* ([Instance constructors](classes.md#instance-constructors)) is the *constructor_initializer* and *block* of that *constructor_declaration*.</span></span>
*  <span data-ttu-id="e25fa-404">Der Gültigkeitsbereich eines Parameters in deklarierten eine *Lambda_expression* ([anonyme Funktionsausdrücke](expressions.md#anonymous-function-expressions)) ist die *Anonymous_function_body* , *Lambda_ Ausdruck*</span><span class="sxs-lookup"><span data-stu-id="e25fa-404">The scope of a parameter declared in a *lambda_expression* ([Anonymous function expressions](expressions.md#anonymous-function-expressions)) is the *anonymous_function_body* of that *lambda_expression*</span></span>
*  <span data-ttu-id="e25fa-405">Der Gültigkeitsbereich eines Parameters in deklarierten ein *Anonymous_method_expression* ([anonyme Funktionsausdrücke](expressions.md#anonymous-function-expressions)) ist die *Block* , *Anonymous_method _ausdruck*.</span><span class="sxs-lookup"><span data-stu-id="e25fa-405">The scope of a parameter declared in an *anonymous_method_expression* ([Anonymous function expressions](expressions.md#anonymous-function-expressions)) is the *block* of that *anonymous_method_expression*.</span></span>
*  <span data-ttu-id="e25fa-406">Der Umfang einer Bezeichnung in deklariert eine *Labeled_statement* ([Anweisungen mit der Bezeichnung](statements.md#labeled-statements)) ist die *Block* in dem die Deklaration erfolgt.</span><span class="sxs-lookup"><span data-stu-id="e25fa-406">The scope of a label declared in a *labeled_statement* ([Labeled statements](statements.md#labeled-statements)) is the *block* in which the declaration occurs.</span></span>
*  <span data-ttu-id="e25fa-407">Eine lokale Variable deklariert, die im Rahmen einer *Local_variable_declaration* ([lokale Variablendeklarationen](statements.md#local-variable-declarations)) wird der Block in dem die Deklaration erfolgt.</span><span class="sxs-lookup"><span data-stu-id="e25fa-407">The scope of a local variable declared in a *local_variable_declaration* ([Local variable declarations](statements.md#local-variable-declarations)) is the block in which the declaration occurs.</span></span>
*  <span data-ttu-id="e25fa-408">Eine lokale Variable deklariert, die im Rahmen einer *Switch_block* von eine `switch` Anweisung ([der Switch-Anweisung](statements.md#the-switch-statement)) ist der *Switch_block*.</span><span class="sxs-lookup"><span data-stu-id="e25fa-408">The scope of a local variable declared in a *switch_block* of a `switch` statement ([The switch statement](statements.md#the-switch-statement)) is the *switch_block*.</span></span>
*  <span data-ttu-id="e25fa-409">Eine lokale Variable deklariert, die im Rahmen eine *For_initializer* von eine `for` Anweisung ([der für die Anweisung](statements.md#the-for-statement)) ist der *For_initializer*, wird die  *For_condition*, *For_iterator*, und den enthaltenen *Anweisung* von der `for` Anweisung.</span><span class="sxs-lookup"><span data-stu-id="e25fa-409">The scope of a local variable declared in a *for_initializer* of a `for` statement ([The for statement](statements.md#the-for-statement)) is the *for_initializer*, the *for_condition*, the *for_iterator*, and the contained *statement* of the `for` statement.</span></span>
*  <span data-ttu-id="e25fa-410">Der Bereich, der eine lokale Konstante deklariert wird, eine *Local_constant_declaration* ([Deklaration von lokalen Konstanten](statements.md#local-constant-declarations)) wird der Block in dem die Deklaration erfolgt.</span><span class="sxs-lookup"><span data-stu-id="e25fa-410">The scope of a local constant declared in a *local_constant_declaration* ([Local constant declarations](statements.md#local-constant-declarations)) is the block in which the declaration occurs.</span></span> <span data-ttu-id="e25fa-411">Es ist ein Fehler während der Kompilierung zu verweisen auf eine lokale Konstante in der Lage, Text vor dessen *Constant_declarator*.</span><span class="sxs-lookup"><span data-stu-id="e25fa-411">It is a compile-time error to refer to a local constant in a textual position that precedes its *constant_declarator*.</span></span>
*  <span data-ttu-id="e25fa-412">Der Gültigkeitsbereich einer Variablen deklariert werden, als Teil einer *Foreach_statement*, *Using_statement*, *Lock_statement* oder *Query_expression* ist durch die Erweiterung des angegebenen Konstrukts bestimmt.</span><span class="sxs-lookup"><span data-stu-id="e25fa-412">The scope of a variable declared as part of a *foreach_statement*, *using_statement*, *lock_statement* or *query_expression* is determined by the expansion of the given construct.</span></span>

<span data-ttu-id="e25fa-413">Innerhalb des Bereichs eines Elements Namespace, Klasse, Struktur oder eines Enumerationswerts ist es möglich, auf das Element in einer Textposition verweisen, die vor der Deklaration des Members.</span><span class="sxs-lookup"><span data-stu-id="e25fa-413">Within the scope of a namespace, class, struct, or enumeration member it is possible to refer to the member in a textual position that precedes the declaration of the member.</span></span> <span data-ttu-id="e25fa-414">Beispiel:</span><span class="sxs-lookup"><span data-stu-id="e25fa-414">For example</span></span>
```csharp
class A
{
    void F() {
        i = 1;
    }

    int i = 0;
}
```
<span data-ttu-id="e25fa-415">Hier ist es für `F` zum Verweisen auf `i` bevor sie deklariert ist.</span><span class="sxs-lookup"><span data-stu-id="e25fa-415">Here, it is valid for `F` to refer to `i` before it is declared.</span></span>

<span data-ttu-id="e25fa-416">Innerhalb des Bereichs einer lokalen Variablen, ist es ein Fehler während der Kompilierung zu verweisen auf die lokale Variable in der Lage, Text vor dem *Local_variable_declarator* der lokalen Variablen.</span><span class="sxs-lookup"><span data-stu-id="e25fa-416">Within the scope of a local variable, it is a compile-time error to refer to the local variable in a textual position that precedes the *local_variable_declarator* of the local variable.</span></span> <span data-ttu-id="e25fa-417">Beispiel:</span><span class="sxs-lookup"><span data-stu-id="e25fa-417">For example</span></span>
```csharp
class A
{
    int i = 0;

    void F() {
        i = 1;                  // Error, use precedes declaration
        int i;
        i = 2;
    }

    void G() {
        int j = (j = 1);        // Valid
    }

    void H() {
        int a = 1, b = ++a;    // Valid
    }
}
```

<span data-ttu-id="e25fa-418">In der `F` oben genannte Methode, die erste Zuweisung zu `i` insbesondere verweist nicht auf das Feld im äußeren Bereich deklariert.</span><span class="sxs-lookup"><span data-stu-id="e25fa-418">In the `F` method above, the first assignment to `i` specifically does not refer to the field declared in the outer scope.</span></span> <span data-ttu-id="e25fa-419">Stattdessen wird dies bezieht sich auf die lokale Variable, und dies führt zu einem Fehler während der Kompilierung, da die Deklaration der Variablen textlich vorausgehenden.</span><span class="sxs-lookup"><span data-stu-id="e25fa-419">Rather, it refers to the local variable and it results in a compile-time error because it textually precedes the declaration of the variable.</span></span> <span data-ttu-id="e25fa-420">In der `G` -Methode, die Verwendung von `j` im Initialisierer für die Deklaration von `j` ist gültig, da die Verwendung nicht vorausgeht, wird die *Local_variable_declarator*.</span><span class="sxs-lookup"><span data-stu-id="e25fa-420">In the `G` method, the use of `j` in the initializer for the declaration of `j` is valid because the use does not precede the *local_variable_declarator*.</span></span> <span data-ttu-id="e25fa-421">In der `H` -Methode, die einen nachfolgenden *Local_variable_declarator* ordnungsgemäß verweist auf eine lokale Variable deklariert, die in einem früheren Zeitpunkt *Local_variable_declarator* innerhalb desselben  *Local_variable_declaration*.</span><span class="sxs-lookup"><span data-stu-id="e25fa-421">In the `H` method, a subsequent *local_variable_declarator* correctly refers to a local variable declared in an earlier *local_variable_declarator* within the same *local_variable_declaration*.</span></span>

<span data-ttu-id="e25fa-422">Um sicherzustellen, dass die Bedeutung des einen Namen, die in einem Ausdruckskontext verwendet immer innerhalb eines Blocks identisch ist, ist die Bereichsregeln für lokale Variablen dienen.</span><span class="sxs-lookup"><span data-stu-id="e25fa-422">The scoping rules for local variables are designed to guarantee that the meaning of a name used in an expression context is always the same within a block.</span></span> <span data-ttu-id="e25fa-423">Würde der Rahmen einer lokalen Variablen nur aus ihrer Deklaration bis zum Ende des Blocks zu erweitern, klicken Sie dann im obigen Beispiel würden die erste Zuweisung an die Instanzvariable zuweisen, und die zweite Zuweisung würden die lokalen Variablen, was möglicherweise zu zuweisen Fehler während der Kompilierung, wäre die Anweisungen des Blocks neu angeordnet werden weiter unten.</span><span class="sxs-lookup"><span data-stu-id="e25fa-423">If the scope of a local variable were to extend only from its declaration to the end of the block, then in the example above, the first assignment would assign to the instance variable and the second assignment would assign to the local variable, possibly leading to compile-time errors if the statements of the block were later to be rearranged.</span></span>

<span data-ttu-id="e25fa-424">Die Bedeutung eines Namens innerhalb eines Blocks kann basierend auf den Kontext unterscheiden, in dem der Name verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="e25fa-424">The meaning of a name within a block may differ based on the context in which the name is used.</span></span> <span data-ttu-id="e25fa-425">Im Beispiel</span><span class="sxs-lookup"><span data-stu-id="e25fa-425">In the example</span></span>
```csharp
using System;

class A {}

class Test
{
    static void Main() {
        string A = "hello, world";
        string s = A;                            // expression context

        Type t = typeof(A);                      // type context

        Console.WriteLine(s);                    // writes "hello, world"
        Console.WriteLine(t);                    // writes "A"
    }
}
```
<span data-ttu-id="e25fa-426">der Name `A` in einem Ausdruckskontext verwendet wird, die zum Verweisen auf die lokale Variable `A` und in einem Typenkontext zum Verweisen auf die Klasse `A`.</span><span class="sxs-lookup"><span data-stu-id="e25fa-426">the name `A` is used in an expression context to refer to the local variable `A` and in a type context to refer to the class `A`.</span></span>

### <a name="name-hiding"></a><span data-ttu-id="e25fa-427">Ausblenden von Namen</span><span class="sxs-lookup"><span data-stu-id="e25fa-427">Name hiding</span></span>

<span data-ttu-id="e25fa-428">Der Bereich einer Entität umfasst in der Regel mehr Programmtext im Deklarationsabschnitt der Entität.</span><span class="sxs-lookup"><span data-stu-id="e25fa-428">The scope of an entity typically encompasses more program text than the declaration space of the entity.</span></span> <span data-ttu-id="e25fa-429">Insbesondere kann der Bereich einer Entität Deklarationen enthalten, die Einführung neuer Deklaration Leerzeichen, die Entitäten mit demselben Namen enthält.</span><span class="sxs-lookup"><span data-stu-id="e25fa-429">In particular, the scope of an entity may include declarations that introduce new declaration spaces containing entities of the same name.</span></span> <span data-ttu-id="e25fa-430">Derartige Deklarationen dazu führen, dass die ursprüngliche Entität werden ***ausgeblendeten***.</span><span class="sxs-lookup"><span data-stu-id="e25fa-430">Such declarations cause the original entity to become ***hidden***.</span></span> <span data-ttu-id="e25fa-431">Im Gegensatz dazu eine Entität gilt als ***sichtbar*** Wenn dieser nicht ausgeblendet.</span><span class="sxs-lookup"><span data-stu-id="e25fa-431">Conversely, an entity is said to be ***visible*** when it is not hidden.</span></span>

<span data-ttu-id="e25fa-432">Ausblenden von Namen tritt auf, wenn Bereiche überschneiden, durch die Schachtelung und wenn die Bereiche durch Vererbung überlappen.</span><span class="sxs-lookup"><span data-stu-id="e25fa-432">Name hiding occurs when scopes overlap through nesting and when scopes overlap through inheritance.</span></span> <span data-ttu-id="e25fa-433">Die Eigenschaften der beiden Typen von ausblenden, werden in den folgenden Abschnitten beschrieben.</span><span class="sxs-lookup"><span data-stu-id="e25fa-433">The characteristics of the two types of hiding are described in the following sections.</span></span>

#### <a name="hiding-through-nesting"></a><span data-ttu-id="e25fa-434">Durch die Schachtelung ausblenden</span><span class="sxs-lookup"><span data-stu-id="e25fa-434">Hiding through nesting</span></span>

<span data-ttu-id="e25fa-435">Ausblenden des Namens durch die Schachtelung kann als Ergebnis das Schachteln von Namespaces oder Typen in Namespaces, die als Ergebnis das Schachteln von Typen in Klassen oder Strukturen und als Ergebnis der Parameter und der lokale Variablendeklarationen auftreten.</span><span class="sxs-lookup"><span data-stu-id="e25fa-435">Name hiding through nesting can occur as a result of nesting namespaces or types within namespaces, as a result of nesting types within classes or structs, and as a result of parameter and local variable declarations.</span></span>

<span data-ttu-id="e25fa-436">Im Beispiel</span><span class="sxs-lookup"><span data-stu-id="e25fa-436">In the example</span></span>
```csharp
class A
{
    int i = 0;

    void F() {
        int i = 1;
    }

    void G() {
        i = 1;
    }
}
```
<span data-ttu-id="e25fa-437">in der `F` -Methode, die Instanzvariable `i` ist ausgeblendet, die lokale Variable `i`, aber noch innerhalb der `G` -Methode, `i` weiterhin auf die Instanzvariable verweist.</span><span class="sxs-lookup"><span data-stu-id="e25fa-437">within the `F` method, the instance variable `i` is hidden by the local variable `i`, but within the `G` method, `i` still refers to the instance variable.</span></span>

<span data-ttu-id="e25fa-438">Wenn Sie ein Namen in einem inneren Gültigkeitsbereich auf einen Namen in einem äußeren Gültigkeitsbereich verdeckt, wird er alle überladene Vorkommen mit diesem Namen ausgeblendet.</span><span class="sxs-lookup"><span data-stu-id="e25fa-438">When a name in an inner scope hides a name in an outer scope, it hides all overloaded occurrences of that name.</span></span> <span data-ttu-id="e25fa-439">Im Beispiel</span><span class="sxs-lookup"><span data-stu-id="e25fa-439">In the example</span></span>
```csharp
class Outer
{
    static void F(int i) {}

    static void F(string s) {}

    class Inner
    {
        void G() {
            F(1);              // Invokes Outer.Inner.F
            F("Hello");        // Error
        }

        static void F(long l) {}
    }
}
```
<span data-ttu-id="e25fa-440">der Aufruf `F(1)` Ruft die `F` in deklarierten `Inner` da alle äußeren Vorkommen von `F` werden durch die innere Deklaration ausgeblendet.</span><span class="sxs-lookup"><span data-stu-id="e25fa-440">the call `F(1)` invokes the `F` declared in `Inner` because all outer occurrences of `F` are hidden by the inner declaration.</span></span> <span data-ttu-id="e25fa-441">Aus demselben Grund, den Aufruf `F("Hello")` führt zu einem Fehler während der Kompilierung.</span><span class="sxs-lookup"><span data-stu-id="e25fa-441">For the same reason, the call `F("Hello")` results in a compile-time error.</span></span>

#### <a name="hiding-through-inheritance"></a><span data-ttu-id="e25fa-442">Durch Vererbung ausblenden</span><span class="sxs-lookup"><span data-stu-id="e25fa-442">Hiding through inheritance</span></span>

<span data-ttu-id="e25fa-443">Ausblenden des Namens durch Vererbung tritt auf, wenn Sie Klassen oder Strukturen Namen erneut deklariert werden, die von Klassen geerbt wurden.</span><span class="sxs-lookup"><span data-stu-id="e25fa-443">Name hiding through inheritance occurs when classes or structs redeclare names that were inherited from base classes.</span></span> <span data-ttu-id="e25fa-444">Diese Art von Ausblenden von Namen akzeptiert einen der folgenden Formate:</span><span class="sxs-lookup"><span data-stu-id="e25fa-444">This type of name hiding takes one of the following forms:</span></span>

*  <span data-ttu-id="e25fa-445">Eine Konstante, ein Feld, Eigenschaft, Ereignis oder in einer Klasse oder Struktur eingeführt Typ Blendet alle Member der Basisklasse mit dem gleichen Namen.</span><span class="sxs-lookup"><span data-stu-id="e25fa-445">A constant, field, property, event, or type introduced in a class or struct hides all base class members with the same name.</span></span>
*  <span data-ttu-id="e25fa-446">Eine Methode, die in einer Klasse oder Struktur eingeführt Blendet alle nicht-Method-Member der Basisklasse mit dem gleichen Namen, und alle Basisklassenmethoden mit der gleichen Signatur (Methodenname und Parameteranzahl, Modifizierer und Typen).</span><span class="sxs-lookup"><span data-stu-id="e25fa-446">A method introduced in a class or struct hides all non-method base class members with the same name, and all base class methods with the same signature (method name and parameter count, modifiers, and types).</span></span>
*  <span data-ttu-id="e25fa-447">Ein Indexer in einer Klasse oder Struktur eingeführt Blendet alle Basisklassenindexer mit der gleichen Signatur (Anzahl und Typen).</span><span class="sxs-lookup"><span data-stu-id="e25fa-447">An indexer introduced in a class or struct hides all base class indexers with the same signature (parameter count and types).</span></span>

<span data-ttu-id="e25fa-448">Die Regeln für die Operatordeklarationen ([Operatoren](classes.md#operators)) möglicherweise nicht für eine abgeleitete Klasse einen Operator mit der gleichen Signatur als-Operator in einer Basisklasse deklariert.</span><span class="sxs-lookup"><span data-stu-id="e25fa-448">The rules governing operator declarations ([Operators](classes.md#operators)) make it impossible for a derived class to declare an operator with the same signature as an operator in a base class.</span></span> <span data-ttu-id="e25fa-449">Operatoren ausblenden daher nie miteinander.</span><span class="sxs-lookup"><span data-stu-id="e25fa-449">Thus, operators never hide one another.</span></span>

<span data-ttu-id="e25fa-450">Im Gegensatz zur Ausblenden von einem Namen aus einem äußeren Bereich aus, führt dazu, dass eine barrierefreie Name aus einem geerbten Gültigkeitsbereich ausblenden eine Warnung gemeldet werden.</span><span class="sxs-lookup"><span data-stu-id="e25fa-450">Contrary to hiding a name from an outer scope, hiding an accessible name from an inherited scope causes a warning to be reported.</span></span> <span data-ttu-id="e25fa-451">Im Beispiel</span><span class="sxs-lookup"><span data-stu-id="e25fa-451">In the example</span></span>
```csharp
class Base
{
    public void F() {}
}

class Derived: Base
{
    public void F() {}        // Warning, hiding an inherited name
}
```
<span data-ttu-id="e25fa-452">die Deklaration von `F` in `Derived` bewirkt, dass eine Warnung gemeldet werden.</span><span class="sxs-lookup"><span data-stu-id="e25fa-452">the declaration of `F` in `Derived` causes a warning to be reported.</span></span> <span data-ttu-id="e25fa-453">Ausblenden einer geerbten Namens ist insbesondere keinen Fehler, da, die separate Entwicklung von Basisklassen ausgeschlossen würden.</span><span class="sxs-lookup"><span data-stu-id="e25fa-453">Hiding an inherited name is specifically not an error, since that would preclude separate evolution of base classes.</span></span> <span data-ttu-id="e25fa-454">Z. B. die oben genannten Situation möglicherweise haben vorkommen, da eine höhere Version von `Base` eingeführt, eine `F` Methode, die nicht in einer früheren Version der Klasse vorhanden war.</span><span class="sxs-lookup"><span data-stu-id="e25fa-454">For example, the above situation might have come about because a later version of `Base` introduced an `F` method that wasn't present in an earlier version of the class.</span></span> <span data-ttu-id="e25fa-455">Die oben genannten Situation ein Fehler gewesen, könnte jede Änderung an einer Basisklasse in einer separaten Versionen Klassenbibliothek potenziell abgeleitete Klassen, ungültig werden, bewirken.</span><span class="sxs-lookup"><span data-stu-id="e25fa-455">Had the above situation been an error, then any change made to a base class in a separately versioned class library could potentially cause derived classes to become invalid.</span></span>

<span data-ttu-id="e25fa-456">Durch das Ausblenden einer geerbten namens ausgelöste Warnung kann behoben werden, durch die Verwendung von der `new` Modifizierer:</span><span class="sxs-lookup"><span data-stu-id="e25fa-456">The warning caused by hiding an inherited name can be eliminated through use of the `new` modifier:</span></span>
```csharp
class Base
{
    public void F() {}
}

class Derived: Base
{
    new public void F() {}
}
```

<span data-ttu-id="e25fa-457">Die `new` Modifizierer gibt an, dass die `F` in `Derived` ist "Neu", und dass sie tatsächlich dafür konzipiert ist, die geerbten Member auszublenden.</span><span class="sxs-lookup"><span data-stu-id="e25fa-457">The `new` modifier indicates that the `F` in `Derived` is "new", and that it is indeed intended to hide the inherited member.</span></span>

<span data-ttu-id="e25fa-458">Eine Deklaration eines neuen Members Blendet einen geerbten Member nur innerhalb des Bereichs des neuen Mitglieds.</span><span class="sxs-lookup"><span data-stu-id="e25fa-458">A declaration of a new member hides an inherited member only within the scope of the new member.</span></span>

```csharp
class Base
{
    public static void F() {}
}

class Derived: Base
{
    new private static void F() {}    // Hides Base.F in Derived only
}

class MoreDerived: Derived
{
    static void G() { F(); }          // Invokes Base.F
}
```

<span data-ttu-id="e25fa-459">Im obigen Beispiel ist die Deklaration von `F` in `Derived` Blendet Sie aus der `F` , vererbt wurde `Base`, aber das neue `F` in `Derived` privaten Zugriff hat der Bereich erstreckt sich nicht um `MoreDerived` .</span><span class="sxs-lookup"><span data-stu-id="e25fa-459">In the example above, the declaration of `F` in `Derived` hides the `F` that was inherited from `Base`, but since the new `F` in `Derived` has private access, its scope does not extend to `MoreDerived`.</span></span> <span data-ttu-id="e25fa-460">Daher den Aufruf `F()` in `MoreDerived.G` gültig ist und ruft `Base.F`.</span><span class="sxs-lookup"><span data-stu-id="e25fa-460">Thus, the call `F()` in `MoreDerived.G` is valid and will invoke `Base.F`.</span></span>

## <a name="namespace-and-type-names"></a><span data-ttu-id="e25fa-461">Namespace und Typnamen</span><span class="sxs-lookup"><span data-stu-id="e25fa-461">Namespace and type names</span></span>

<span data-ttu-id="e25fa-462">Mehrere Kontexte in einem C# Programm erforderlich einen *Namespace_name* oder *Type_name* angegeben werden.</span><span class="sxs-lookup"><span data-stu-id="e25fa-462">Several contexts in a C# program require a *namespace_name* or a *type_name* to be specified.</span></span>

```antlr
namespace_name
    : namespace_or_type_name
    ;

type_name
    : namespace_or_type_name
    ;

namespace_or_type_name
    : identifier type_argument_list?
    | namespace_or_type_name '.' identifier type_argument_list?
    | qualified_alias_member
    ;
```

<span data-ttu-id="e25fa-463">Ein *Namespace_name* ist eine *Namespace_or_type_name* , der auf einen Namespace verweist.</span><span class="sxs-lookup"><span data-stu-id="e25fa-463">A *namespace_name* is a *namespace_or_type_name* that refers to a namespace.</span></span> <span data-ttu-id="e25fa-464">Auflösung befolgen, wie unten beschrieben, die *Namespace_or_type_name* von einer *Namespace_name* muss einem Namespace verweisen oder andernfalls tritt ein Fehler während der Kompilierung auf.</span><span class="sxs-lookup"><span data-stu-id="e25fa-464">Following resolution as described below, the *namespace_or_type_name* of a *namespace_name* must refer to a namespace, or otherwise a compile-time error occurs.</span></span> <span data-ttu-id="e25fa-465">Keine Typargumente ([Typargumente](types.md#type-arguments)) in vorhanden sein können eine *Namespace_name* (nur Typen über Typargumente verfügen können).</span><span class="sxs-lookup"><span data-stu-id="e25fa-465">No type arguments ([Type arguments](types.md#type-arguments)) can be present in a *namespace_name* (only types can have type arguments).</span></span>

<span data-ttu-id="e25fa-466">Ein *Type_name* ist eine *Namespace_or_type_name* , der auf einen Typ verweist.</span><span class="sxs-lookup"><span data-stu-id="e25fa-466">A *type_name* is a *namespace_or_type_name* that refers to a type.</span></span> <span data-ttu-id="e25fa-467">Auflösung befolgen, wie unten beschrieben, die *Namespace_or_type_name* von einer *Type_name* muss auf einen Typ verweisen oder andernfalls tritt ein Fehler während der Kompilierung auf.</span><span class="sxs-lookup"><span data-stu-id="e25fa-467">Following resolution as described below, the *namespace_or_type_name* of a *type_name* must refer to a type, or otherwise a compile-time error occurs.</span></span>

<span data-ttu-id="e25fa-468">Wenn die *Namespace_or_type_name* ist ein qualifizierter-Alias-Element seine Bedeutung ist, wie in beschrieben [Namespace Alias Qualifiers](namespaces.md#namespace-alias-qualifiers).</span><span class="sxs-lookup"><span data-stu-id="e25fa-468">If the *namespace_or_type_name* is a qualified-alias-member its meaning is as described in [Namespace alias qualifiers](namespaces.md#namespace-alias-qualifiers).</span></span> <span data-ttu-id="e25fa-469">Andernfalls ein *Namespace_or_type_name* verfügt über einen von vier Formaten:</span><span class="sxs-lookup"><span data-stu-id="e25fa-469">Otherwise, a *namespace_or_type_name* has one of four forms:</span></span>

*  `I`
*  `I<A1, ..., Ak>`
*  `N.I`
*  `N.I<A1, ..., Ak>`

<span data-ttu-id="e25fa-470">in denen `I` ist ein einzelner Bezeichner, `N` ist eine *Namespace_or_type_name* und `<A1, ..., Ak>` ist eine optionale *Type_argument_list*.</span><span class="sxs-lookup"><span data-stu-id="e25fa-470">where `I` is a single identifier, `N` is a *namespace_or_type_name* and `<A1, ..., Ak>` is an optional *type_argument_list*.</span></span> <span data-ttu-id="e25fa-471">Wenn kein *Type_argument_list* wird angegeben, sollten Sie `k` 0 (null).</span><span class="sxs-lookup"><span data-stu-id="e25fa-471">When no *type_argument_list* is specified, consider `k` to be zero.</span></span>

<span data-ttu-id="e25fa-472">Die Bedeutung des einen *Namespace_or_type_name* wird wie folgt bestimmt:</span><span class="sxs-lookup"><span data-stu-id="e25fa-472">The meaning of a *namespace_or_type_name* is determined as follows:</span></span>

*   <span data-ttu-id="e25fa-473">Wenn die *Namespace_or_type_name* hat das Format `I` oder des Formulars `I<A1, ..., Ak>`:</span><span class="sxs-lookup"><span data-stu-id="e25fa-473">If the *namespace_or_type_name* is of the form `I` or of the form `I<A1, ..., Ak>`:</span></span>
    * <span data-ttu-id="e25fa-474">Wenn `K` ist 0 (null) und die *Namespace_or_type_name* innerhalb der Deklaration einer generischen Methode angezeigt wird ([Methoden](classes.md#methods)) und wenn dieser Deklaration einen Typparameter enthält ([Typ Parameter](classes.md#type-parameters)) mit dem Namen `I`, und klicken Sie dann die *Namespace_or_type_name* bezieht sich auf den Typparameter.</span><span class="sxs-lookup"><span data-stu-id="e25fa-474">If `K` is zero and the *namespace_or_type_name* appears within a generic method declaration ([Methods](classes.md#methods)) and if that declaration includes a type parameter ([Type parameters](classes.md#type-parameters)) with name `I`, then the *namespace_or_type_name* refers to that type parameter.</span></span>
    * <span data-ttu-id="e25fa-475">Andernfalls gilt: Wenn die *Namespace_or_type_name* angezeigt wird, in einer Typdeklaration aus, und klicken Sie dann für jeden Instanztyp `T` ([den Instanztyp](classes.md#the-instance-type)) mit dem Instanztyp dieses Typs ab. Erklärung und weiterhin mit den Instanztyp einer Deklaration für jeden einschließenden Klasse oder Struktur (falls vorhanden):</span><span class="sxs-lookup"><span data-stu-id="e25fa-475">Otherwise, if the *namespace_or_type_name* appears within a type declaration, then for each instance type `T` ([The instance type](classes.md#the-instance-type)), starting with the instance type of that type declaration and continuing with the instance type of each enclosing class or struct declaration (if any):</span></span>
        * <span data-ttu-id="e25fa-476">Wenn `K` ist 0 (null) und die Deklaration von `T` enthält einen Typparameter mit dem Namen `I`, und klicken Sie dann die *Namespace_or_type_name* bezieht sich auf den Typparameter.</span><span class="sxs-lookup"><span data-stu-id="e25fa-476">If `K` is zero and the declaration of `T` includes a type parameter with name `I`, then the *namespace_or_type_name* refers to that type parameter.</span></span>
        * <span data-ttu-id="e25fa-477">Andernfalls gilt: Wenn die *Namespace_or_type_name* angezeigt wird, im Hauptteil der Deklaration des Typs und `T` oder seinen Basistypen enthalten einen geschachtelten zugegriffen werden Typ, der mit Namen `I` und `K`  Typparameter, und klicken Sie dann die *Namespace_or_type_name* bezieht sich auf diesen Typ mit den Argumenten angegebenen Typs erstellt.</span><span class="sxs-lookup"><span data-stu-id="e25fa-477">Otherwise, if the *namespace_or_type_name* appears within the body of the type declaration, and `T` or any of its base types contain a nested accessible type having name `I` and `K` type parameters, then the *namespace_or_type_name* refers to that type constructed with the given type arguments.</span></span> <span data-ttu-id="e25fa-478">Wenn mehr als ein solcher Typ vorhanden ist, wird die in den stärker abgeleiteten Typ deklarierte Typ ausgewählt.</span><span class="sxs-lookup"><span data-stu-id="e25fa-478">If there is more than one such type, the type declared within the more derived type is selected.</span></span> <span data-ttu-id="e25fa-479">Beachten Sie, dass Nichttyp-Member (Konstanten, Felder, Methoden, Eigenschaften, Indexer, Operatoren, Instanzkonstruktoren, Destruktoren und statische Konstruktoren) und Typmember mit einer anderen Anzahl von Typparametern ignoriert werden, wenn bestimmt wird die Bedeutung des das *Namespace_or_type_name*.</span><span class="sxs-lookup"><span data-stu-id="e25fa-479">Note that non-type members (constants, fields, methods, properties, indexers, operators, instance constructors, destructors, and static constructors) and type members with a different number of type parameters are ignored when determining the meaning of the *namespace_or_type_name*.</span></span>
    * <span data-ttu-id="e25fa-480">Wenn die vorherigen Schritte aus, klicken Sie dann für jeden Namespace nicht erfolgreich ausgeführt wurden `N`, beginnend mit dem Namespace, in dem die *Namespace_or_type_name* auftritt, die Sie den Vorgang fortsetzen, wobei für jeden einschließenden Namespace (sofern vorhanden) und endet mit dem Globaler Namespace die folgenden Schritte werden ausgewertet, bis eine Entität befindet:</span><span class="sxs-lookup"><span data-stu-id="e25fa-480">If the previous steps were unsuccessful then, for each namespace `N`, starting with the namespace in which the *namespace_or_type_name* occurs, continuing with each enclosing namespace (if any), and ending with the global namespace, the following steps are evaluated until an entity is located:</span></span>
        * <span data-ttu-id="e25fa-481">Wenn `K` ist 0 (null) und `I` ist der Name eines Namespace im `N`, klicken Sie dann:</span><span class="sxs-lookup"><span data-stu-id="e25fa-481">If `K` is zero and `I` is the name of a namespace in `N`, then:</span></span>
            * <span data-ttu-id="e25fa-482">Wenn der Speicherort, in dem die *Namespace_or_type_name* tritt auf, steht eine Namespace-Deklaration für `N` und die Namespacedeklaration enthält eine *Extern_alias_directive* oder *Using_alias_directive* , die den Namen zuordnet `I` mit einem Namespace oder Typ, der *Namespace_or_type_name* ist mehrdeutig und ein Fehler während der Kompilierung auftritt.</span><span class="sxs-lookup"><span data-stu-id="e25fa-482">If the location where the *namespace_or_type_name* occurs is enclosed by a namespace declaration for `N` and the namespace declaration contains an *extern_alias_directive* or *using_alias_directive* that associates the name `I` with a namespace or type, then the *namespace_or_type_name* is ambiguous and a compile-time error occurs.</span></span>
            * <span data-ttu-id="e25fa-483">Andernfalls die *Namespace_or_type_name* verweist auf den Namespace mit dem Namen `I` in `N`.</span><span class="sxs-lookup"><span data-stu-id="e25fa-483">Otherwise, the *namespace_or_type_name* refers to the namespace named `I` in `N`.</span></span>
        * <span data-ttu-id="e25fa-484">Andernfalls gilt: Wenn `N` enthält einen zugreifbarer Typ, der mit Namen `I` und `K`  Typparameter, klicken Sie dann:</span><span class="sxs-lookup"><span data-stu-id="e25fa-484">Otherwise, if `N` contains an accessible type having name `I` and `K` type parameters, then:</span></span>
            * <span data-ttu-id="e25fa-485">Wenn `K` ist 0 (null) und den Speicherort, in denen die *Namespace_or_type_name* tritt auf, wird durch eine Namespacedeklaration zur eingeschlossen `N` und die Namespacedeklaration enthält eine *Extern_alias_directive*  oder *Using_alias_directive* , die den Namen verknüpft `I` mit einem Namespace oder Typ, und klicken Sie dann die *Namespace_or_type_name* mehrdeutig und durch einen während der Kompilierung Fehler tritt auf.</span><span class="sxs-lookup"><span data-stu-id="e25fa-485">If `K` is zero and the location where the *namespace_or_type_name* occurs is enclosed by a namespace declaration for `N` and the namespace declaration contains an *extern_alias_directive* or *using_alias_directive* that associates the name `I` with a namespace or type, then the *namespace_or_type_name* is ambiguous and a compile-time error occurs.</span></span>
            * <span data-ttu-id="e25fa-486">Andernfalls die *Namespace_or_type_name* verweist auf den Typ mit den Argumenten angegebenen Typs erstellt.</span><span class="sxs-lookup"><span data-stu-id="e25fa-486">Otherwise, the *namespace_or_type_name* refers to the type constructed with the given type arguments.</span></span>
        * <span data-ttu-id="e25fa-487">Andernfalls gilt: Wenn der Speicherort, in dem die *Namespace_or_type_name* tritt auf, wird durch eine Namespacedeklaration zur eingeschlossen `N`:</span><span class="sxs-lookup"><span data-stu-id="e25fa-487">Otherwise, if the location where the *namespace_or_type_name* occurs is enclosed by a namespace declaration for `N`:</span></span>
            * <span data-ttu-id="e25fa-488">Wenn `K` ist 0 (null) und die Namespacedeklaration enthält eine *Extern_alias_directive* oder *Using_alias_directive* , die den Namen verknüpft `I` mit einem importierten Namespace oder Der Typ, und klicken Sie dann die *Namespace_or_type_name* bezieht sich auf diesen Namespace oder Typ.</span><span class="sxs-lookup"><span data-stu-id="e25fa-488">If `K` is zero and the namespace declaration contains an *extern_alias_directive* or *using_alias_directive* that associates the name `I` with an imported namespace or type, then the *namespace_or_type_name* refers to that namespace or type.</span></span>
            * <span data-ttu-id="e25fa-489">Andernfalls, wenn die Deklarationen für Namespaces und importiert die *Using_namespace_directive*s und *Using_alias_directive*s der Namespacedeklaration enthalten genau ein zugreifbarer Typ mit Namen `I` und `K`  Typparameter, und klicken Sie dann die *Namespace_or_type_name* bezieht sich auf diesen Typ mit den Argumenten angegebenen Typs erstellt.</span><span class="sxs-lookup"><span data-stu-id="e25fa-489">Otherwise, if the namespaces and type declarations imported by the *using_namespace_directive*s and *using_alias_directive*s of the namespace declaration contain exactly one accessible type having name `I` and `K` type parameters, then the *namespace_or_type_name* refers to that type constructed with the given type arguments.</span></span>
            * <span data-ttu-id="e25fa-490">Andernfalls, wenn die Deklarationen für Namespaces und importiert die *Using_namespace_directive*s und *Using_alias_directive*s der Namespacedeklaration enthalten mehr als ein zugreifbarer Typ mit Namen `I` und `K`  Typparameter, und klicken Sie dann die *Namespace_or_type_name* ist mehrdeutig und ein Fehler auftritt.</span><span class="sxs-lookup"><span data-stu-id="e25fa-490">Otherwise, if the namespaces and type declarations imported by the *using_namespace_directive*s and *using_alias_directive*s of the namespace declaration contain more than one accessible type having name `I` and `K` type parameters, then the *namespace_or_type_name* is ambiguous and an error occurs.</span></span>
    * <span data-ttu-id="e25fa-491">Andernfalls die *Namespace_or_type_name* ist nicht definiert und ein Fehler während der Kompilierung auftritt.</span><span class="sxs-lookup"><span data-stu-id="e25fa-491">Otherwise, the *namespace_or_type_name* is undefined and a compile-time error occurs.</span></span>
*  <span data-ttu-id="e25fa-492">Andernfalls die *Namespace_or_type_name* hat das Format `N.I` oder des Formulars `N.I<A1, ..., Ak>`.</span><span class="sxs-lookup"><span data-stu-id="e25fa-492">Otherwise, the *namespace_or_type_name* is of the form `N.I` or of the form `N.I<A1, ..., Ak>`.</span></span> <span data-ttu-id="e25fa-493">`N` wird zuerst aufgelöst, als eine *Namespace_or_type_name*.</span><span class="sxs-lookup"><span data-stu-id="e25fa-493">`N` is first resolved as a *namespace_or_type_name*.</span></span> <span data-ttu-id="e25fa-494">Wenn die Auflösung der `N` nicht erfolgreich ist, tritt ein Fehler während der Kompilierung.</span><span class="sxs-lookup"><span data-stu-id="e25fa-494">If the resolution of `N` is not successful, a compile-time error occurs.</span></span> <span data-ttu-id="e25fa-495">Andernfalls `N.I` oder `N.I<A1, ..., Ak>` wird wie folgt aufgelöst:</span><span class="sxs-lookup"><span data-stu-id="e25fa-495">Otherwise, `N.I` or `N.I<A1, ..., Ak>` is resolved as follows:</span></span>
    * <span data-ttu-id="e25fa-496">Wenn `K` ist 0 (null) und `N` bezieht sich auf einen Namespace und `N` enthält einen geschachtelten Namespace mit dem Namen `I`, und klicken Sie dann die *Namespace_or_type_name* bezieht sich auf diesen geschachtelten Namespace.</span><span class="sxs-lookup"><span data-stu-id="e25fa-496">If `K` is zero and `N` refers to a namespace and `N` contains a nested namespace with name `I`, then the *namespace_or_type_name* refers to that nested namespace.</span></span>
    * <span data-ttu-id="e25fa-497">Andernfalls gilt: Wenn `N` bezieht sich auf einen Namespace und `N` enthält einen zugreifbarer Typ mit dem Namen `I` und `K`  Typparameter, und klicken Sie dann die *Namespace_or_type_name* verweist in diesen Typ, der mit den Argumenten angegebenen Typs erstellt wird.</span><span class="sxs-lookup"><span data-stu-id="e25fa-497">Otherwise, if `N` refers to a namespace and `N` contains an accessible type having name `I` and `K` type parameters, then the *namespace_or_type_name* refers to that type constructed with the given type arguments.</span></span>
    * <span data-ttu-id="e25fa-498">Andernfalls gilt: Wenn `N` bezieht sich auf einen (möglicherweise konstruierten) Klasse oder Struktur-Typ und `N` oder der zugehörigen Basisklassen enthält einen geschachtelte zugreifbarer Typ mit Namen `I` und `K`  Geben Sie Parameter, und klicken Sie dann auf die *Namespace_or_type_name* bezieht sich auf diesen Typ mit den Argumenten angegebenen Typs erstellt.</span><span class="sxs-lookup"><span data-stu-id="e25fa-498">Otherwise, if `N` refers to a (possibly constructed) class or struct type and `N` or any of its base classes contain a nested accessible type having name `I` and `K` type parameters, then the *namespace_or_type_name* refers to that type constructed with the given type arguments.</span></span> <span data-ttu-id="e25fa-499">Wenn mehr als ein solcher Typ vorhanden ist, wird die in den stärker abgeleiteten Typ deklarierte Typ ausgewählt.</span><span class="sxs-lookup"><span data-stu-id="e25fa-499">If there is more than one such type, the type declared within the more derived type is selected.</span></span> <span data-ttu-id="e25fa-500">Beachten Sie, wenn die Bedeutung der `N.I` als Teil des Abschlusses der Basisklasse-Spezifikation, der bestimmt wird `N` klicken Sie dann die direkte Basisklasse von `N` Objekt gilt ([Basisklassen](classes.md#base-classes)).</span><span class="sxs-lookup"><span data-stu-id="e25fa-500">Note that if the meaning of `N.I` is being determined as part of resolving the base class specification of `N` then the direct base class of `N` is considered to be object ([Base classes](classes.md#base-classes)).</span></span>
    * <span data-ttu-id="e25fa-501">Andernfalls `N.I` ist ein ungültiger *Namespace_or_type_name*, und ein Fehler während der Kompilierung auftritt.</span><span class="sxs-lookup"><span data-stu-id="e25fa-501">Otherwise, `N.I` is an invalid *namespace_or_type_name*, and a compile-time error occurs.</span></span>

<span data-ttu-id="e25fa-502">Ein *Namespace_or_type_name* ist zulässig, eine statische Klasse verweisen ([statische Klassen](classes.md#static-classes)) nur, wenn</span><span class="sxs-lookup"><span data-stu-id="e25fa-502">A *namespace_or_type_name* is permitted to reference a static class ([Static classes](classes.md#static-classes)) only if</span></span>

*  <span data-ttu-id="e25fa-503">Die *Namespace_or_type_name* ist die `T` in einem *Namespace_or_type_name* des Formulars `T.I`, oder</span><span class="sxs-lookup"><span data-stu-id="e25fa-503">The *namespace_or_type_name* is the `T` in a *namespace_or_type_name* of the form `T.I`, or</span></span>
*  <span data-ttu-id="e25fa-504">Die *Namespace_or_type_name* ist die `T` in einem *Typeof_expression* ([Argumentlisten](expressions.md#argument-lists)1) des Formulars `typeof(T)`.</span><span class="sxs-lookup"><span data-stu-id="e25fa-504">The *namespace_or_type_name* is the `T` in a *typeof_expression* ([Argument lists](expressions.md#argument-lists)1) of the form `typeof(T)`.</span></span>

### <a name="fully-qualified-names"></a><span data-ttu-id="e25fa-505">Vollqualifizierte Namen</span><span class="sxs-lookup"><span data-stu-id="e25fa-505">Fully qualified names</span></span>

<span data-ttu-id="e25fa-506">Jeder Namespace und Typ verfügt über eine ***voll gekennzeichneten Namen***, den Namespace oder Typ unter anderem alle eindeutig identifiziert.</span><span class="sxs-lookup"><span data-stu-id="e25fa-506">Every namespace and type has a ***fully qualified name***, which uniquely identifies the namespace or type amongst all others.</span></span> <span data-ttu-id="e25fa-507">Der vollqualifizierte Name eines Namespace oder Typ `N` wird wie folgt bestimmt:</span><span class="sxs-lookup"><span data-stu-id="e25fa-507">The fully qualified name of a namespace or type `N` is determined as follows:</span></span>

*  <span data-ttu-id="e25fa-508">Wenn `N` ist Mitglied des globalen Namespaces, lautet der vollqualifizierte Name ist `N`.</span><span class="sxs-lookup"><span data-stu-id="e25fa-508">If `N` is a member of the global namespace, its fully qualified name is `N`.</span></span>
*  <span data-ttu-id="e25fa-509">Andernfalls lautet der vollqualifizierte Name ist `S.N`, wobei `S` ist der vollqualifizierte Name des Namespace oder Typ, in dem `N` deklariert wird.</span><span class="sxs-lookup"><span data-stu-id="e25fa-509">Otherwise, its fully qualified name is `S.N`, where `S` is the fully qualified name of the namespace or type in which `N` is declared.</span></span>

<span data-ttu-id="e25fa-510">Das heißt, der vollqualifizierte Name des `N` enthält den vollständigen hierarchische Pfad von Bezeichnern, die zu führen `N`ab, aus dem globalen Namespace.</span><span class="sxs-lookup"><span data-stu-id="e25fa-510">In other words, the fully qualified name of `N` is the complete hierarchical path of identifiers that lead to `N`, starting from the global namespace.</span></span> <span data-ttu-id="e25fa-511">Da jedes Mitglied eines Namespaces oder Typs auf einen eindeutigen Namen aufweisen muss, ergibt sich, dass es sich bei der vollqualifizierte Namen eines Namespaces oder der Typ immer eindeutig ist.</span><span class="sxs-lookup"><span data-stu-id="e25fa-511">Because every member of a namespace or type must have a unique name, it follows that the fully qualified name of a namespace or type is always unique.</span></span>

<span data-ttu-id="e25fa-512">Das folgende Beispiel zeigt mehrere Deklarationen von Namespace und Typ sowie den zugehörigen voll qualifizierten Namen.</span><span class="sxs-lookup"><span data-stu-id="e25fa-512">The example below shows several namespace and type declarations along with their associated fully qualified names.</span></span>
```csharp
class A {}                // A

namespace X               // X
{
    class B               // X.B
    {
        class C {}        // X.B.C
    }

    namespace Y           // X.Y
    {
        class D {}        // X.Y.D
    }
}

namespace X.Y             // X.Y
{
    class E {}            // X.Y.E
}
```

## <a name="automatic-memory-management"></a><span data-ttu-id="e25fa-513">Automatische Speicherverwaltung</span><span class="sxs-lookup"><span data-stu-id="e25fa-513">Automatic memory management</span></span>

<span data-ttu-id="e25fa-514">C# -Code setzt automatische Speicherverwaltung, die Entwickler von manuell zuordnen und Freigeben von den von Objekten belegten Arbeitsspeicher freigibt.</span><span class="sxs-lookup"><span data-stu-id="e25fa-514">C# employs automatic memory management, which frees developers from manually allocating and freeing the memory occupied by objects.</span></span> <span data-ttu-id="e25fa-515">Richtlinien für die automatische arbeitsspeicherverwaltung werden implementiert, indem eine ***Garbage Collector***.</span><span class="sxs-lookup"><span data-stu-id="e25fa-515">Automatic memory management policies are implemented by a ***garbage collector***.</span></span> <span data-ttu-id="e25fa-516">Der Speicher-Management-Lebenszyklus eines Objekts lautet wie folgt aus:</span><span class="sxs-lookup"><span data-stu-id="e25fa-516">The memory management life cycle of an object is as follows:</span></span>

1. <span data-ttu-id="e25fa-517">Wenn das Objekt erstellt wird, Arbeitsspeicher dafür zugeordnet wird, wird der Konstruktor ausgeführt und das Objekt wird als aktiv angesehen.</span><span class="sxs-lookup"><span data-stu-id="e25fa-517">When the object is created, memory is allocated for it, the constructor is run, and the object is considered live.</span></span>
2. <span data-ttu-id="e25fa-518">Wenn das Objekt oder einen Teil der Seite, indem alle möglichen Fortsetzung der Ausführung nicht zugegriffen werden kann, als die Ausführung von Destruktoren, das Objekt gilt als nicht mehr verwendet, und es zerstört wird.</span><span class="sxs-lookup"><span data-stu-id="e25fa-518">If the object, or any part of it, cannot be accessed by any possible continuation of execution, other than the running of destructors, the object is considered no longer in use, and it becomes eligible for destruction.</span></span> <span data-ttu-id="e25fa-519">Der C#-Compiler und der Garbage Collector können zum Analysieren von Code, um festzustellen, welche Verweise auf ein Objekt in der Zukunft verwendet werden können.</span><span class="sxs-lookup"><span data-stu-id="e25fa-519">The C# compiler and the garbage collector may choose to analyze code to determine which references to an object may be used in the future.</span></span> <span data-ttu-id="e25fa-520">Beispielsweise wenn eine lokale Variable, die im Bereich ist die einzige vorhandene Verweis auf ein Objekt, aber die lokale Variable wird nie in alle möglichen Fortsetzung der Ausführung der aktuellen Ausführung zeigen Sie im Verfahren bezeichnet, der Garbage Collector kann (aber nicht erforderlich, um) behandeln Sie das Objekt als nicht mehr verwendet.</span><span class="sxs-lookup"><span data-stu-id="e25fa-520">For instance, if a local variable that is in scope is the only existing reference to an object, but that local variable is never referred to in any possible continuation of execution from the current execution point in the procedure, the garbage collector may (but is not required to) treat the object as no longer in use.</span></span>
3. <span data-ttu-id="e25fa-521">Sobald das Objekt zerstört werden kann, Zeit Sie einige später angegeben den Destruktor ([Destruktoren](classes.md#destructors)) (sofern vorhanden) für das Objekt ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="e25fa-521">Once the object is eligible for destruction, at some unspecified later time the destructor ([Destructors](classes.md#destructors)) (if any) for the object is run.</span></span> <span data-ttu-id="e25fa-522">Unter normalen Umständen wird der Destruktor für das Objekt nur einmal ausgeführt, wenn dieses Verhalten außer Kraft gesetzt werden möglicherweise die implementierungsspezifischen APIs zulässt.</span><span class="sxs-lookup"><span data-stu-id="e25fa-522">Under normal circumstances the destructor for the object is run once only, though implementation-specific APIs may allow this behavior to be overridden.</span></span>
4. <span data-ttu-id="e25fa-523">Wenn der Destruktor für ein Objekt ausgeführt wird, wenn das Objekt oder einen Teil der Seite, von jedem möglichen Fortsetzung der Ausführung, einschließlich der Ausführung von Destruktoren, zugegriffen werden kann, gilt als das Objekt kann nicht zugegriffen werden, und das Objekt wird Garbage Collection.</span><span class="sxs-lookup"><span data-stu-id="e25fa-523">Once the destructor for an object is run, if that object, or any part of it, cannot be accessed by any possible continuation of execution, including the running of destructors, the object is considered inaccessible and the object becomes eligible for collection.</span></span>
5. <span data-ttu-id="e25fa-524">Schließlich nach der Garbage Collection, das Objekt nicht mehr frei zu einem Zeitpunkt der Garbage Collector den Speicher mit diesem Objekt verknüpft ist.</span><span class="sxs-lookup"><span data-stu-id="e25fa-524">Finally, at some time after the object becomes eligible for collection, the garbage collector frees the memory associated with that object.</span></span>

<span data-ttu-id="e25fa-525">Der Garbage Collector verwaltet Informationen über die Verwendung des Objekts und verwendet diese Informationen zum Arbeitsspeicher Entscheidungen Management, z. B. Where, im Arbeitsspeicher, um ein neu erstelltes Objekt, zu suchen, wenn ein Objekt, und wenn ein Objekt verschieben nicht mehr verwendet oder ist nicht möglich ist.</span><span class="sxs-lookup"><span data-stu-id="e25fa-525">The garbage collector maintains information about object usage, and uses this information to make memory management decisions, such as where in memory to locate a newly created object, when to relocate an object, and when an object is no longer in use or inaccessible.</span></span>

<span data-ttu-id="e25fa-526">Wie andere Sprachen, die das Vorhandensein eines Garbage Collectors wird davon ausgegangen wird, ist C# -Code so konzipiert, dass der Garbage Collector kann eine Vielzahl von Richtlinien für die arbeitsspeicherverwaltung implementieren.</span><span class="sxs-lookup"><span data-stu-id="e25fa-526">Like other languages that assume the existence of a garbage collector, C# is designed so that the garbage collector may implement a wide range of memory management policies.</span></span> <span data-ttu-id="e25fa-527">Z. B. erfordert C# keine Destruktoren ausgeführt werden oder, dass Objekte gesammelt werden, sobald sie berechtigt sind, oder dass Destruktoren in einer bestimmten Reihenfolge oder in einem bestimmten Thread ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="e25fa-527">For instance, C# does not require that destructors be run or that objects be collected as soon as they are eligible, or that destructors be run in any particular order, or on any particular thread.</span></span>

<span data-ttu-id="e25fa-528">Das Verhalten des Garbage Collectors kann gesteuert werden, und zu einem gewissen Grad über statische Methoden für die Klasse `System.GC`.</span><span class="sxs-lookup"><span data-stu-id="e25fa-528">The behavior of the garbage collector can be controlled, to some degree, via static methods on the class `System.GC`.</span></span> <span data-ttu-id="e25fa-529">Diese Klasse kann verwendet werden, um die Anforderung einer Auflistung, die auftreten, Destruktoren führen (oder nicht ausgeführt werden), und so weiter.</span><span class="sxs-lookup"><span data-stu-id="e25fa-529">This class can be used to request a collection to occur, destructors to be run (or not run), and so forth.</span></span>

<span data-ttu-id="e25fa-530">Da der Garbage Collector entscheiden, wann Objekte sammeln, und führen die Destruktoren zulässig ist, kann keine entsprechende Implementierung Ergebnis liefern, die unterscheidet sich von dem durch den folgenden Code gezeigt.</span><span class="sxs-lookup"><span data-stu-id="e25fa-530">Since the garbage collector is allowed wide latitude in deciding when to collect objects and run destructors, a conforming implementation may produce output that differs from that shown by the following code.</span></span> <span data-ttu-id="e25fa-531">Das Programm</span><span class="sxs-lookup"><span data-stu-id="e25fa-531">The program</span></span>
```csharp
using System;

class A
{
    ~A() {
        Console.WriteLine("Destruct instance of A");
    }
}

class B
{
    object Ref;

    public B(object o) {
        Ref = o;
    }

    ~B() {
        Console.WriteLine("Destruct instance of B");
    }
}

class Test
{
    static void Main() {
        B b = new B(new A());
        b = null;
        GC.Collect();
        GC.WaitForPendingFinalizers();
    }
}
```
<span data-ttu-id="e25fa-532">erstellt eine Instanz der Klasse `A` und eine Instanz dieser Klasse `B`.</span><span class="sxs-lookup"><span data-stu-id="e25fa-532">creates an instance of class `A` and an instance of class `B`.</span></span> <span data-ttu-id="e25fa-533">Diese Objekte werden für die Garbagecollection bei der die Variable `b` wird der Wert zugewiesen `null`, da nach dieser Zeit es für jeden Benutzer erstellter Code für den Zugriff darauf nicht möglich ist.</span><span class="sxs-lookup"><span data-stu-id="e25fa-533">These objects become eligible for garbage collection when the variable `b` is assigned the value `null`, since after this time it is impossible for any user-written code to access them.</span></span> <span data-ttu-id="e25fa-534">Die Ausgabe kann entweder sein.</span><span class="sxs-lookup"><span data-stu-id="e25fa-534">The output could be either</span></span>
```
Destruct instance of A
Destruct instance of B
```
<span data-ttu-id="e25fa-535">oder</span><span class="sxs-lookup"><span data-stu-id="e25fa-535">or</span></span>
```
Destruct instance of B
Destruct instance of A
```
<span data-ttu-id="e25fa-536">Da die Sprache keine Einschränkungen hinsichtlich der Reihenfolge erzwungen, in dem Objekte die Garbage Collection bereinigt werden.</span><span class="sxs-lookup"><span data-stu-id="e25fa-536">because the language imposes no constraints on the order in which objects are garbage collected.</span></span>

<span data-ttu-id="e25fa-537">In Fällen feine kann der Unterschied zwischen "für die Zerstörung geeignet" und "Garbage Collection" wichtig sein.</span><span class="sxs-lookup"><span data-stu-id="e25fa-537">In subtle cases, the distinction between "eligible for destruction" and "eligible for collection" can be important.</span></span> <span data-ttu-id="e25fa-538">Ein auf ein Objekt angewendeter</span><span class="sxs-lookup"><span data-stu-id="e25fa-538">For example,</span></span>
```csharp
using System;

class A
{
    ~A() {
        Console.WriteLine("Destruct instance of A");
    }

    public void F() {
        Console.WriteLine("A.F");
        Test.RefA = this;
    }
}

class B
{
    public A Ref;

    ~B() {
        Console.WriteLine("Destruct instance of B");
        Ref.F();
    }
}

class Test
{
    public static A RefA;
    public static B RefB;

    static void Main() {
        RefB = new B();
        RefA = new A();
        RefB.Ref = RefA;
        RefB = null;
        RefA = null;

        // A and B now eligible for destruction
        GC.Collect();
        GC.WaitForPendingFinalizers();

        // B now eligible for collection, but A is not
        if (RefA != null)
            Console.WriteLine("RefA is not null");
    }
}
```

<span data-ttu-id="e25fa-539">Im oben genannten-Programm, wenn der Garbage Collector auswählt, den Destruktor der auszuführenden `A` vor dem Destruktor der `B`, und klicken Sie dann die Ausgabe dieses Programms sein könnte:</span><span class="sxs-lookup"><span data-stu-id="e25fa-539">In the above program, if the garbage collector chooses to run the destructor of `A` before the destructor of `B`, then the output of this program might be:</span></span>
```
Destruct instance of A
Destruct instance of B
A.F
RefA is not null
```

<span data-ttu-id="e25fa-540">Beachten Sie, dass, obwohl die Instanz von `A` war nicht verwendet und `A`der Destruktor ausgeführt wurde, kann aber dennoch für Methoden des `A` (in diesem Fall `F`), die von einem anderen Destruktor aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="e25fa-540">Note that although the instance of `A` was not in use and `A`'s destructor was run, it is still possible for methods of `A` (in this case, `F`) to be called from another destructor.</span></span> <span data-ttu-id="e25fa-541">Beachten Sie, dass die Ausführung von einem Destruktor ein Objekt, aus dem hauptbranch Programm wieder verwendbar führen kann.</span><span class="sxs-lookup"><span data-stu-id="e25fa-541">Also, note that running of a destructor may cause an object to become usable from the mainline program again.</span></span> <span data-ttu-id="e25fa-542">In diesem Fall ist die Ausführung von `B`der Destruktor aufgrund einer Instanz von `A` , wurde zuvor nicht in Gebrauch von der aktiven Verweis zugegriffen werden kann `Test.RefA`.</span><span class="sxs-lookup"><span data-stu-id="e25fa-542">In this case, the running of `B`'s destructor caused an instance of `A` that was previously not in use to become accessible from the live reference `Test.RefA`.</span></span> <span data-ttu-id="e25fa-543">Nach dem Aufruf von `WaitForPendingFinalizers`, die Instanz von `B` ist für die Sammlung, doch die Instanz von geeignet `A` ist aufgrund der Verweis nicht, `Test.RefA`.</span><span class="sxs-lookup"><span data-stu-id="e25fa-543">After the call to `WaitForPendingFinalizers`, the instance of `B` is eligible for collection, but the instance of `A` is not, because of the reference `Test.RefA`.</span></span>

<span data-ttu-id="e25fa-544">Um Verwirrung und unerwartetes Verhalten zu vermeiden, ist es im Allgemeinen eine gute Idee für Destruktoren, nur auszuführen, Cleanup für Daten in die Felder des Objekts und nicht für alle Aktionen auf Objekte verwiesen wird, oder statische Felder.</span><span class="sxs-lookup"><span data-stu-id="e25fa-544">To avoid confusion and unexpected behavior, it is generally a good idea for destructors to only perform cleanup on data stored in their object's own fields, and not to perform any actions on referenced objects or static fields.</span></span>

<span data-ttu-id="e25fa-545">Eine Alternative zum Verwenden von Destruktoren-besteht darin, dass eine Klasse implementiert die `System.IDisposable` Schnittstelle.</span><span class="sxs-lookup"><span data-stu-id="e25fa-545">An alternative to using destructors is to let a class implement the `System.IDisposable` interface.</span></span> <span data-ttu-id="e25fa-546">Dies ermöglicht dem Client des Objekts zu bestimmen, wann die Ressourcen des Objekts, in der Regel freigegeben wird, durch den Zugriff auf das Objekt als Ressource in einem `using` Anweisung ([die using-Anweisung](statements.md#the-using-statement)).</span><span class="sxs-lookup"><span data-stu-id="e25fa-546">This allows the client of the object to determine when to release the resources of the object, typically by accessing the object as a resource in a `using` statement ([The using statement](statements.md#the-using-statement)).</span></span>

## <a name="execution-order"></a><span data-ttu-id="e25fa-547">Ausführungsreihenfolge</span><span class="sxs-lookup"><span data-stu-id="e25fa-547">Execution order</span></span>

<span data-ttu-id="e25fa-548">Ausführung eines C#-Programms wird fortgesetzt, die Nebeneffekte für jeden ausgeführten Thread an Ausführungspunkten, kritische beibehalten werden.</span><span class="sxs-lookup"><span data-stu-id="e25fa-548">Execution of a C# program proceeds such that the side effects of each executing thread are preserved at critical execution points.</span></span> <span data-ttu-id="e25fa-549">Ein ***Nebeneffekt*** ist definiert als ein Lese- oder Schreibvorgang eines flüchtigen Felds, das Schreiben in einen nicht flüchtigen Variablen, die das Schreiben in eine externe Ressource, und das Auslösen einer Ausnahme.</span><span class="sxs-lookup"><span data-stu-id="e25fa-549">A ***side effect*** is defined as a read or write of a volatile field, a write to a non-volatile variable, a write to an external resource, and the throwing of an exception.</span></span> <span data-ttu-id="e25fa-550">Die kritische Ausführungspunkte, an dem die Reihenfolge der diese Nebenwirkungen beibehalten werden muss, werden Verweise auf flüchtige Felder ([flüchtige Felder](classes.md#volatile-fields)), `lock` Anweisungen ([die sperranweisung](statements.md#the-lock-statement)), und Threaderstellung und-Beendung.</span><span class="sxs-lookup"><span data-stu-id="e25fa-550">The critical execution points at which the order of these side effects must be preserved are references to volatile fields ([Volatile fields](classes.md#volatile-fields)), `lock` statements ([The lock statement](statements.md#the-lock-statement)), and thread creation and termination.</span></span> <span data-ttu-id="e25fa-551">Die ausführungsumgebung kann so ändern Sie die Reihenfolge der Ausführung eines C#-Programms, gelten die folgenden Einschränkungen:</span><span class="sxs-lookup"><span data-stu-id="e25fa-551">The execution environment is free to change the order of execution of a C# program, subject to the following constraints:</span></span>

*  <span data-ttu-id="e25fa-552">Abhängigkeit von Daten wird in einem Thread der Ausführung beibehalten.</span><span class="sxs-lookup"><span data-stu-id="e25fa-552">Data dependence is preserved within a thread of execution.</span></span> <span data-ttu-id="e25fa-553">D.h., wird der Wert der einzelnen Variablen berechnet, als ob alle Anweisungen im Thread in der ursprünglichen programmreihenfolge ausgeführt wurden.</span><span class="sxs-lookup"><span data-stu-id="e25fa-553">That is, the value of each variable is computed as if all statements in the thread were executed in original program order.</span></span>
*  <span data-ttu-id="e25fa-554">Initialisierung Sortierung Regeln bleiben erhalten ([Feld Initialisierung](classes.md#field-initialization) und [Variableninitialisierern](classes.md#variable-initializers)).</span><span class="sxs-lookup"><span data-stu-id="e25fa-554">Initialization ordering rules are preserved ([Field initialization](classes.md#field-initialization) and [Variable initializers](classes.md#variable-initializers)).</span></span>
*  <span data-ttu-id="e25fa-555">Die Sortierung von Nebenwirkungen in Bezug auf flüchtige Lese- und Schreibvorgänge beibehalten wird ([flüchtige Felder](classes.md#volatile-fields)).</span><span class="sxs-lookup"><span data-stu-id="e25fa-555">The ordering of side effects is preserved with respect to volatile reads and writes ([Volatile fields](classes.md#volatile-fields)).</span></span> <span data-ttu-id="e25fa-556">Darüber hinaus muss die ausführungsumgebung nicht Teil des Ausdrucks ausgewertet, wenn es ableiten kann, dass der Wert des Ausdrucks nicht verwendet wird und keine erforderlichen Nebeneffekte erstellt werden (einschließlich durch Aufrufen einer Methode oder den Zugriff auf ein flüchtiges Feld verursacht).</span><span class="sxs-lookup"><span data-stu-id="e25fa-556">Additionally, the execution environment need not evaluate part of an expression if it can deduce that that expression's value is not used and that no needed side effects are produced (including any caused by calling a method or accessing a volatile field).</span></span> <span data-ttu-id="e25fa-557">Wenn die Ausführung des Programms durch ein asynchrones Ereignis (z. B. eine von einem anderen Thread ausgelöste Ausnahme) unterbrochen wird, ist nicht gewährleistet, dass die wahrnehmbaren Nebeneffekte in der ursprünglichen Reihenfolge der Anwendung angezeigt werden.</span><span class="sxs-lookup"><span data-stu-id="e25fa-557">When program execution is interrupted by an asynchronous event (such as an exception thrown by another thread), it is not guaranteed that the observable side effects are visible in the original program order.</span></span>
