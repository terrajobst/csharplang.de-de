---
ms.openlocfilehash: ff31585520c9090ad92893a930327112743c8e77
ms.sourcegitcommit: 892af9016b3317a8fae12d195014dc38ba51cf16
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 10/01/2019
ms.locfileid: "71704006"
---
# <a name="basic-concepts"></a><span data-ttu-id="ee99f-101">Grundlegende Konzepte</span><span class="sxs-lookup"><span data-stu-id="ee99f-101">Basic concepts</span></span>

## <a name="application-startup"></a><span data-ttu-id="ee99f-102">Anwendungsstart</span><span class="sxs-lookup"><span data-stu-id="ee99f-102">Application Startup</span></span>

<span data-ttu-id="ee99f-103">Eine Assembly, die über einen ***Einstiegspunkt*** verfügt, wird als ***Anwendung***bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="ee99f-103">An assembly that has an ***entry point*** is called an ***application***.</span></span> <span data-ttu-id="ee99f-104">Wenn eine Anwendung ausgeführt wird, wird eine neue ***Anwendungsdomäne*** erstellt.</span><span class="sxs-lookup"><span data-stu-id="ee99f-104">When an application is run, a new ***application domain*** is created.</span></span> <span data-ttu-id="ee99f-105">Mehrere verschiedene Instanziierungen einer Anwendung können gleichzeitig auf demselben Computer vorhanden sein, und jede verfügt über eine eigene Anwendungsdomäne.</span><span class="sxs-lookup"><span data-stu-id="ee99f-105">Several different instantiations of an application may exist on the same machine at the same time, and each has its own application domain.</span></span>

<span data-ttu-id="ee99f-106">Eine Anwendungsdomäne ermöglicht die Anwendungs Isolation, indem Sie als Container für den Anwendungs Zustand fungiert.</span><span class="sxs-lookup"><span data-stu-id="ee99f-106">An application domain enables application isolation by acting as a container for application state.</span></span> <span data-ttu-id="ee99f-107">Eine Anwendungsdomäne fungiert als Container und Grenze für die Typen, die in der Anwendung definiert sind, und die Klassenbibliotheken, die Sie verwendet.</span><span class="sxs-lookup"><span data-stu-id="ee99f-107">An application domain acts as a container and boundary for the types defined in the application and the class libraries it uses.</span></span> <span data-ttu-id="ee99f-108">Typen, die in eine Anwendungsdomäne geladen werden, unterscheiden sich vom gleichen Typ, der in eine andere Anwendungsdomäne geladen wurde, und Instanzen von Objekten werden nicht direkt zwischen Anwendungs Domänen freigegeben.</span><span class="sxs-lookup"><span data-stu-id="ee99f-108">Types loaded into one application domain are distinct from the same type loaded into another application domain, and instances of objects are not directly shared between application domains.</span></span> <span data-ttu-id="ee99f-109">Zum Beispiel verfügt jede Anwendungsdomäne über eine eigene Kopie statischer Variablen für diese Typen, und ein statischer Konstruktor für einen Typ wird höchstens einmal pro Anwendungsdomäne ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="ee99f-109">For instance, each application domain has its own copy of static variables for these types, and a static constructor for a type is run at most once per application domain.</span></span> <span data-ttu-id="ee99f-110">Implementierungen können mit Implementierungs spezifischen Richtlinien oder Mechanismen für die Erstellung und Zerstörung von Anwendungs Domänen bereitgestellt werden.</span><span class="sxs-lookup"><span data-stu-id="ee99f-110">Implementations are free to provide implementation-specific policy or mechanisms for the creation and destruction of application domains.</span></span>

<span data-ttu-id="ee99f-111">Der ***Anwendungsstart*** erfolgt, wenn die Ausführungsumgebung eine bestimmte Methode aufruft, die als Einstiegspunkt der Anwendung bezeichnet wird.</span><span class="sxs-lookup"><span data-stu-id="ee99f-111">***Application startup*** occurs when the execution environment calls a designated method, which is referred to as the application's entry point.</span></span> <span data-ttu-id="ee99f-112">Diese Einstiegspunkt Methode heißt immer `Main` und kann eine der folgenden Signaturen aufweisen:</span><span class="sxs-lookup"><span data-stu-id="ee99f-112">This entry point method is always named `Main`, and can have one of the following signatures:</span></span>

```csharp
static void Main() {...}

static void Main(string[] args) {...}

static int Main() {...}

static int Main(string[] args) {...}
```

<span data-ttu-id="ee99f-113">Wie gezeigt, kann der Einstiegspunkt optional einen `int`-Wert zurückgeben.</span><span class="sxs-lookup"><span data-stu-id="ee99f-113">As shown, the entry point may optionally return an `int` value.</span></span> <span data-ttu-id="ee99f-114">Dieser Rückgabewert wird beim Beenden der Anwendung ([Beendigung der Anwendung](basic-concepts.md#application-termination)) verwendet.</span><span class="sxs-lookup"><span data-stu-id="ee99f-114">This return value is used in application termination ([Application termination](basic-concepts.md#application-termination)).</span></span>

<span data-ttu-id="ee99f-115">Der Einstiegspunkt kann optional einen formalen Parameter aufweisen.</span><span class="sxs-lookup"><span data-stu-id="ee99f-115">The entry point may optionally have one formal parameter.</span></span> <span data-ttu-id="ee99f-116">Der-Parameter kann einen beliebigen Namen haben, aber der Typ des Parameters muss `string[]` sein.</span><span class="sxs-lookup"><span data-stu-id="ee99f-116">The parameter may have any name, but the type of the parameter must be `string[]`.</span></span> <span data-ttu-id="ee99f-117">Wenn der formale Parameter vorhanden ist, erstellt und übergibt die Ausführungsumgebung ein `string[]`-Argument, das die Befehlszeilenargumente enthält, die beim Starten der Anwendung angegeben wurden.</span><span class="sxs-lookup"><span data-stu-id="ee99f-117">If the formal parameter is present, the execution environment creates and passes a `string[]` argument containing the command-line arguments that were specified when the application was started.</span></span> <span data-ttu-id="ee99f-118">Das `string[]`-Argument ist nie NULL, kann jedoch eine Länge von 0 (null) aufweisen, wenn keine Befehlszeilenargumente angegeben wurden.</span><span class="sxs-lookup"><span data-stu-id="ee99f-118">The `string[]` argument is never null, but it may have a length of zero if no command-line arguments were specified.</span></span>

<span data-ttu-id="ee99f-119">Da C# das Überladen von Methoden unterstützt, kann eine Klasse oder Struktur mehrere Definitionen einer Methode enthalten, vorausgesetzt, jede hat eine andere Signatur.</span><span class="sxs-lookup"><span data-stu-id="ee99f-119">Since C# supports method overloading, a class or struct may contain multiple definitions of some method, provided each has a different signature.</span></span> <span data-ttu-id="ee99f-120">Allerdings kann in einem einzelnen Programm keine Klasse oder Struktur mehr als eine Methode mit dem Namen "`Main`" enthalten, deren Definition die Verwendung als Anwendungs Einstiegspunkt qualifiziert.</span><span class="sxs-lookup"><span data-stu-id="ee99f-120">However, within a single program, no class or struct may contain more than one method called `Main` whose definition qualifies it to be used as an application entry point.</span></span> <span data-ttu-id="ee99f-121">Andere überladene Versionen von `Main` sind jedoch zulässig, vorausgesetzt, Sie verfügen über mehr als einen Parameter, oder der einzige Parameter ist ein anderer Parameter als der Typ `string[]`.</span><span class="sxs-lookup"><span data-stu-id="ee99f-121">Other overloaded versions of `Main` are permitted, however, provided they have more than one parameter, or their only parameter is other than type `string[]`.</span></span>

<span data-ttu-id="ee99f-122">Eine Anwendung kann aus mehreren Klassen oder Strukturen bestehen.</span><span class="sxs-lookup"><span data-stu-id="ee99f-122">An application can be made up of multiple classes or structs.</span></span> <span data-ttu-id="ee99f-123">Es ist möglich, dass mehr als eine dieser Klassen oder Strukturen eine Methode namens "`Main`" enthalten, deren Definition die Verwendung als Anwendungs Einstiegspunkt qualifiziert.</span><span class="sxs-lookup"><span data-stu-id="ee99f-123">It is possible for more than one of these classes or structs to contain a method called `Main` whose definition qualifies it to be used as an application entry point.</span></span> <span data-ttu-id="ee99f-124">In solchen Fällen muss ein externer Mechanismus (z. b. eine Befehlszeilen-Compileroption) verwendet werden, um eine dieser `Main`-Methoden als Einstiegspunkt auszuwählen.</span><span class="sxs-lookup"><span data-stu-id="ee99f-124">In such cases, an external mechanism (such as a command-line compiler option) must be used to select one of these `Main` methods as the entry point.</span></span>

<span data-ttu-id="ee99f-125">In C#muss jede Methode als Member einer Klasse oder Struktur definiert werden.</span><span class="sxs-lookup"><span data-stu-id="ee99f-125">In C#, every method must be defined as a member of a class or struct.</span></span> <span data-ttu-id="ee99f-126">Normalerweise wird die deklarierte Barrierefreiheit (der[deklarierte](basic-concepts.md#declared-accessibility)Zugriff) einer Methode durch die Zugriffsmodifizierer ([Zugriffsmodifizierer](classes.md#access-modifiers)) bestimmt, die in der Deklaration angegeben sind, und auf ähnliche Weise wird die deklarierte Barrierefreiheit eines Typs in der Deklaration angegebene Zugriffsmodifizierer</span><span class="sxs-lookup"><span data-stu-id="ee99f-126">Ordinarily, the declared accessibility ([Declared accessibility](basic-concepts.md#declared-accessibility)) of a method is determined by the access modifiers ([Access modifiers](classes.md#access-modifiers)) specified in its declaration, and similarly the declared accessibility of a type is determined by the access modifiers specified in its declaration.</span></span> <span data-ttu-id="ee99f-127">Damit eine bestimmte Methode eines bestimmten Typs aufgerufen werden kann, muss der Zugriff auf den Typ und den Member möglich sein.</span><span class="sxs-lookup"><span data-stu-id="ee99f-127">In order for a given method of a given type to be callable, both the type and the member must be accessible.</span></span> <span data-ttu-id="ee99f-128">Der Einstiegspunkt der Anwendung ist jedoch ein Sonderfall.</span><span class="sxs-lookup"><span data-stu-id="ee99f-128">However, the application entry point is a special case.</span></span> <span data-ttu-id="ee99f-129">Insbesondere kann die Ausführungsumgebung auf den Einstiegspunkt der Anwendung zugreifen, unabhängig von der deklarierten Barrierefreiheit und unabhängig von der deklarierten Barrierefreiheit ihrer einschließenden Typdeklarationen.</span><span class="sxs-lookup"><span data-stu-id="ee99f-129">Specifically, the execution environment can access the application's entry point regardless of its declared accessibility and regardless of the declared accessibility of its enclosing type declarations.</span></span>

<span data-ttu-id="ee99f-130">Die Einstiegspunkt Methode der Anwendung darf sich nicht in einer generischen Klassen Deklaration befinden.</span><span class="sxs-lookup"><span data-stu-id="ee99f-130">The application entry point method may not be in a generic class declaration.</span></span>

<span data-ttu-id="ee99f-131">In allen anderen Punkten verhalten sich Einstiegspunkt Methoden wie solche, die keine Einstiegspunkte sind.</span><span class="sxs-lookup"><span data-stu-id="ee99f-131">In all other respects, entry point methods behave like those that are not entry points.</span></span>

## <a name="application-termination"></a><span data-ttu-id="ee99f-132">Beenden der Anwendung</span><span class="sxs-lookup"><span data-stu-id="ee99f-132">Application termination</span></span>

<span data-ttu-id="ee99f-133">Beim Beenden der ***Anwendung*** wird die Steuerung an die Ausführungsumgebung zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="ee99f-133">***Application termination*** returns control to the execution environment.</span></span>

<span data-ttu-id="ee99f-134">Wenn der Rückgabetyp der ***Einstiegspunkt*** Methode der Anwendung `int` ist, fungiert der zurückgegebene Wert als Beendigungs ***Statuscode***der Anwendung.</span><span class="sxs-lookup"><span data-stu-id="ee99f-134">If the return type of the application's ***entry point*** method is `int`, the value returned serves as the application's ***termination status code***.</span></span> <span data-ttu-id="ee99f-135">Der Zweck dieses Codes besteht darin, die Kommunikation über Erfolg oder Misserfolg der Ausführungsumgebung zuzulassen.</span><span class="sxs-lookup"><span data-stu-id="ee99f-135">The purpose of this code is to allow communication of success or failure to the execution environment.</span></span>

<span data-ttu-id="ee99f-136">Wenn der Rückgabetyp der Einstiegspunkt Methode `void` ist und die Rechte geschweifter Klammer (`}`) erreicht wird, die diese Methode beendet oder eine `return`-Anweisung ausführt, die keinen Ausdruck aufweist, wird der Beendigungs Statuscode `0` angezeigt.</span><span class="sxs-lookup"><span data-stu-id="ee99f-136">If the return type of the entry point method is `void`, reaching the right brace (`}`) which terminates that method, or executing a `return` statement that has no expression, results in a termination status code of `0`.</span></span>

<span data-ttu-id="ee99f-137">Vor dem Beenden einer Anwendung werden debugtoren für alle Objekte, die noch keine Garbage Collection durchgeführt haben, aufgerufen, es sei denn, eine solche Bereinigung wurde unterdrückt (z. b. durch einen Aufruf der Bibliotheks Methode `GC.SuppressFinalize`).</span><span class="sxs-lookup"><span data-stu-id="ee99f-137">Prior to an application's termination, destructors for all of its objects that have not yet been garbage collected are called, unless such cleanup has been suppressed (by a call to the library method `GC.SuppressFinalize`, for example).</span></span>

## <a name="declarations"></a><span data-ttu-id="ee99f-138">Deklarationen</span><span class="sxs-lookup"><span data-stu-id="ee99f-138">Declarations</span></span>

<span data-ttu-id="ee99f-139">Deklarationen in C# einem Programm definieren die Bestandteile des Programms.</span><span class="sxs-lookup"><span data-stu-id="ee99f-139">Declarations in a C# program define the constituent elements of the program.</span></span> <span data-ttu-id="ee99f-140">C#Programme werden mithilfe von Namespaces ([Namespaces](namespaces.md)) organisiert, die Typdeklarationen und schsted Namespace Deklarationen enthalten können.</span><span class="sxs-lookup"><span data-stu-id="ee99f-140">C# programs are organized using namespaces ([Namespaces](namespaces.md)), which can contain type declarations and nested namespace declarations.</span></span> <span data-ttu-id="ee99f-141">Typdeklarationen ([Typdeklarationen](namespaces.md#type-declarations)) werden verwendet, um Klassen ([Klassen](classes.md)), Strukturen ([Strukturen](structs.md)), Schnittstellen ([Schnittstellen](interfaces.md)), Enumerationen ([Enumerationen](enums.md)) und Delegaten ([Delegaten)](delegates.md) zu definieren.</span><span class="sxs-lookup"><span data-stu-id="ee99f-141">Type declarations ([Type declarations](namespaces.md#type-declarations)) are used to define classes ([Classes](classes.md)), structs ([Structs](structs.md)), interfaces ([Interfaces](interfaces.md)), enums ([Enums](enums.md)), and delegates ([Delegates](delegates.md)).</span></span> <span data-ttu-id="ee99f-142">Die Arten von Membern, die in einer Typdeklaration zulässig sind, hängen von der Form der Typdeklaration ab.</span><span class="sxs-lookup"><span data-stu-id="ee99f-142">The kinds of members permitted in a type declaration depend on the form of the type declaration.</span></span> <span data-ttu-id="ee99f-143">Klassen Deklarationen können z. a. Deklarationen für Konstanten ([Konstanten](classes.md#constants)), Felder ([Felder](classes.md#fields)), Methoden ([Methoden](classes.md#methods)), Eigenschaften ([Eigenschaften](classes.md#properties)), Ereignisse ([Ereignisse](classes.md#events)), Indexer ([Indexer](classes.md#indexers)) enthalten, Operatoren[(Operatoren](classes.md#operators)), Instanzkonstruktoren ([Instanzkonstruktoren](classes.md#instance-constructors)), statische Konstruktoren ([statische Konstruktoren](classes.md#static-constructors)), Dekonstruktoren ([Dekonstruktoren](classes.md#destructors)) und geclusterte Typen ([geclusterte Typen](classes.md#nested-types)).</span><span class="sxs-lookup"><span data-stu-id="ee99f-143">For instance, class declarations can contain declarations for constants ([Constants](classes.md#constants)), fields ([Fields](classes.md#fields)), methods ([Methods](classes.md#methods)), properties ([Properties](classes.md#properties)), events ([Events](classes.md#events)), indexers ([Indexers](classes.md#indexers)), operators ([Operators](classes.md#operators)), instance constructors ([Instance constructors](classes.md#instance-constructors)), static constructors ([Static constructors](classes.md#static-constructors)), destructors ([Destructors](classes.md#destructors)), and nested types ([Nested types](classes.md#nested-types)).</span></span>

<span data-ttu-id="ee99f-144">Eine Deklaration definiert einen Namen im ***Deklarations Bereich*** , zu dem die Deklaration gehört.</span><span class="sxs-lookup"><span data-stu-id="ee99f-144">A declaration defines a name in the ***declaration space*** to which the declaration belongs.</span></span> <span data-ttu-id="ee99f-145">Mit Ausnahme überladener Elemente ([Signaturen und überladen](basic-concepts.md#signatures-and-overloading)) handelt es sich um einen Kompilierzeitfehler, der zwei oder mehr Deklarationen mit demselben Namen in einem Deklarations Raum einführt.</span><span class="sxs-lookup"><span data-stu-id="ee99f-145">Except for overloaded members ([Signatures and overloading](basic-concepts.md#signatures-and-overloading)), it is a compile-time error to have two or more declarations that introduce members with the same name in a declaration space.</span></span> <span data-ttu-id="ee99f-146">Es ist nie möglich, dass ein Deklarations Bereich unterschiedliche Arten von Membern mit dem gleichen Namen enthält.</span><span class="sxs-lookup"><span data-stu-id="ee99f-146">It is never possible for a declaration space to contain different kinds of members with the same name.</span></span> <span data-ttu-id="ee99f-147">Beispielsweise kann ein Deklarations Raum nie ein Feld und eine Methode mit demselben Namen enthalten.</span><span class="sxs-lookup"><span data-stu-id="ee99f-147">For example, a declaration space can never contain a field and a method by the same name.</span></span>

<span data-ttu-id="ee99f-148">Es gibt mehrere verschiedene Typen von Deklarations Bereichen, die im folgenden beschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="ee99f-148">There are several different types of declaration spaces, as described in the following.</span></span>

*  <span data-ttu-id="ee99f-149">Innerhalb aller Quelldateien eines Programms sind *namespace_member_declaration*s ohne einschließende *namespace_declaration* Member eines einzelnen kombinierten Deklarations Raums, der als ***globaler Deklarations Bereich***bezeichnet wird.</span><span class="sxs-lookup"><span data-stu-id="ee99f-149">Within all source files of a program, *namespace_member_declaration*s with no enclosing *namespace_declaration* are members of a single combined declaration space called the ***global declaration space***.</span></span>
*  <span data-ttu-id="ee99f-150">Innerhalb aller Quelldateien eines Programms sind *namespace_member_declaration*s innerhalb von *namespace_declaration*s, die denselben voll qualifizierten Namespace Namen aufweisen, Member eines einzelnen kombinierten Deklarations Raums.</span><span class="sxs-lookup"><span data-stu-id="ee99f-150">Within all source files of a program, *namespace_member_declaration*s within *namespace_declaration*s that have the same fully qualified namespace name are members of a single combined declaration space.</span></span>
*  <span data-ttu-id="ee99f-151">Jede Klassen-, Struktur-oder Schnittstellen Deklaration erstellt einen neuen Deklarations Bereich.</span><span class="sxs-lookup"><span data-stu-id="ee99f-151">Each class, struct, or interface declaration creates a new declaration space.</span></span> <span data-ttu-id="ee99f-152">Namen werden in diesem Deklarations Bereich durch *class_member_declaration*s, *struct_member_declaration*s, *interface_member_declaration*s oder *type_parameter*s eingeführt.</span><span class="sxs-lookup"><span data-stu-id="ee99f-152">Names are introduced into this declaration space through *class_member_declaration*s, *struct_member_declaration*s, *interface_member_declaration*s, or *type_parameter*s.</span></span> <span data-ttu-id="ee99f-153">Mit Ausnahme von überladenen Instanzkonstruktordeklarationen und statischen Konstruktordeklarationen kann eine Klasse oder Struktur keine Element Deklaration mit dem gleichen Namen wie die Klasse oder Struktur enthalten.</span><span class="sxs-lookup"><span data-stu-id="ee99f-153">Except for overloaded instance constructor declarations and static constructor declarations, a class or struct cannot contain a member declaration with the same name as the class or struct.</span></span> <span data-ttu-id="ee99f-154">Eine Klasse, Struktur oder Schnittstelle ermöglicht die Deklaration überladener Methoden und Indexer.</span><span class="sxs-lookup"><span data-stu-id="ee99f-154">A class, struct, or interface permits the declaration of overloaded methods and indexers.</span></span> <span data-ttu-id="ee99f-155">Außerdem ermöglicht eine Klasse oder Struktur die Deklaration überladener Instanzkonstruktoren und Operatoren.</span><span class="sxs-lookup"><span data-stu-id="ee99f-155">Furthermore, a class or struct permits the declaration of overloaded instance constructors and operators.</span></span> <span data-ttu-id="ee99f-156">Eine Klasse, Struktur oder Schnittstelle kann z. b. mehrere Methoden Deklarationen mit demselben Namen enthalten, sofern sich diese Methoden Deklarationen in Ihrer Signatur ([Signaturen und überladen](basic-concepts.md#signatures-and-overloading)) unterscheiden.</span><span class="sxs-lookup"><span data-stu-id="ee99f-156">For example, a class, struct, or interface may contain multiple method declarations with the same name, provided these method declarations differ in their signature ([Signatures and overloading](basic-concepts.md#signatures-and-overloading)).</span></span> <span data-ttu-id="ee99f-157">Beachten Sie, dass Basisklassen nicht zum Deklarations Bereich einer Klasse beitragen und Basis Schnittstellen nicht zum Deklarations Bereich einer Schnittstelle beitragen.</span><span class="sxs-lookup"><span data-stu-id="ee99f-157">Note that base classes do not contribute to the declaration space of a class, and base interfaces do not contribute to the declaration space of an interface.</span></span> <span data-ttu-id="ee99f-158">Daher kann eine abgeleitete Klasse oder Schnittstelle einen Member mit demselben Namen wie ein geerbten Member deklarieren.</span><span class="sxs-lookup"><span data-stu-id="ee99f-158">Thus, a derived class or interface is allowed to declare a member with the same name as an inherited member.</span></span> <span data-ttu-id="ee99f-159">Ein solcher Member gibt an, dass der geerbte Member ***ausgeblendet*** wird.</span><span class="sxs-lookup"><span data-stu-id="ee99f-159">Such a member is said to ***hide*** the inherited member.</span></span>
*  <span data-ttu-id="ee99f-160">Jede Delegatdeklaration erstellt einen neuen Deklarations Bereich.</span><span class="sxs-lookup"><span data-stu-id="ee99f-160">Each delegate declaration creates a new declaration space.</span></span> <span data-ttu-id="ee99f-161">Namen werden in diesem Deklarations Raum durch formale Parameter (*fixed_parameter*s und *parameter_array*s) und *type_parameter*s eingeführt.</span><span class="sxs-lookup"><span data-stu-id="ee99f-161">Names are introduced into this declaration space through formal parameters (*fixed_parameter*s and *parameter_array*s) and *type_parameter*s.</span></span>
*  <span data-ttu-id="ee99f-162">Jede Enumerationsdeklaration erstellt einen neuen Deklarations Bereich.</span><span class="sxs-lookup"><span data-stu-id="ee99f-162">Each enumeration declaration creates a new declaration space.</span></span> <span data-ttu-id="ee99f-163">Namen werden in diesem Deklarations Raum über *enum_member_declarations*eingeführt.</span><span class="sxs-lookup"><span data-stu-id="ee99f-163">Names are introduced into this declaration space through *enum_member_declarations*.</span></span>
*  <span data-ttu-id="ee99f-164">Jede Methoden Deklaration, Indexer-Deklaration, Operator Deklaration, Instanzkonstruktordeklaration und anonyme Funktion erstellt einen neuen Deklarations Raum, der als ***lokaler Variablen Deklarations Bereich***bezeichnet wird</span><span class="sxs-lookup"><span data-stu-id="ee99f-164">Each method declaration, indexer declaration, operator declaration, instance constructor declaration and anonymous function creates a new declaration space called a ***local variable declaration space***.</span></span> <span data-ttu-id="ee99f-165">Namen werden in diesem Deklarations Raum durch formale Parameter (*fixed_parameter*s und *parameter_array*s) und *type_parameter*s eingeführt.</span><span class="sxs-lookup"><span data-stu-id="ee99f-165">Names are introduced into this declaration space through formal parameters (*fixed_parameter*s and *parameter_array*s) and *type_parameter*s.</span></span> <span data-ttu-id="ee99f-166">Der Text des Funktionsmembers oder der anonymen Funktion wird, falls vorhanden, als geschachtelt im lokalen Variablen Deklarations Bereich betrachtet.</span><span class="sxs-lookup"><span data-stu-id="ee99f-166">The body of the function member or anonymous function, if any, is considered to be nested within the local variable declaration space.</span></span> <span data-ttu-id="ee99f-167">Es ist ein Fehler bei einem Deklarations Raum für lokale Variablen und einem in der Tabelle enthaltenen Deklarations Bereich der lokalen Variablen, der Elemente mit dem gleichen Namen enthalten soll.</span><span class="sxs-lookup"><span data-stu-id="ee99f-167">It is an error for a local variable declaration space and a nested local variable declaration space to contain elements with the same name.</span></span> <span data-ttu-id="ee99f-168">Daher ist es in einem geschachtelten Deklarations Bereich nicht möglich, eine lokale Variable oder Konstante mit dem gleichen Namen wie eine lokale Variable oder Konstante in einem einschließenden Deklarations Bereich zu deklarieren.</span><span class="sxs-lookup"><span data-stu-id="ee99f-168">Thus, within a nested declaration space it is not possible to declare a local variable or constant with the same name as a local variable or constant in an enclosing declaration space.</span></span> <span data-ttu-id="ee99f-169">Es ist möglich, dass zwei Deklarations Bereiche Elemente mit dem gleichen Namen enthalten, solange kein Deklarations Raum den anderen enthält.</span><span class="sxs-lookup"><span data-stu-id="ee99f-169">It is possible for two declaration spaces to contain elements with the same name as long as neither declaration space contains the other.</span></span>
*  <span data-ttu-id="ee99f-170">Jede *Block* -oder *switch_block* -Anweisung sowie eine *for*-, *foreach* -und *using* -Anweisung erstellt einen lokalen Variablen Deklarations Raum für lokale Variablen und lokale Konstanten.</span><span class="sxs-lookup"><span data-stu-id="ee99f-170">Each *block* or *switch_block* , as well as a *for*, *foreach* and *using* statement, creates a local variable declaration space for local variables and local constants .</span></span> <span data-ttu-id="ee99f-171">Namen werden in diesem Deklarations Bereich durch *local_variable_declaration*s und *local_constant_declaration*s eingeführt.</span><span class="sxs-lookup"><span data-stu-id="ee99f-171">Names are introduced into this declaration space through *local_variable_declaration*s and *local_constant_declaration*s.</span></span> <span data-ttu-id="ee99f-172">Beachten Sie, dass Blöcke, die als oder innerhalb des Texts eines Funktionsmembers oder einer anonymen Funktion auftreten, innerhalb des Deklarations Raums für lokale Variablen geschachtelt sind, der von diesen Funktionen für Ihre Parameter deklariert wird.</span><span class="sxs-lookup"><span data-stu-id="ee99f-172">Note that blocks that occur as or within the body of a function member or anonymous function are nested within the local variable declaration space declared by those functions for their parameters.</span></span> <span data-ttu-id="ee99f-173">Daher ist es ein Fehler, z. b. eine Methode mit einer lokalen Variablen und einem Parameter mit dem gleichen Namen zu haben.</span><span class="sxs-lookup"><span data-stu-id="ee99f-173">Thus it is an error to have e.g. a method with a local variable and a parameter of the same name.</span></span>
*  <span data-ttu-id="ee99f-174">Jeder *Block* oder *switch_block* erstellt einen separaten Deklarations Raum für Bezeichnungen.</span><span class="sxs-lookup"><span data-stu-id="ee99f-174">Each *block* or *switch_block* creates a separate declaration space for labels.</span></span> <span data-ttu-id="ee99f-175">Namen werden mit *labeled_statement*s in diesen Deklarations Bereich eingefügt, und auf die Namen wird über *goto_statement*s verwiesen.</span><span class="sxs-lookup"><span data-stu-id="ee99f-175">Names are introduced into this declaration space through *labeled_statement*s, and the names are referenced through *goto_statement*s.</span></span> <span data-ttu-id="ee99f-176">Der ***Zeichenbereich*** der Bezeichnungs Deklaration eines-Blocks enthält alle in der Liste enthaltenen Blöcke.</span><span class="sxs-lookup"><span data-stu-id="ee99f-176">The ***label declaration space*** of a block includes any nested blocks.</span></span> <span data-ttu-id="ee99f-177">Daher ist es in einem geschachtelten Block nicht möglich, eine Bezeichnung mit demselben Namen wie eine Bezeichnung in einem einschließenden Block zu deklarieren.</span><span class="sxs-lookup"><span data-stu-id="ee99f-177">Thus, within a nested block it is not possible to declare a label with the same name as a label in an enclosing block.</span></span>

<span data-ttu-id="ee99f-178">Die Text Reihenfolge, in der die Namen deklariert werden, ist im Allgemeinen nicht von Bedeutung.</span><span class="sxs-lookup"><span data-stu-id="ee99f-178">The textual order in which names are declared is generally of no significance.</span></span> <span data-ttu-id="ee99f-179">Insbesondere ist die Text Reihenfolge für die Deklaration und Verwendung von Namespaces, Konstanten, Methoden, Eigenschaften, Ereignissen, Indexern, Operatoren, Instanzkonstruktoren, Dekonstruktoren, statischen Konstruktoren und Typen nicht signifikant.</span><span class="sxs-lookup"><span data-stu-id="ee99f-179">In particular, textual order is not significant for the declaration and use of namespaces, constants, methods, properties, events, indexers, operators, instance constructors, destructors, static constructors, and types.</span></span> <span data-ttu-id="ee99f-180">Die Deklarations Reihenfolge ist wie folgt signifikant:</span><span class="sxs-lookup"><span data-stu-id="ee99f-180">Declaration order is significant in the following ways:</span></span>

*  <span data-ttu-id="ee99f-181">Die Deklarations Reihenfolge für Feld Deklarationen und lokale Variablen Deklarationen bestimmt die Reihenfolge, in der Ihre Initialisierer (sofern vorhanden) ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="ee99f-181">Declaration order for field declarations and local variable declarations determines the order in which their initializers (if any) are executed.</span></span>
*  <span data-ttu-id="ee99f-182">Lokale Variablen müssen definiert werden, bevor Sie verwendet werden ([Bereiche](basic-concepts.md#scopes)).</span><span class="sxs-lookup"><span data-stu-id="ee99f-182">Local variables must be defined before they are used ([Scopes](basic-concepts.md#scopes)).</span></span>
*  <span data-ttu-id="ee99f-183">Die Deklarations Reihenfolge für Enumerationmember-Deklarationen ([Enumeration](enums.md#enum-members)-Member) ist signifikant, wenn *constant_expression* -Werte ausgelassen</span><span class="sxs-lookup"><span data-stu-id="ee99f-183">Declaration order for enum member declarations ([Enum members](enums.md#enum-members)) is significant when *constant_expression* values are omitted.</span></span>

<span data-ttu-id="ee99f-184">Der Deklarations Bereich eines Namespaces ist "Open End", und zwei Namespace Deklarationen mit demselben voll qualifizierten Namen tragen zum selben Deklarations Bereich bei.</span><span class="sxs-lookup"><span data-stu-id="ee99f-184">The declaration space of a namespace is "open ended", and two namespace declarations with the same fully qualified name contribute to the same declaration space.</span></span> <span data-ttu-id="ee99f-185">Beispiel:</span><span class="sxs-lookup"><span data-stu-id="ee99f-185">For example</span></span>
```csharp
namespace Megacorp.Data
{
    class Customer
    {
        ...
    }
}

namespace Megacorp.Data
{
    class Order
    {
        ...
    }
}
```

<span data-ttu-id="ee99f-186">Die beiden oben genannten Namespace Deklarationen tragen zum selben Deklarations Bereich bei, in diesem Fall werden zwei Klassen mit den voll qualifizierten Namen `Megacorp.Data.Customer` und `Megacorp.Data.Order` deklariert.</span><span class="sxs-lookup"><span data-stu-id="ee99f-186">The two namespace declarations above contribute to the same declaration space, in this case declaring two classes with the fully qualified names `Megacorp.Data.Customer` and `Megacorp.Data.Order`.</span></span> <span data-ttu-id="ee99f-187">Da die beiden Deklarationen zum gleichen Deklarations Bereich beitragen, hätte Sie einen Kompilierzeitfehler verursacht, wenn jeder eine Deklaration einer Klasse mit dem gleichen Namen enthielt.</span><span class="sxs-lookup"><span data-stu-id="ee99f-187">Because the two declarations contribute to the same declaration space, it would have caused a compile-time error if each contained a declaration of a class with the same name.</span></span>

<span data-ttu-id="ee99f-188">Wie oben angegeben, enthält der Deklarations Bereich eines-Blocks alle in der Liste enthaltenen Blöcke.</span><span class="sxs-lookup"><span data-stu-id="ee99f-188">As specified above, the declaration space of a block includes any nested blocks.</span></span> <span data-ttu-id="ee99f-189">Im folgenden Beispiel führen die Methoden `F` und `G` zu einem Kompilierzeitfehler, da der Name `i` im äußeren Block deklariert wird und nicht im Inneren Block erneut deklariert werden kann.</span><span class="sxs-lookup"><span data-stu-id="ee99f-189">Thus, in the following example, the `F` and `G` methods result in a compile-time error because the name `i` is declared in the outer block and cannot be redeclared in the inner block.</span></span> <span data-ttu-id="ee99f-190">Allerdings sind die Methoden `H` und `I` gültig, da die beiden `i` in separaten nicht in-Blöcken deklarierten Blöcken deklariert werden.</span><span class="sxs-lookup"><span data-stu-id="ee99f-190">However, the `H` and `I` methods are valid since the two `i`'s are declared in separate non-nested blocks.</span></span>

```csharp
class A
{
    void F() {
        int i = 0;
        if (true) {
            int i = 1;            
        }
    }

    void G() {
        if (true) {
            int i = 0;
        }
        int i = 1;                
    }

    void H() {
        if (true) {
            int i = 0;
        }
        if (true) {
            int i = 1;
        }
    }

    void I() {
        for (int i = 0; i < 10; i++)
            H();
        for (int i = 0; i < 10; i++)
            H();
    }
}
```

## <a name="members"></a><span data-ttu-id="ee99f-191">Member</span><span class="sxs-lookup"><span data-stu-id="ee99f-191">Members</span></span>

<span data-ttu-id="ee99f-192">Namespaces und Typen verfügen über ***Mitglieder***.</span><span class="sxs-lookup"><span data-stu-id="ee99f-192">Namespaces and types have ***members***.</span></span> <span data-ttu-id="ee99f-193">Die Elemente einer Entität sind in der Regel über einen qualifizierten Namen verfügbar, der mit einem Verweis auf die Entität beginnt, gefolgt von einem "`.`"-Token, gefolgt vom Namen des Members.</span><span class="sxs-lookup"><span data-stu-id="ee99f-193">The members of an entity are generally available through the use of a qualified name that starts with a reference to the entity, followed by a "`.`" token, followed by the name of the member.</span></span>

<span data-ttu-id="ee99f-194">Member eines Typs werden entweder in der Typdeklaration deklariert oder von der Basisklasse des Typs ***geerbt*** .</span><span class="sxs-lookup"><span data-stu-id="ee99f-194">Members of a type are either declared in the type declaration or ***inherited*** from the base class of the type.</span></span> <span data-ttu-id="ee99f-195">Wenn ein Typ von einer Basisklasse erbt, werden alle Member der Basisklasse, ausgenommen Instanzkonstruktoren, destrukturtoren und statische Konstruktoren, zu Membern des abgeleiteten Typs.</span><span class="sxs-lookup"><span data-stu-id="ee99f-195">When a type inherits from a base class, all members of the base class, except instance constructors, destructors and static constructors, become members of the derived type.</span></span> <span data-ttu-id="ee99f-196">Der deklarierte Zugriff eines Basisklassenmembers steuert nicht, ob der Member geerbt wird – die Vererbung wird auf einen Member ausgedehnt, der kein Instanzkonstruktor, statischer Konstruktor oder Dekonstruktor ist.</span><span class="sxs-lookup"><span data-stu-id="ee99f-196">The declared accessibility of a base class member does not control whether the member is inherited—inheritance extends to any member that isn't an instance constructor, static constructor, or destructor.</span></span> <span data-ttu-id="ee99f-197">Es ist jedoch möglich, dass auf einen geerbten Member nicht in einem abgeleiteten Typ zugegriffen werden kann, entweder aufgrund seiner deklarierten Barrierefreiheit ([deklariert Barrierefreiheit](basic-concepts.md#declared-accessibility)) oder weil er durch eine Deklaration im Typ selbst ausgeblendet wird ([durch Vererbung verbergen](basic-concepts.md#hiding-through-inheritance)).</span><span class="sxs-lookup"><span data-stu-id="ee99f-197">However, an inherited member may not be accessible in a derived type, either because of its declared accessibility ([Declared accessibility](basic-concepts.md#declared-accessibility)) or because it is hidden by a declaration in the type itself ([Hiding through inheritance](basic-concepts.md#hiding-through-inheritance)).</span></span>

### <a name="namespace-members"></a><span data-ttu-id="ee99f-198">Namespace-Member</span><span class="sxs-lookup"><span data-stu-id="ee99f-198">Namespace members</span></span>

<span data-ttu-id="ee99f-199">Namespaces und Typen, die keinen einschließenden Namespace aufweisen, sind Member des ***globalen Namespace***.</span><span class="sxs-lookup"><span data-stu-id="ee99f-199">Namespaces and types that have no enclosing namespace are members of the ***global namespace***.</span></span> <span data-ttu-id="ee99f-200">Dies entspricht direkt den im globalen Deklarations Bereich deklarierten Namen.</span><span class="sxs-lookup"><span data-stu-id="ee99f-200">This corresponds directly to the names declared in the global declaration space.</span></span>

<span data-ttu-id="ee99f-201">Namespaces und Typen, die in einem Namespace deklariert werden, sind Member dieses Namespace.</span><span class="sxs-lookup"><span data-stu-id="ee99f-201">Namespaces and types declared within a namespace are members of that namespace.</span></span> <span data-ttu-id="ee99f-202">Dies entspricht direkt den Namen, die im Deklarations Raum des-Namespace deklariert werden.</span><span class="sxs-lookup"><span data-stu-id="ee99f-202">This corresponds directly to the names declared in the declaration space of the namespace.</span></span>

<span data-ttu-id="ee99f-203">Namespaces haben uneingeschränkten Zugriff.</span><span class="sxs-lookup"><span data-stu-id="ee99f-203">Namespaces have no access restrictions.</span></span> <span data-ttu-id="ee99f-204">Es ist nicht möglich, private, geschützte oder interne Namespaces zu deklarieren, und Namespace Namen sind immer öffentlich zugänglich.</span><span class="sxs-lookup"><span data-stu-id="ee99f-204">It is not possible to declare private, protected, or internal namespaces, and namespace names are always publicly accessible.</span></span>

### <a name="struct-members"></a><span data-ttu-id="ee99f-205">Strukturmember</span><span class="sxs-lookup"><span data-stu-id="ee99f-205">Struct members</span></span>

<span data-ttu-id="ee99f-206">Die Member einer Struktur sind die Member, die in der Struktur deklariert sind, und die Member, die von der direkten Basisklasse der Struktur geerbt wurden `System.ValueType` und die indirekte Basisklasse `object`.</span><span class="sxs-lookup"><span data-stu-id="ee99f-206">The members of a struct are the members declared in the struct and the members inherited from the struct's direct base class `System.ValueType` and the indirect base class `object`.</span></span>

<span data-ttu-id="ee99f-207">Die Member eines einfachen Typs entsprechen direkt den Membern des Struktur Typs, der durch den einfachen Typ Alias:</span><span class="sxs-lookup"><span data-stu-id="ee99f-207">The members of a simple type correspond directly to the members of the struct type aliased by the simple type:</span></span>

*  <span data-ttu-id="ee99f-208">Die Member von `sbyte` sind die Elemente der `System.SByte`-Struktur.</span><span class="sxs-lookup"><span data-stu-id="ee99f-208">The members of `sbyte` are the members of the `System.SByte` struct.</span></span>
*  <span data-ttu-id="ee99f-209">Die Member von `byte` sind die Elemente der `System.Byte`-Struktur.</span><span class="sxs-lookup"><span data-stu-id="ee99f-209">The members of `byte` are the members of the `System.Byte` struct.</span></span>
*  <span data-ttu-id="ee99f-210">Die Member von `short` sind die Elemente der `System.Int16`-Struktur.</span><span class="sxs-lookup"><span data-stu-id="ee99f-210">The members of `short` are the members of the `System.Int16` struct.</span></span>
*  <span data-ttu-id="ee99f-211">Die Member von `ushort` sind die Elemente der `System.UInt16`-Struktur.</span><span class="sxs-lookup"><span data-stu-id="ee99f-211">The members of `ushort` are the members of the `System.UInt16` struct.</span></span>
*  <span data-ttu-id="ee99f-212">Die Member von `int` sind die Elemente der `System.Int32`-Struktur.</span><span class="sxs-lookup"><span data-stu-id="ee99f-212">The members of `int` are the members of the `System.Int32` struct.</span></span>
*  <span data-ttu-id="ee99f-213">Die Member von `uint` sind die Elemente der `System.UInt32`-Struktur.</span><span class="sxs-lookup"><span data-stu-id="ee99f-213">The members of `uint` are the members of the `System.UInt32` struct.</span></span>
*  <span data-ttu-id="ee99f-214">Die Member von `long` sind die Elemente der `System.Int64`-Struktur.</span><span class="sxs-lookup"><span data-stu-id="ee99f-214">The members of `long` are the members of the `System.Int64` struct.</span></span>
*  <span data-ttu-id="ee99f-215">Die Member von `ulong` sind die Elemente der `System.UInt64`-Struktur.</span><span class="sxs-lookup"><span data-stu-id="ee99f-215">The members of `ulong` are the members of the `System.UInt64` struct.</span></span>
*  <span data-ttu-id="ee99f-216">Die Member von `char` sind die Elemente der `System.Char`-Struktur.</span><span class="sxs-lookup"><span data-stu-id="ee99f-216">The members of `char` are the members of the `System.Char` struct.</span></span>
*  <span data-ttu-id="ee99f-217">Die Member von `float` sind die Elemente der `System.Single`-Struktur.</span><span class="sxs-lookup"><span data-stu-id="ee99f-217">The members of `float` are the members of the `System.Single` struct.</span></span>
*  <span data-ttu-id="ee99f-218">Die Member von `double` sind die Elemente der `System.Double`-Struktur.</span><span class="sxs-lookup"><span data-stu-id="ee99f-218">The members of `double` are the members of the `System.Double` struct.</span></span>
*  <span data-ttu-id="ee99f-219">Die Member von `decimal` sind die Elemente der `System.Decimal`-Struktur.</span><span class="sxs-lookup"><span data-stu-id="ee99f-219">The members of `decimal` are the members of the `System.Decimal` struct.</span></span>
*  <span data-ttu-id="ee99f-220">Die Member von `bool` sind die Elemente der `System.Boolean`-Struktur.</span><span class="sxs-lookup"><span data-stu-id="ee99f-220">The members of `bool` are the members of the `System.Boolean` struct.</span></span>

### <a name="enumeration-members"></a><span data-ttu-id="ee99f-221">Enumerationsmember</span><span class="sxs-lookup"><span data-stu-id="ee99f-221">Enumeration members</span></span>

<span data-ttu-id="ee99f-222">Die Member einer Enumeration sind die in der-Enumeration deklarierten Konstanten und die Member, die von der direkten Basisklasse der-Enumeration geerbt werden `System.Enum` und die indirekten Basisklassen `System.ValueType` und `object`.</span><span class="sxs-lookup"><span data-stu-id="ee99f-222">The members of an enumeration are the constants declared in the enumeration and the members inherited from the enumeration's direct base class `System.Enum` and the indirect base classes `System.ValueType` and `object`.</span></span>

### <a name="class-members"></a><span data-ttu-id="ee99f-223">Klassenmember</span><span class="sxs-lookup"><span data-stu-id="ee99f-223">Class members</span></span>

<span data-ttu-id="ee99f-224">Die Member einer Klasse sind die Member, die in der Klasse deklariert werden, und die Member, die von der Basisklasse geerbt wurden (mit Ausnahme der Klasse `object`, die keine Basisklasse aufweist).</span><span class="sxs-lookup"><span data-stu-id="ee99f-224">The members of a class are the members declared in the class and the members inherited from the base class (except for class `object` which has no base class).</span></span> <span data-ttu-id="ee99f-225">Die von der Basisklasse geerbten Member enthalten die Konstanten, Felder, Methoden, Eigenschaften, Ereignisse, Indexer, Operatoren und Typen der Basisklasse, nicht jedoch die Instanzkonstruktoren, destrukturtoren und statischen Konstruktoren der Basisklasse.</span><span class="sxs-lookup"><span data-stu-id="ee99f-225">The members inherited from the base class include the constants, fields, methods, properties, events, indexers, operators, and types of the base class, but not the instance constructors, destructors and static constructors of the base class.</span></span> <span data-ttu-id="ee99f-226">Basisklassenmember werden ohne Rücksicht auf ihre Barrierefreiheit geerbt.</span><span class="sxs-lookup"><span data-stu-id="ee99f-226">Base class members are inherited without regard to their accessibility.</span></span>

<span data-ttu-id="ee99f-227">Eine Klassen Deklaration kann Deklarationen von Konstanten, Feldern, Methoden, Eigenschaften, Ereignissen, Indexern, Operatoren, Instanzkonstruktoren, Debuggern, statischen Konstruktoren und Typen enthalten.</span><span class="sxs-lookup"><span data-stu-id="ee99f-227">A class declaration may contain declarations of constants, fields, methods, properties, events, indexers, operators, instance constructors, destructors, static constructors and types.</span></span>

<span data-ttu-id="ee99f-228">Die Member von `object` und `string` entsprechen direkt den Membern der Klassentypen, die Sie Alias:</span><span class="sxs-lookup"><span data-stu-id="ee99f-228">The members of `object` and `string` correspond directly to the members of the class types they alias:</span></span>

*  <span data-ttu-id="ee99f-229">Die Member von `object` sind die Member der `System.Object`-Klasse.</span><span class="sxs-lookup"><span data-stu-id="ee99f-229">The members of `object` are the members of the `System.Object` class.</span></span>
*  <span data-ttu-id="ee99f-230">Die Member von `string` sind die Member der `System.String`-Klasse.</span><span class="sxs-lookup"><span data-stu-id="ee99f-230">The members of `string` are the members of the `System.String` class.</span></span>

### <a name="interface-members"></a><span data-ttu-id="ee99f-231">Schnittstellenmember</span><span class="sxs-lookup"><span data-stu-id="ee99f-231">Interface members</span></span>

<span data-ttu-id="ee99f-232">Die Member einer Schnittstelle sind die Member, die in der-Schnittstelle und in allen Basis Schnittstellen der-Schnittstelle deklariert werden.</span><span class="sxs-lookup"><span data-stu-id="ee99f-232">The members of an interface are the members declared in the interface and in all base interfaces of the interface.</span></span> <span data-ttu-id="ee99f-233">Die Member in der Klasse `object` sind nicht, streng genommen Member einer beliebigen Schnittstelle ([Schnittstellenmember](interfaces.md#interface-members)).</span><span class="sxs-lookup"><span data-stu-id="ee99f-233">The members in class `object` are not, strictly speaking, members of any interface ([Interface members](interfaces.md#interface-members)).</span></span> <span data-ttu-id="ee99f-234">Allerdings sind die Member in der Klasse `object` über die Element Suche in einem beliebigen Schnittstellentyp ([Member-Suche](expressions.md#member-lookup)) verfügbar.</span><span class="sxs-lookup"><span data-stu-id="ee99f-234">However, the members in class `object` are available via member lookup in any interface type ([Member lookup](expressions.md#member-lookup)).</span></span>

### <a name="array-members"></a><span data-ttu-id="ee99f-235">Array Elemente</span><span class="sxs-lookup"><span data-stu-id="ee99f-235">Array members</span></span>

<span data-ttu-id="ee99f-236">Die Member eines Arrays sind die Member, die von der Klasse `System.Array` geerbt werden.</span><span class="sxs-lookup"><span data-stu-id="ee99f-236">The members of an array are the members inherited from class `System.Array`.</span></span>

### <a name="delegate-members"></a><span data-ttu-id="ee99f-237">Delegatmember</span><span class="sxs-lookup"><span data-stu-id="ee99f-237">Delegate members</span></span>

<span data-ttu-id="ee99f-238">Die Member eines Delegaten sind die Member, die von der Klasse `System.Delegate` geerbt werden.</span><span class="sxs-lookup"><span data-stu-id="ee99f-238">The members of a delegate are the members inherited from class `System.Delegate`.</span></span>

## <a name="member-access"></a><span data-ttu-id="ee99f-239">Memberzugriff</span><span class="sxs-lookup"><span data-stu-id="ee99f-239">Member access</span></span>

<span data-ttu-id="ee99f-240">Deklarationen von Membern ermöglichen die Steuerung des Member-Zugriffs.</span><span class="sxs-lookup"><span data-stu-id="ee99f-240">Declarations of members allow control over member access.</span></span> <span data-ttu-id="ee99f-241">Der Zugriff auf einen Member wird durch die deklarierte Barrierefreiheit (als[Barrierefreiheit deklariert](basic-concepts.md#declared-accessibility)) des Members in Kombination mit dem Zugriff auf den direkt enthaltenden Typ hergestellt, sofern vorhanden.</span><span class="sxs-lookup"><span data-stu-id="ee99f-241">The accessibility of a member is established by the declared accessibility ([Declared accessibility](basic-concepts.md#declared-accessibility)) of the member combined with the accessibility of the immediately containing type, if any.</span></span>

<span data-ttu-id="ee99f-242">Wenn der Zugriff auf ein bestimmtes Element zulässig ist, wird der Zugriff auf den Member als ***verfügbar***bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="ee99f-242">When access to a particular member is allowed, the member is said to be ***accessible***.</span></span> <span data-ttu-id="ee99f-243">Wenn der Zugriff auf ein bestimmtes Element nicht zulässig ist ***, wird der***Zugriff auf den Member als nicht zulässig bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="ee99f-243">Conversely, when access to a particular member is disallowed, the member is said to be ***inaccessible***.</span></span> <span data-ttu-id="ee99f-244">Der Zugriff auf ein Mitglied ist zulässig, wenn der Text Speicherort, in dem der Zugriff erfolgt, in der Zugriffs Domäne ([Barrierefreiheits Domänen](basic-concepts.md#accessibility-domains)) des Mitglieds enthalten ist.</span><span class="sxs-lookup"><span data-stu-id="ee99f-244">Access to a member is permitted when the textual location in which the access takes place is included in the accessibility domain ([Accessibility domains](basic-concepts.md#accessibility-domains)) of the member.</span></span>

### <a name="declared-accessibility"></a><span data-ttu-id="ee99f-245">Deklarierter Zugriff</span><span class="sxs-lookup"><span data-stu-id="ee99f-245">Declared accessibility</span></span>

<span data-ttu-id="ee99f-246">Die ***deklarierte Barrierefreiheit*** eines Members kann eine der folgenden sein:</span><span class="sxs-lookup"><span data-stu-id="ee99f-246">The ***declared accessibility*** of a member can be one of the following:</span></span>

*  <span data-ttu-id="ee99f-247">Public, das durch Einschließen eines `public`-Modifizierers in die Element Deklaration ausgewählt wird.</span><span class="sxs-lookup"><span data-stu-id="ee99f-247">Public, which is selected by including a `public` modifier in the member declaration.</span></span> <span data-ttu-id="ee99f-248">Die intuitive Bedeutung von `public` ist "Zugriff nicht beschränkt".</span><span class="sxs-lookup"><span data-stu-id="ee99f-248">The intuitive meaning of `public` is "access not limited".</span></span>
*  <span data-ttu-id="ee99f-249">Geschützt, das durch Einschließen eines `protected`-Modifizierers in die Element Deklaration ausgewählt wird.</span><span class="sxs-lookup"><span data-stu-id="ee99f-249">Protected, which is selected by including a `protected` modifier in the member declaration.</span></span> <span data-ttu-id="ee99f-250">Die intuitive Bedeutung von `protected` ist "der Zugriff ist auf die enthaltende Klasse oder auf Typen beschränkt, die von der enthaltenden Klasse abgeleitet sind".</span><span class="sxs-lookup"><span data-stu-id="ee99f-250">The intuitive meaning of `protected` is "access limited to the containing class or types derived from the containing class".</span></span>
*  <span data-ttu-id="ee99f-251">Intern, das durch Einschließen eines `internal`-Modifizierers in die Element Deklaration ausgewählt wird.</span><span class="sxs-lookup"><span data-stu-id="ee99f-251">Internal, which is selected by including an `internal` modifier in the member declaration.</span></span> <span data-ttu-id="ee99f-252">Die intuitive Bedeutung von `internal` ist "Zugriff beschränkt auf dieses Programm".</span><span class="sxs-lookup"><span data-stu-id="ee99f-252">The intuitive meaning of `internal` is "access limited to this program".</span></span>
*  <span data-ttu-id="ee99f-253">Geschützter interner (d.h. geschützt oder intern), der durch das Einschließen eines `protected`-und eines `internal`-Modifizierers in die Element Deklaration ausgewählt wird.</span><span class="sxs-lookup"><span data-stu-id="ee99f-253">Protected internal (meaning protected or internal), which is selected by including both a `protected` and an `internal` modifier in the member declaration.</span></span> <span data-ttu-id="ee99f-254">Die intuitive Bedeutung von `protected internal` ist "der Zugriff ist auf dieses Programm oder auf Typen beschränkt, die von der enthaltenden Klasse abgeleitet sind".</span><span class="sxs-lookup"><span data-stu-id="ee99f-254">The intuitive meaning of `protected internal` is "access limited to this program or types derived from the containing class".</span></span>
*  <span data-ttu-id="ee99f-255">Privat, das durch Einschließen eines `private`-Modifizierers in die Element Deklaration ausgewählt wird.</span><span class="sxs-lookup"><span data-stu-id="ee99f-255">Private, which is selected by including a `private` modifier in the member declaration.</span></span> <span data-ttu-id="ee99f-256">Die intuitive Bedeutung von `private` ist "der Zugriff ist auf den enthaltenden Typ beschränkt".</span><span class="sxs-lookup"><span data-stu-id="ee99f-256">The intuitive meaning of `private` is "access limited to the containing type".</span></span>

<span data-ttu-id="ee99f-257">Abhängig vom Kontext, in dem eine Element Deklaration stattfindet, sind nur bestimmte Typen von deklarierter Barrierefreiheit zulässig.</span><span class="sxs-lookup"><span data-stu-id="ee99f-257">Depending on the context in which a member declaration takes place, only certain types of declared accessibility are permitted.</span></span> <span data-ttu-id="ee99f-258">Wenn eine Member-Deklaration keine Zugriffsmodifizierer enthält, bestimmt der Kontext, in dem die Deklaration stattfindet, die standardmäßige deklarierte Barrierefreiheit.</span><span class="sxs-lookup"><span data-stu-id="ee99f-258">Furthermore, when a member declaration does not include any access modifiers, the context in which the declaration takes place determines the default declared accessibility.</span></span>

*  <span data-ttu-id="ee99f-259">Namespaces verfügen implizit über `public` deklarierte Zugriffsmöglichkeiten.</span><span class="sxs-lookup"><span data-stu-id="ee99f-259">Namespaces implicitly have `public` declared accessibility.</span></span> <span data-ttu-id="ee99f-260">Für Namespace Deklarationen sind keine Zugriffsmodifizierer zulässig.</span><span class="sxs-lookup"><span data-stu-id="ee99f-260">No access modifiers are allowed on namespace declarations.</span></span>
*  <span data-ttu-id="ee99f-261">Typen, die in Kompilierungs Einheiten oder Namespaces deklariert sind, können `public` oder `internal` als Barrierefreiheit deklariert haben und standardmäßig `internal` deklarierten Barrierefreiheit aufweisen.</span><span class="sxs-lookup"><span data-stu-id="ee99f-261">Types declared in compilation units or namespaces can have `public` or `internal` declared accessibility and default to `internal` declared accessibility.</span></span>
*  <span data-ttu-id="ee99f-262">Klassenmember können eine der fünf Arten von deklarierten zugreif barkeit aufweisen und standardmäßig auf `private` deklarierte Barrierefreiheit.</span><span class="sxs-lookup"><span data-stu-id="ee99f-262">Class members can have any of the five kinds of declared accessibility and default to `private` declared accessibility.</span></span> <span data-ttu-id="ee99f-263">(Beachten Sie, dass ein Typ, der als Member einer Klasse deklariert wird, eine der fünf Arten von deklarierten zugreif barkeit haben kann, wohingegen ein als Member eines Namespace deklarierter Typ nur `public` oder `internal` als Barrierefreiheit deklariert hat.)</span><span class="sxs-lookup"><span data-stu-id="ee99f-263">(Note that a type declared as a member of a class can have any of the five kinds of declared accessibility, whereas a type declared as a member of a namespace can have only `public` or `internal` declared accessibility.)</span></span>
*  <span data-ttu-id="ee99f-264">Strukturmember können `public`, `internal` oder `private` als Barrierefreiheit deklariert haben und standardmäßig `private` deklarierten Barrierefreiheit aufweisen, da Strukturen implizit versiegelt sind.</span><span class="sxs-lookup"><span data-stu-id="ee99f-264">Struct members can have `public`, `internal`, or `private` declared accessibility and default to `private` declared accessibility because structs are implicitly sealed.</span></span> <span data-ttu-id="ee99f-265">Strukturmember, die in einer Struktur eingeführt werden (d. h. nicht von dieser Struktur geerbt), dürfen nicht `protected`-oder `protected internal`-Barrierefreiheit haben.</span><span class="sxs-lookup"><span data-stu-id="ee99f-265">Struct members introduced in a struct (that is, not inherited by that struct) cannot have `protected` or `protected internal` declared accessibility.</span></span> <span data-ttu-id="ee99f-266">(Beachten Sie, dass ein Typ, der als Member einer Struktur deklariert ist, `public`, `internal` oder `private` als Barrierefreiheit deklariert hat. ein als Member eines Namespace deklarierter Typ kann jedoch nur `public` oder `internal` als Barrierefreiheit deklarierte Zugriffsmöglichkeiten aufweisen.)</span><span class="sxs-lookup"><span data-stu-id="ee99f-266">(Note that a type declared as a member of a struct can have `public`, `internal`, or `private` declared accessibility, whereas a type declared as a member of a namespace can have only `public` or `internal` declared accessibility.)</span></span>
*  <span data-ttu-id="ee99f-267">Schnittstellenmember verfügen implizit über `public` deklarierte Zugriffsmöglichkeiten.</span><span class="sxs-lookup"><span data-stu-id="ee99f-267">Interface members implicitly have `public` declared accessibility.</span></span> <span data-ttu-id="ee99f-268">Zugriffsmodifizierer sind für Schnittstellenmember-Deklarationen unzulässig</span><span class="sxs-lookup"><span data-stu-id="ee99f-268">No access modifiers are allowed on interface member declarations.</span></span>
*  <span data-ttu-id="ee99f-269">Enumerationsmember haben implizit `public` deklarierte Zugriffsmöglichkeiten.</span><span class="sxs-lookup"><span data-stu-id="ee99f-269">Enumeration members implicitly have `public` declared accessibility.</span></span> <span data-ttu-id="ee99f-270">Es sind keine Zugriffsmodifizierer für Enumerationsmember zulässig.</span><span class="sxs-lookup"><span data-stu-id="ee99f-270">No access modifiers are allowed on enumeration member declarations.</span></span>

### <a name="accessibility-domains"></a><span data-ttu-id="ee99f-271">Barrierefreiheits Domänen</span><span class="sxs-lookup"><span data-stu-id="ee99f-271">Accessibility domains</span></span>

<span data-ttu-id="ee99f-272">Die Zugriffs ***Domäne*** eines Members besteht aus den (möglicherweise zusammenhängenden) Abschnitten von Programmtext, in dem der Zugriff auf den Member zulässig ist.</span><span class="sxs-lookup"><span data-stu-id="ee99f-272">The ***accessibility domain*** of a member consists of the (possibly disjoint) sections of program text in which access to the member is permitted.</span></span> <span data-ttu-id="ee99f-273">Zum Definieren der Zugriffs Domäne eines Members wird ein Member als ***oberste Ebene*** bezeichnet, wenn er nicht innerhalb eines Typs deklariert ist, und ein Member wird als geschachtelt bezeichnet, wenn er in einem anderen Typ deklariert wird.</span><span class="sxs-lookup"><span data-stu-id="ee99f-273">For purposes of defining the accessibility domain of a member, a member is said to be ***top-level*** if it is not declared within a type, and a member is said to be ***nested*** if it is declared within another type.</span></span> <span data-ttu-id="ee99f-274">Außerdem wird der ***Programmtext*** eines Programms als sämtlicher Programmtext definiert, der in allen Quelldateien des Programms enthalten ist, und der Programmtext eines Typs wird als sämtlicher Programmtext definiert, der in den *type_declaration*s dieses Typs enthalten ist (einschließlich). Möglicherweise sind Typen, die innerhalb des Typs geschachtelt sind.</span><span class="sxs-lookup"><span data-stu-id="ee99f-274">Furthermore, the ***program text*** of a program is defined as all program text contained in all source files of the program, and the program text of a type is defined as all program text contained in the *type_declaration*s of that type (including, possibly, types that are nested within the type).</span></span>

<span data-ttu-id="ee99f-275">Die Zugriffs Domäne eines vordefinierten Typs (z. b. `object`, `int` oder `double`) ist unbegrenzt.</span><span class="sxs-lookup"><span data-stu-id="ee99f-275">The accessibility domain of a predefined type (such as `object`, `int`, or `double`) is unlimited.</span></span>

<span data-ttu-id="ee99f-276">Die Zugriffs Domäne eines ungebundenen Typs der obersten Ebene `T` ([gebundene und ungebundene Typen](types.md#bound-and-unbound-types)), die in einem Programm `P` deklariert ist, wird wie folgt definiert:</span><span class="sxs-lookup"><span data-stu-id="ee99f-276">The accessibility domain of a top-level unbound type `T` ([Bound and unbound types](types.md#bound-and-unbound-types)) that is declared in a program `P` is defined as follows:</span></span>

*  <span data-ttu-id="ee99f-277">Wenn die deklarierte Barrierefreiheit von `T` `public` ist, ist die Zugriffs Domäne von `T` der Programmtext von `P` und jedes Programm, das auf `P` verweist.</span><span class="sxs-lookup"><span data-stu-id="ee99f-277">If the declared accessibility of `T` is `public`, the accessibility domain of `T` is the program text of `P` and any program that references `P`.</span></span>
*  <span data-ttu-id="ee99f-278">Wenn die deklarierte Zugriffsart von `T` den Wert `internal` hat, entspricht die Zugriffsdomäne von `T` dem Programmtext von `P`.</span><span class="sxs-lookup"><span data-stu-id="ee99f-278">If the declared accessibility of `T` is `internal`, the accessibility domain of `T` is the program text of `P`.</span></span>

<span data-ttu-id="ee99f-279">Aus diesen Definitionen folgt, dass die Zugriffs Domäne eines ungebundenen Typs der obersten Ebene immer mindestens dem Programmtext des Programms entspricht, in dem der Typ deklariert ist.</span><span class="sxs-lookup"><span data-stu-id="ee99f-279">From these definitions it follows that the accessibility domain of a top-level unbound type is always at least the program text of the program in which that type is declared.</span></span>

<span data-ttu-id="ee99f-280">Die Barrierefreiheits Domäne für einen konstruierten Typ `T<A1, ..., An>` ist die Schnittmenge der Barrierefreiheits Domäne des ungebundenen generischen Typs `T` und der Barrierefreiheits Domänen der Typargumente `A1, ..., An`.</span><span class="sxs-lookup"><span data-stu-id="ee99f-280">The accessibility domain for a constructed type `T<A1, ..., An>` is the intersection of the accessibility domain of the unbound generic type `T` and the accessibility domains of the type arguments `A1, ..., An`.</span></span>

<span data-ttu-id="ee99f-281">Die Zugriffs Domäne @no__t eines geschachtelten Members, der in einem Typ `T` in einem Programm `P` deklariert ist, wird wie folgt definiert (Beachten Sie, dass `M` selbst möglicherweise ein Typ sein kann):</span><span class="sxs-lookup"><span data-stu-id="ee99f-281">The accessibility domain of a nested member `M` declared in a type `T` within a program `P` is defined as follows (noting that `M` itself may possibly be a type):</span></span>

*  <span data-ttu-id="ee99f-282">Wenn die deklarierte Zugriffsart von `M` den Wert `public` hat, entspricht die Zugriffsdomäne von `M` der von `T`.</span><span class="sxs-lookup"><span data-stu-id="ee99f-282">If the declared accessibility of `M` is `public`, the accessibility domain of `M` is the accessibility domain of `T`.</span></span>
*  <span data-ttu-id="ee99f-283">Wenn die deklarierte Barrierefreiheit von `M` `protected internal` ist, lassen Sie `D` die Vereinigung des Programm Texts von `P` und den Programmtext eines beliebigen Typs sein, der von `T` abgeleitet ist, der außerhalb von `P` deklariert ist.</span><span class="sxs-lookup"><span data-stu-id="ee99f-283">If the declared accessibility of `M` is `protected internal`, let `D` be the union of the program text of `P` and the program text of any type derived from `T`, which is declared outside `P`.</span></span> <span data-ttu-id="ee99f-284">Die Zugriffs Domäne `M` ist die Schnittmenge der Zugriffs Domäne `T` mit `D`.</span><span class="sxs-lookup"><span data-stu-id="ee99f-284">The accessibility domain of `M` is the intersection of the accessibility domain of `T` with `D`.</span></span>
*  <span data-ttu-id="ee99f-285">Wenn die deklarierte Barrierefreiheit von `M` `protected` ist, lassen Sie `D` die Vereinigung des Programm Texts von `T` und den Programmtext jedes Typs, der von `T` abgeleitet ist, sein.</span><span class="sxs-lookup"><span data-stu-id="ee99f-285">If the declared accessibility of `M` is `protected`, let `D` be the union of the program text of `T` and the program text of any type derived from `T`.</span></span> <span data-ttu-id="ee99f-286">Die Zugriffs Domäne `M` ist die Schnittmenge der Zugriffs Domäne `T` mit `D`.</span><span class="sxs-lookup"><span data-stu-id="ee99f-286">The accessibility domain of `M` is the intersection of the accessibility domain of `T` with `D`.</span></span>
*  <span data-ttu-id="ee99f-287">Wenn die deklarierte Zugriffsart von `M` den Wert `internal` hat, entspricht die Zugriffsdomäne von `M` der Schnittmenge zwischen der Zugriffsdomäne von `T` und dem Programmtext von `P`.</span><span class="sxs-lookup"><span data-stu-id="ee99f-287">If the declared accessibility of `M` is `internal`, the accessibility domain of `M` is the intersection of the accessibility domain of `T` with the program text of `P`.</span></span>
*  <span data-ttu-id="ee99f-288">Wenn die deklarierte Zugriffsart von `M` den Wert `private` hat, entspricht die Zugriffsdomäne von `M` dem Programmtext von `T`.</span><span class="sxs-lookup"><span data-stu-id="ee99f-288">If the declared accessibility of `M` is `private`, the accessibility domain of `M` is the program text of `T`.</span></span>

<span data-ttu-id="ee99f-289">Aus diesen Definitionen folgt, dass die Barrierefreiheits Domäne eines in einem Bereich eingefügten Members immer mindestens dem Programmtext des Typs entspricht, in dem der Member deklariert ist.</span><span class="sxs-lookup"><span data-stu-id="ee99f-289">From these definitions it follows that the accessibility domain of a nested member is always at least the program text of the type in which the member is declared.</span></span> <span data-ttu-id="ee99f-290">Ferner folgt, dass die Zugriffs Domäne eines Members nie inklusiver ist als die Zugriffs Domäne des Typs, in dem der Member deklariert ist.</span><span class="sxs-lookup"><span data-stu-id="ee99f-290">Furthermore, it follows that the accessibility domain of a member is never more inclusive than the accessibility domain of the type in which the member is declared.</span></span>

<span data-ttu-id="ee99f-291">Wenn auf einen Typ oder Member `M` zugegriffen wird, werden die folgenden Schritte in intuitiver Hinsicht ausgewertet, um sicherzustellen, dass der Zugriff zulässig ist:</span><span class="sxs-lookup"><span data-stu-id="ee99f-291">In intuitive terms, when a type or member `M` is accessed, the following steps are evaluated to ensure that the access is permitted:</span></span>

*  <span data-ttu-id="ee99f-292">Wenn `M` innerhalb eines Typs deklariert ist (im Gegensatz zu einer Kompilierungseinheit oder einem Namespace), tritt zunächst ein Kompilierzeitfehler auf, wenn auf diesen Typ nicht zugegriffen werden kann.</span><span class="sxs-lookup"><span data-stu-id="ee99f-292">First, if `M` is declared within a type (as opposed to a compilation unit or a namespace), a compile-time error occurs if that type is not accessible.</span></span>
*  <span data-ttu-id="ee99f-293">Wenn `M` `public` ist, ist der Zugriff zulässig.</span><span class="sxs-lookup"><span data-stu-id="ee99f-293">Then, if `M` is `public`, the access is permitted.</span></span>
*  <span data-ttu-id="ee99f-294">Andernfalls, wenn `M` `protected internal` ist, ist der Zugriff zulässig, wenn er innerhalb des Programms auftritt, in dem `M` deklariert ist, oder wenn es in einer Klasse auftritt, die von der Klasse abgeleitet ist, in der `M` deklariert ist, und durch den abgeleiteten Klassentyp (geschützt) erfolgt.[ Zugriff für Instanzmember](basic-concepts.md#protected-access-for-instance-members)).</span><span class="sxs-lookup"><span data-stu-id="ee99f-294">Otherwise, if `M` is `protected internal`, the access is permitted if it occurs within the program in which `M` is declared, or if it occurs within a class derived from the class in which `M` is declared and takes place through the derived class type ([Protected access for instance members](basic-concepts.md#protected-access-for-instance-members)).</span></span>
*  <span data-ttu-id="ee99f-295">Andernfalls, wenn `M` `protected` ist, ist der Zugriff zulässig, wenn er innerhalb der Klasse auftritt, in der `M` deklariert ist, oder wenn er in einer Klasse auftritt, die von der Klasse abgeleitet ist, in der `M` deklariert ist und durch den Typ der abgeleiteten Klasse erfolgt ([geschützt Zugriff für Instanzmember](basic-concepts.md#protected-access-for-instance-members)).</span><span class="sxs-lookup"><span data-stu-id="ee99f-295">Otherwise, if `M` is `protected`, the access is permitted if it occurs within the class in which `M` is declared, or if it occurs within a class derived from the class in which `M` is declared and takes place through the derived class type ([Protected access for instance members](basic-concepts.md#protected-access-for-instance-members)).</span></span>
*  <span data-ttu-id="ee99f-296">Andernfalls ist der Zugriff zulässig, wenn `M` `internal` ist, wenn er innerhalb des Programms auftritt, in dem `M` deklariert ist.</span><span class="sxs-lookup"><span data-stu-id="ee99f-296">Otherwise, if `M` is `internal`, the access is permitted if it occurs within the program in which `M` is declared.</span></span>
*  <span data-ttu-id="ee99f-297">Andernfalls ist der Zugriff zulässig, wenn `M` `private` ist, wenn er innerhalb des Typs auftritt, in dem `M` deklariert ist.</span><span class="sxs-lookup"><span data-stu-id="ee99f-297">Otherwise, if `M` is `private`, the access is permitted if it occurs within the type in which `M` is declared.</span></span>
*  <span data-ttu-id="ee99f-298">Andernfalls ist der Typ oder Member nicht zugänglich, und es tritt ein Kompilierzeitfehler auf.</span><span class="sxs-lookup"><span data-stu-id="ee99f-298">Otherwise, the type or member is inaccessible, and a compile-time error occurs.</span></span>

<span data-ttu-id="ee99f-299">Im Beispiel</span><span class="sxs-lookup"><span data-stu-id="ee99f-299">In the example</span></span>
```csharp
public class A
{
    public static int X;
    internal static int Y;
    private static int Z;
}

internal class B
{
    public static int X;
    internal static int Y;
    private static int Z;

    public class C
    {
        public static int X;
        internal static int Y;
        private static int Z;
    }

    private class D
    {
        public static int X;
        internal static int Y;
        private static int Z;
    }
}
```
<span data-ttu-id="ee99f-300">die Klassen und Member haben die folgenden Barrierefreiheits Domänen:</span><span class="sxs-lookup"><span data-stu-id="ee99f-300">the classes and members have the following accessibility domains:</span></span>

*  <span data-ttu-id="ee99f-301">Die Zugriffs Domäne `A` und `A.X` ist unbegrenzt.</span><span class="sxs-lookup"><span data-stu-id="ee99f-301">The accessibility domain of `A` and `A.X` is unlimited.</span></span>
*  <span data-ttu-id="ee99f-302">Die Zugriffs Domäne `A.Y`, `B`, `B.X`, `B.Y`, `B.C`, `B.C.X` und `B.C.Y` ist der Programmtext des enthaltenden Programms.</span><span class="sxs-lookup"><span data-stu-id="ee99f-302">The accessibility domain of `A.Y`, `B`, `B.X`, `B.Y`, `B.C`, `B.C.X`, and `B.C.Y` is the program text of the containing program.</span></span>
*  <span data-ttu-id="ee99f-303">Die Zugriffs Domäne `A.Z` ist der Programmtext von `A`.</span><span class="sxs-lookup"><span data-stu-id="ee99f-303">The accessibility domain of `A.Z` is the program text of `A`.</span></span>
*  <span data-ttu-id="ee99f-304">Die Zugriffs Domäne `B.Z` und `B.D` ist der Programmtext von `B`, einschließlich des Programm Texts von `B.C` und `B.D`.</span><span class="sxs-lookup"><span data-stu-id="ee99f-304">The accessibility domain of `B.Z` and `B.D` is the program text of `B`, including the program text of `B.C` and `B.D`.</span></span>
*  <span data-ttu-id="ee99f-305">Die Zugriffs Domäne `B.C.Z` ist der Programmtext von `B.C`.</span><span class="sxs-lookup"><span data-stu-id="ee99f-305">The accessibility domain of `B.C.Z` is the program text of `B.C`.</span></span>
*  <span data-ttu-id="ee99f-306">Die Zugriffs Domäne `B.D.X` und `B.D.Y` ist der Programmtext von `B`, einschließlich des Programm Texts von `B.C` und `B.D`.</span><span class="sxs-lookup"><span data-stu-id="ee99f-306">The accessibility domain of `B.D.X` and `B.D.Y` is the program text of `B`, including the program text of `B.C` and `B.D`.</span></span>
*  <span data-ttu-id="ee99f-307">Die Zugriffs Domäne `B.D.Z` ist der Programmtext von `B.D`.</span><span class="sxs-lookup"><span data-stu-id="ee99f-307">The accessibility domain of `B.D.Z` is the program text of `B.D`.</span></span>

<span data-ttu-id="ee99f-308">Wie das Beispiel zeigt, ist die Zugriffs Domäne eines Members nie größer als die eines enthaltenden Typs.</span><span class="sxs-lookup"><span data-stu-id="ee99f-308">As the example illustrates, the accessibility domain of a member is never larger than that of a containing type.</span></span> <span data-ttu-id="ee99f-309">Wenn z. b. alle `X`-Member öffentlich deklarierte Barrierefreiheit haben, verfügen alle, aber `A.X` über Barrierefreiheits Domänen, die durch einen enthaltenden Typ eingeschränkt werden.</span><span class="sxs-lookup"><span data-stu-id="ee99f-309">For example, even though all `X` members have public declared accessibility, all but `A.X` have accessibility domains that are constrained by a containing type.</span></span>

<span data-ttu-id="ee99f-310">Wie in [Members](basic-concepts.md#members)beschrieben, werden alle Member einer Basisklasse, mit Ausnahme von Instanzkonstruktoren, destrukturiertoren und statischen Konstruktoren, von abgeleiteten Typen geerbt.</span><span class="sxs-lookup"><span data-stu-id="ee99f-310">As described in [Members](basic-concepts.md#members), all members of a base class, except for instance constructors, destructors and static constructors, are inherited by derived types.</span></span> <span data-ttu-id="ee99f-311">Dies schließt sogar private Member einer Basisklasse ein.</span><span class="sxs-lookup"><span data-stu-id="ee99f-311">This includes even private members of a base class.</span></span> <span data-ttu-id="ee99f-312">Die Zugriffs Domäne eines privaten Members enthält jedoch nur den Programmtext des Typs, in dem der Member deklariert ist.</span><span class="sxs-lookup"><span data-stu-id="ee99f-312">However, the accessibility domain of a private member includes only the program text of the type in which the member is declared.</span></span> <span data-ttu-id="ee99f-313">Im Beispiel</span><span class="sxs-lookup"><span data-stu-id="ee99f-313">In the example</span></span>
```csharp
class A
{
    int x;

    static void F(B b) {
        b.x = 1;        // Ok
    }
}

class B: A
{
    static void F(B b) {
        b.x = 1;        // Error, x not accessible
    }
}
```
<span data-ttu-id="ee99f-314">die `B`-Klasse erbt den privaten Member `x` von der `A`-Klasse.</span><span class="sxs-lookup"><span data-stu-id="ee99f-314">the `B` class inherits the private member `x` from the `A` class.</span></span> <span data-ttu-id="ee99f-315">Da der Member privat ist, kann er nur innerhalb des *class_body* von `A` aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="ee99f-315">Because the member is private, it is only accessible within the *class_body* of `A`.</span></span> <span data-ttu-id="ee99f-316">Folglich ist der Zugriff auf `b.x` in der `A.F`-Methode erfolgreich, schlägt jedoch in der `B.F`-Methode fehl.</span><span class="sxs-lookup"><span data-stu-id="ee99f-316">Thus, the access to `b.x` succeeds in the `A.F` method, but fails in the `B.F` method.</span></span>

### <a name="protected-access-for-instance-members"></a><span data-ttu-id="ee99f-317">Geschützter Zugriff für Instanzmember</span><span class="sxs-lookup"><span data-stu-id="ee99f-317">Protected access for instance members</span></span>

<span data-ttu-id="ee99f-318">Wenn auf einen `protected`-Instanzmember außerhalb des Programm Texts der Klasse zugegriffen wird, in der er deklariert ist, und wenn auf einen `protected internal`-Instanzmember außerhalb des Programm Texts des Programms zugegriffen wird, in dem es deklariert ist, muss der Zugriff innerhalb einer Klasse erfolgen. Deklaration, die von der Klasse abgeleitet ist, in der Sie deklariert ist.</span><span class="sxs-lookup"><span data-stu-id="ee99f-318">When a `protected` instance member is accessed outside the program text of the class in which it is declared, and when a `protected internal` instance member is accessed outside the program text of the program in which it is declared, the access must take place within a class declaration that derives from the class in which it is declared.</span></span> <span data-ttu-id="ee99f-319">Darüber hinaus muss der Zugriff durch eine Instanz dieses abgeleiteten Klassen Typs oder eines aus der Klasse erstellten Klassen Typs erfolgen.</span><span class="sxs-lookup"><span data-stu-id="ee99f-319">Furthermore, the access is required to take place through an instance of that derived class type or a class type constructed from it.</span></span> <span data-ttu-id="ee99f-320">Diese Einschränkung verhindert, dass eine abgeleitete Klasse auf geschützte Member anderer abgeleiteter Klassen zugreift, auch wenn die Elemente von derselben Basisklasse geerbt werden.</span><span class="sxs-lookup"><span data-stu-id="ee99f-320">This restriction prevents one derived class from accessing protected members of other derived classes, even when the members are inherited from the same base class.</span></span>

<span data-ttu-id="ee99f-321">Let `B` ist eine Basisklasse, die einen geschützten Instanzmember `M` deklariert und `D` eine Klasse sein kann, die von `B` abgeleitet ist.</span><span class="sxs-lookup"><span data-stu-id="ee99f-321">Let `B` be a base class that declares a protected instance member `M`, and let `D` be a class that derives from `B`.</span></span> <span data-ttu-id="ee99f-322">Innerhalb des *class_body* -`D` kann der Zugriff auf `M` eine der folgenden Formen annehmen:</span><span class="sxs-lookup"><span data-stu-id="ee99f-322">Within the *class_body* of `D`, access to `M` can take one of the following forms:</span></span>

*  <span data-ttu-id="ee99f-323">Ein nicht qualifizierter *TYPE_NAME* oder *primary_expression* der Form `M`.</span><span class="sxs-lookup"><span data-stu-id="ee99f-323">An unqualified *type_name* or *primary_expression* of the form `M`.</span></span>
*  <span data-ttu-id="ee99f-324">Ein *primary_expression* im Format `E.M`, wenn der Typ von `E` `T` ist, oder eine Klasse, die von `T` abgeleitet ist, wobei `T` der Klassentyp `D` oder ein Klassentyp ist, der aus `D` erstellt wurde.</span><span class="sxs-lookup"><span data-stu-id="ee99f-324">A *primary_expression* of the form `E.M`, provided the type of `E` is `T` or a class derived from `T`, where `T` is the class type `D`, or a class type constructed from `D`</span></span>
*  <span data-ttu-id="ee99f-325">Ein *primary_expression* -Format `base.M`.</span><span class="sxs-lookup"><span data-stu-id="ee99f-325">A *primary_expression* of the form `base.M`.</span></span>

<span data-ttu-id="ee99f-326">Zusätzlich zu diesen Zugriffs Formen kann eine abgeleitete Klasse auf einen geschützten Instanzkonstruktor einer Basisklasse in einem *constructor_initializer* ([Konstruktorinitialisierer](classes.md#constructor-initializers)) zugreifen.</span><span class="sxs-lookup"><span data-stu-id="ee99f-326">In addition to these forms of access, a derived class can access a protected instance constructor of a base class in a *constructor_initializer* ([Constructor initializers](classes.md#constructor-initializers)).</span></span>

<span data-ttu-id="ee99f-327">Im Beispiel</span><span class="sxs-lookup"><span data-stu-id="ee99f-327">In the example</span></span>
```csharp
public class A
{
    protected int x;

    static void F(A a, B b) {
        a.x = 1;        // Ok
        b.x = 1;        // Ok
    }
}

public class B: A
{
    static void F(A a, B b) {
        a.x = 1;        // Error, must access through instance of B
        b.x = 1;        // Ok
    }
}
```
<span data-ttu-id="ee99f-328">in `A` ist es möglich, über Instanzen von `A` und `B` auf `x` zuzugreifen, da der Zugriff in beiden Fällen durch eine Instanz von `A` oder eine von `A` abgeleitete Klasse erfolgt.</span><span class="sxs-lookup"><span data-stu-id="ee99f-328">within `A`, it is possible to access `x` through instances of both `A` and `B`, since in either case the access takes place through an instance of `A` or a class derived from `A`.</span></span> <span data-ttu-id="ee99f-329">In `B` ist es jedoch nicht möglich, auf `x` über eine Instanz von `A` zuzugreifen, da `A` nicht von `B` abgeleitet ist.</span><span class="sxs-lookup"><span data-stu-id="ee99f-329">However, within `B`, it is not possible to access `x` through an instance of `A`, since `A` does not derive from `B`.</span></span>

<span data-ttu-id="ee99f-330">Im Beispiel</span><span class="sxs-lookup"><span data-stu-id="ee99f-330">In the example</span></span>
```csharp
class C<T>
{
    protected T x;
}

class D<T>: C<T>
{
    static void F() {
        D<T> dt = new D<T>();
        D<int> di = new D<int>();
        D<string> ds = new D<string>();
        dt.x = default(T);
        di.x = 123;
        ds.x = "test";
    }
}
```
<span data-ttu-id="ee99f-331">die drei Zuweisungen zu `x` sind zulässig, da Sie alle über Instanzen von Klassentypen erfolgen, die aus dem generischen Typ erstellt werden.</span><span class="sxs-lookup"><span data-stu-id="ee99f-331">the three assignments to `x` are permitted because they all take place through instances of class types constructed from the generic type.</span></span>

### <a name="accessibility-constraints"></a><span data-ttu-id="ee99f-332">Barrierefreiheits Einschränkungen</span><span class="sxs-lookup"><span data-stu-id="ee99f-332">Accessibility constraints</span></span>

<span data-ttu-id="ee99f-333">Mehrere Konstrukte in C# der Sprache erfordern, dass ein Typ mindestens ***so zugänglich ist wie*** ein Member oder ein anderer Typ.</span><span class="sxs-lookup"><span data-stu-id="ee99f-333">Several constructs in the C# language require a type to be ***at least as accessible as*** a member or another type.</span></span> <span data-ttu-id="ee99f-334">Ein Typ `T` ist zumindest so, dass er mindestens so zugänglich ist wie ein Member oder Typ `M`, wenn die Barrierefreiheits Domäne von `T` eine supermenge der Barrierefreiheits Domäne `M` ist.</span><span class="sxs-lookup"><span data-stu-id="ee99f-334">A type `T` is said to be at least as accessible as a member or type `M` if the accessibility domain of `T` is a superset of the accessibility domain of `M`.</span></span> <span data-ttu-id="ee99f-335">Anders ausgedrückt: `T` ist zumindest so verfügbar wie `M`, wenn `T` in allen Kontexten zugänglich ist, in denen `M` zugänglich ist.</span><span class="sxs-lookup"><span data-stu-id="ee99f-335">In other words, `T` is at least as accessible as `M` if `T` is accessible in all contexts in which `M` is accessible.</span></span>

<span data-ttu-id="ee99f-336">Die folgenden Barrierefreiheits Einschränkungen sind vorhanden:</span><span class="sxs-lookup"><span data-stu-id="ee99f-336">The following accessibility constraints exist:</span></span>

*  <span data-ttu-id="ee99f-337">Die direkte Basisklasse eines Klassentyps muss mindesten dieselben Zugriffsmöglichkeiten wie der Klassentyp selbst bieten.</span><span class="sxs-lookup"><span data-stu-id="ee99f-337">The direct base class of a class type must be at least as accessible as the class type itself.</span></span>
*  <span data-ttu-id="ee99f-338">Die explizite Basisschnittstelle eines Schnittstellentyps muss mindesten dieselben Zugriffsmöglichkeiten bieten wie der Schnittstellentyp selbst.</span><span class="sxs-lookup"><span data-stu-id="ee99f-338">The explicit base interfaces of an interface type must be at least as accessible as the interface type itself.</span></span>
*  <span data-ttu-id="ee99f-339">Die Rückgabe- und Parametertypen eines Delegattyps müssen mindestens dieselben Zugriffsmöglichkeiten wie der Delegattyp selbst bieten.</span><span class="sxs-lookup"><span data-stu-id="ee99f-339">The return type and parameter types of a delegate type must be at least as accessible as the delegate type itself.</span></span>
*  <span data-ttu-id="ee99f-340">Der Typ einer Konstante muss mindestens dieselben Zugriffsmöglichkeiten wie die Konstante selbst bieten.</span><span class="sxs-lookup"><span data-stu-id="ee99f-340">The type of a constant must be at least as accessible as the constant itself.</span></span>
*  <span data-ttu-id="ee99f-341">Der Typ eines Felds muss mindestens dieselben Zugriffsmöglichkeiten bieten wie das Feld selbst.</span><span class="sxs-lookup"><span data-stu-id="ee99f-341">The type of a field must be at least as accessible as the field itself.</span></span>
*  <span data-ttu-id="ee99f-342">Die Rückgabe- und Parametertypen einer Methode müssen mindestens dieselben Zugriffsmöglichkeiten bieten wie die Methode selbst.</span><span class="sxs-lookup"><span data-stu-id="ee99f-342">The return type and parameter types of a method must be at least as accessible as the method itself.</span></span>
*  <span data-ttu-id="ee99f-343">Der Typ einer Eigenschaft muss mindestens dieselben Zugriffsmöglichkeiten bieten wie die Eigenschaft selbst.</span><span class="sxs-lookup"><span data-stu-id="ee99f-343">The type of a property must be at least as accessible as the property itself.</span></span>
*  <span data-ttu-id="ee99f-344">Der Typ eines Ereignisses muss mindestens dieselben Zugriffsmöglichkeiten bieten wie das Ereignis selbst.</span><span class="sxs-lookup"><span data-stu-id="ee99f-344">The type of an event must be at least as accessible as the event itself.</span></span>
*  <span data-ttu-id="ee99f-345">Der Typ und die Parametertypen eines Indexers müssen mindestens dieselben Zugriffsmöglichkeiten bieten wie der Indexer selbst.</span><span class="sxs-lookup"><span data-stu-id="ee99f-345">The type and parameter types of an indexer must be at least as accessible as the indexer itself.</span></span>
*  <span data-ttu-id="ee99f-346">Die Rückgabe- und Parametertypen eines Operators müssen mindestens dieselben Zugriffsmöglichkeiten bieten wie der Operator selbst.</span><span class="sxs-lookup"><span data-stu-id="ee99f-346">The return type and parameter types of an operator must be at least as accessible as the operator itself.</span></span>
*  <span data-ttu-id="ee99f-347">Die Parametertypen eines Instanzkonstruktors müssen mindestens so zugänglich sein wie der Instanzkonstruktor selbst.</span><span class="sxs-lookup"><span data-stu-id="ee99f-347">The parameter types of an instance constructor must be at least as accessible as the instance constructor itself.</span></span>

<span data-ttu-id="ee99f-348">Im Beispiel</span><span class="sxs-lookup"><span data-stu-id="ee99f-348">In the example</span></span>
```csharp
class A {...}

public class B: A {...}
```
<span data-ttu-id="ee99f-349">die `B`-Klasse führt zu einem Kompilierzeitfehler, da `A` nicht mindestens so zugänglich ist wie `B`.</span><span class="sxs-lookup"><span data-stu-id="ee99f-349">the `B` class results in a compile-time error because `A` is not at least as accessible as `B`.</span></span>

<span data-ttu-id="ee99f-350">Gleiches gilt für das Beispiel</span><span class="sxs-lookup"><span data-stu-id="ee99f-350">Likewise, in the example</span></span>
```csharp
class A {...}

public class B
{
    A F() {...}

    internal A G() {...}

    public A H() {...}
}
```
<span data-ttu-id="ee99f-351">die `H`-Methode in `B` führt zu einem Kompilierzeitfehler, da der Rückgabetyp `A` nicht mindestens so zugänglich ist wie die-Methode.</span><span class="sxs-lookup"><span data-stu-id="ee99f-351">the `H` method in `B` results in a compile-time error because the return type `A` is not at least as accessible as the method.</span></span>

## <a name="signatures-and-overloading"></a><span data-ttu-id="ee99f-352">Signaturen und überladen</span><span class="sxs-lookup"><span data-stu-id="ee99f-352">Signatures and overloading</span></span>

<span data-ttu-id="ee99f-353">Methoden, Instanzkonstruktoren, Indexer und Operatoren sind durch ihre ***Signaturen***gekennzeichnet:</span><span class="sxs-lookup"><span data-stu-id="ee99f-353">Methods, instance constructors, indexers, and operators are characterized by their ***signatures***:</span></span>

*  <span data-ttu-id="ee99f-354">Die Signatur einer Methode besteht aus dem Namen der Methode, der Anzahl der Typparameter und dem Typ und der Art (Wert, Verweis oder Ausgabe) der einzelnen formalen Parameter, die in der Reihenfolge von links nach rechts berücksichtigt werden.</span><span class="sxs-lookup"><span data-stu-id="ee99f-354">The signature of a method consists of the name of the method, the number of type parameters and the type and kind (value, reference, or output) of each of its formal parameters, considered in the order left to right.</span></span> <span data-ttu-id="ee99f-355">Zu diesem Zweck wird jeder Typparameter der Methode, die im Typ eines formalen Parameters vorkommt, nicht anhand seines Namens identifiziert, sondern anhand seiner Ordinalposition in der Typargument Liste der Methode.</span><span class="sxs-lookup"><span data-stu-id="ee99f-355">For these purposes, any type parameter of the method that occurs in the type of a formal parameter is identified not by its name, but by its ordinal position in the type argument list of the method.</span></span> <span data-ttu-id="ee99f-356">Die Signatur einer Methode enthält nicht den Rückgabetyp, den `params`-Modifizierer, der für den ganz rechts Esten Parameter angegeben werden kann, oder die optionalen Typparameter Einschränkungen.</span><span class="sxs-lookup"><span data-stu-id="ee99f-356">The signature of a method specifically does not include the return type, the `params` modifier that may be specified for the right-most parameter, nor the optional type parameter constraints.</span></span>
*  <span data-ttu-id="ee99f-357">Die Signatur eines Instanzkonstruktors besteht aus Typ und Art (Wert, Verweis oder Ausgabe) der einzelnen formalen Parameter, die in der Reihenfolge von links nach rechts berücksichtigt werden.</span><span class="sxs-lookup"><span data-stu-id="ee99f-357">The signature of an instance constructor consists of the type and kind (value, reference, or output) of each of its formal parameters, considered in the order left to right.</span></span> <span data-ttu-id="ee99f-358">Die Signatur eines Instanzkonstruktors schließt speziell den `params`-Modifizierer nicht ein, der für den ganz rechts Esten Parameter angegeben werden kann.</span><span class="sxs-lookup"><span data-stu-id="ee99f-358">The signature of an instance constructor specifically does not include the `params` modifier that may be specified for the right-most parameter.</span></span>
*  <span data-ttu-id="ee99f-359">Die Signatur eines Indexers besteht aus dem Typ der einzelnen formalen Parameter, die in der Reihenfolge von links nach rechts berücksichtigt werden.</span><span class="sxs-lookup"><span data-stu-id="ee99f-359">The signature of an indexer consists of the type of each of its formal parameters, considered in the order left to right.</span></span> <span data-ttu-id="ee99f-360">Die Signatur eines Indexers enthält weder den Elementtyp noch den `params`-Modifizierer, der für den ganz rechts Esten Parameter angegeben werden kann.</span><span class="sxs-lookup"><span data-stu-id="ee99f-360">The signature of an indexer specifically does not include the element type, nor does it include the `params` modifier that may be specified for the right-most parameter.</span></span>
*  <span data-ttu-id="ee99f-361">Die Signatur eines Operators besteht aus dem Namen des Operators und dem Typ der einzelnen formalen Parameter, die in der Reihenfolge von links nach rechts betrachtet werden.</span><span class="sxs-lookup"><span data-stu-id="ee99f-361">The signature of an operator consists of the name of the operator and the type of each of its formal parameters, considered in the order left to right.</span></span> <span data-ttu-id="ee99f-362">Die Signatur eines Operators schließt den Ergebnistyp nicht ein.</span><span class="sxs-lookup"><span data-stu-id="ee99f-362">The signature of an operator specifically does not include the result type.</span></span>

<span data-ttu-id="ee99f-363">Signaturen sind der aktivierende Mechanismus für das ***überladen*** von Membern in Klassen, Strukturen und Schnittstellen:</span><span class="sxs-lookup"><span data-stu-id="ee99f-363">Signatures are the enabling mechanism for ***overloading*** of members in classes, structs, and interfaces:</span></span>

*  <span data-ttu-id="ee99f-364">Das Überladen von Methoden ermöglicht einer Klasse, Struktur oder Schnittstelle das Deklarieren mehrerer Methoden mit demselben Namen, vorausgesetzt, ihre Signaturen sind innerhalb dieser Klasse, Struktur oder Schnittstelle eindeutig.</span><span class="sxs-lookup"><span data-stu-id="ee99f-364">Overloading of methods permits a class, struct, or interface to declare multiple methods with the same name, provided their signatures are unique within that class, struct, or interface.</span></span>
*  <span data-ttu-id="ee99f-365">Das Überladen von Instanzkonstruktoren ermöglicht einer Klasse oder Struktur das Deklarieren mehrerer Instanzkonstruktoren, vorausgesetzt, ihre Signaturen sind innerhalb dieser Klasse oder Struktur eindeutig.</span><span class="sxs-lookup"><span data-stu-id="ee99f-365">Overloading of instance constructors permits a class or struct to declare multiple instance constructors, provided their signatures are unique within that class or struct.</span></span>
*  <span data-ttu-id="ee99f-366">Das Überladen von indexatoren ermöglicht es einer Klasse, Struktur oder Schnittstelle, mehrere Indexer zu deklarieren, vorausgesetzt, ihre Signaturen sind innerhalb dieser Klasse, Struktur oder Schnittstelle eindeutig.</span><span class="sxs-lookup"><span data-stu-id="ee99f-366">Overloading of indexers permits a class, struct, or interface to declare multiple indexers, provided their signatures are unique within that class, struct, or interface.</span></span>
*  <span data-ttu-id="ee99f-367">Das Überladen von Operatoren ermöglicht einer Klasse oder Struktur das Deklarieren mehrerer Operatoren mit demselben Namen, vorausgesetzt, ihre Signaturen sind innerhalb dieser Klasse oder Struktur eindeutig.</span><span class="sxs-lookup"><span data-stu-id="ee99f-367">Overloading of operators permits a class or struct to declare multiple operators with the same name, provided their signatures are unique within that class or struct.</span></span>

<span data-ttu-id="ee99f-368">Obwohl `out`-und `ref`-Parametermodifizierer als Teil einer Signatur angesehen werden, können in einem einzelnen Typ deklarierte Member nicht in der Signatur ausschließlich von `ref` und `out` abweichen.</span><span class="sxs-lookup"><span data-stu-id="ee99f-368">Although `out` and `ref` parameter modifiers are considered part of a signature, members declared in a single type cannot differ in signature solely by `ref` and `out`.</span></span> <span data-ttu-id="ee99f-369">Ein Kompilierzeitfehler tritt auf, wenn zwei Member im gleichen Typ mit Signaturen deklariert werden, die identisch wären, wenn alle Parameter in beiden Methoden mit `out`-modifiziererelementen in `ref`-modifiziererer geändert wurden.</span><span class="sxs-lookup"><span data-stu-id="ee99f-369">A compile-time error occurs if two members are declared in the same type with signatures that would be the same if all parameters in both methods with `out` modifiers were changed to `ref` modifiers.</span></span> <span data-ttu-id="ee99f-370">Für andere Zwecke des Signatur Abgleich (z. b. ausblenden oder überschreiben) werden die `ref` und `out` als Teil der Signatur angesehen und stimmen nicht überein.</span><span class="sxs-lookup"><span data-stu-id="ee99f-370">For other purposes of signature matching (e.g., hiding or overriding), `ref` and `out` are considered part of the signature and do not match each other.</span></span> <span data-ttu-id="ee99f-371">(Diese Einschränkung besteht darin, C# dass Programme auf einfache Weise für die Common Language Infrastructure (CLI) übersetzt werden können, die keine Möglichkeit bietet, Methoden zu definieren, die sich nur in `ref` und `out` unterscheiden.)</span><span class="sxs-lookup"><span data-stu-id="ee99f-371">(This restriction is to allow C#  programs to be easily translated to run on the Common Language Infrastructure (CLI), which does not provide a way to define methods that differ solely in `ref` and `out`.)</span></span>

<span data-ttu-id="ee99f-372">Für Signaturen werden die Typen `object` und `dynamic` als identisch betrachtet.</span><span class="sxs-lookup"><span data-stu-id="ee99f-372">For the purposes of signatures, the types `object` and `dynamic` are considered the same.</span></span> <span data-ttu-id="ee99f-373">Member, die in einem einzelnen Typ deklariert werden, können sich daher nicht nur durch `object` und `dynamic` in der Signatur unterscheiden.</span><span class="sxs-lookup"><span data-stu-id="ee99f-373">Members declared in a single type can therefore not differ in signature solely by `object` and `dynamic`.</span></span>

<span data-ttu-id="ee99f-374">Das folgende Beispiel zeigt eine Reihe von überladenen Methoden Deklarationen zusammen mit ihren Signaturen.</span><span class="sxs-lookup"><span data-stu-id="ee99f-374">The following example shows a set of overloaded method declarations along with their signatures.</span></span>
```csharp
interface ITest
{
    void F();                        // F()

    void F(int x);                   // F(int)

    void F(ref int x);               // F(ref int)

    void F(out int x);               // F(out int)      error

    void F(int x, int y);            // F(int, int)

    int F(string s);                 // F(string)

    int F(int x);                    // F(int)          error

    void F(string[] a);              // F(string[])

    void F(params string[] a);       // F(string[])     error
}
```

<span data-ttu-id="ee99f-375">Beachten Sie, dass die Parametermodifizierer "`ref`" und "`out`" ([Methoden Parameter](classes.md#method-parameters)) Teil einer Signatur sind.</span><span class="sxs-lookup"><span data-stu-id="ee99f-375">Note that any `ref` and `out` parameter modifiers ([Method parameters](classes.md#method-parameters)) are part of a signature.</span></span> <span data-ttu-id="ee99f-376">Daher sind `F(int)` und `F(ref int)` eindeutige Signaturen.</span><span class="sxs-lookup"><span data-stu-id="ee99f-376">Thus, `F(int)` and `F(ref int)` are unique signatures.</span></span> <span data-ttu-id="ee99f-377">Allerdings können `F(ref int)` und `F(out int)` nicht innerhalb derselben Schnittstelle deklariert werden, da sich Ihre Signaturen ausschließlich durch `ref` und `out` unterscheiden.</span><span class="sxs-lookup"><span data-stu-id="ee99f-377">However, `F(ref int)` and `F(out int)` cannot be declared within the same interface because their signatures differ solely by `ref` and `out`.</span></span> <span data-ttu-id="ee99f-378">Beachten Sie außerdem, dass der Rückgabetyp und der `params`-Modifizierer nicht Teil einer Signatur sind. Daher ist es nicht möglich, nur auf der Grundlage des Rückgabe Typs oder auf dem einschließen oder ausschließen des `params`-Modifizierers zu überladen.</span><span class="sxs-lookup"><span data-stu-id="ee99f-378">Also, note that the return type and the `params` modifier are not part of a signature, so it is not possible to overload solely based on return type or on the inclusion or exclusion of the `params` modifier.</span></span> <span data-ttu-id="ee99f-379">Daher führen die Deklarationen der oben identifizierten Methoden `F(int)` und `F(params string[])` zu einem Kompilierzeitfehler.</span><span class="sxs-lookup"><span data-stu-id="ee99f-379">As such, the declarations of the methods `F(int)` and `F(params string[])` identified above result in a compile-time error.</span></span>

## <a name="scopes"></a><span data-ttu-id="ee99f-380">Bereiche</span><span class="sxs-lookup"><span data-stu-id="ee99f-380">Scopes</span></span>

<span data-ttu-id="ee99f-381">Der Gültigkeitsbereich eines Namens ist der ***Bereich*** des Programm Texts, in dem auf die durch den Namen deklarierte Entität ohne Qualifikation des Namens verwiesen werden kann.</span><span class="sxs-lookup"><span data-stu-id="ee99f-381">The ***scope*** of a name is the region of program text within which it is possible to refer to the entity declared by the name without qualification of the name.</span></span> <span data-ttu-id="ee99f-382">Bereiche können ***geschachtelt***werden, und ein innerer Bereich kann die Bedeutung eines Namens aus einem äußeren Gültigkeitsbereich neu deklarieren (Dies bedeutet jedoch nicht, dass die Einschränkung, die von [Deklarationen aufgrund von Deklarationen](basic-concepts.md#declarations) in einem geschachtelten Block festgelegt wird, nicht möglich ist, eine lokale Variable mit dem gleicher Name wie eine lokale Variable in einem einschließenden-Block).</span><span class="sxs-lookup"><span data-stu-id="ee99f-382">Scopes can be ***nested***, and an inner scope may redeclare the meaning of a name from an outer scope (this does not, however, remove the restriction imposed by [Declarations](basic-concepts.md#declarations) that within a nested block it is not possible to declare a local variable with the same name as a local variable in an enclosing block).</span></span> <span data-ttu-id="ee99f-383">Der Name aus dem äußeren Gültigkeitsbereich wird dann in der vom inneren Bereich behandelten Programm Textzeile ***ausgeblendet*** , und der Zugriff auf den äußeren Namen ist nur durch Qualifizierung des Namens möglich.</span><span class="sxs-lookup"><span data-stu-id="ee99f-383">The name from the outer scope is then said to be ***hidden*** in the region of program text covered by the inner scope, and access to the outer name is only possible by qualifying the name.</span></span>

*  <span data-ttu-id="ee99f-384">Der Gültigkeitsbereich eines Namespace Members, der von einem *namespace_member_declaration* ([Namespace](namespaces.md#namespace-members)-Member) ohne einschließendes *namespace_declaration* deklariert wird, ist der gesamte Programmtext.</span><span class="sxs-lookup"><span data-stu-id="ee99f-384">The scope of a namespace member declared by a *namespace_member_declaration* ([Namespace members](namespaces.md#namespace-members)) with no enclosing *namespace_declaration* is the entire program text.</span></span>
*  <span data-ttu-id="ee99f-385">Der Gültigkeitsbereich eines Namespace Members, der von einem *namespace_member_declaration* innerhalb eines *namespace_declaration* deklariert wird, dessen voll qualifizierter Name `N` ist, ist die *namespace_body* jedes *namespace_declaration* , dessen vollständig der qualifizierte Name ist `N` oder beginnt mit `N`, gefolgt von einem bestimmten Zeitraum.</span><span class="sxs-lookup"><span data-stu-id="ee99f-385">The scope of a namespace member declared by a *namespace_member_declaration* within a *namespace_declaration* whose fully qualified name is `N` is the *namespace_body* of every *namespace_declaration* whose fully qualified name is `N` or starts with `N`, followed by a period.</span></span>
*  <span data-ttu-id="ee99f-386">Der durch ein *extern_alias_directive* definierte Bereich des Namens erstreckt sich über die *using_directive*s, *global_attributes* und *namespace_member_declaration*s der unmittelbar enthaltenden Kompilierungseinheit oder des Namespace Texts.</span><span class="sxs-lookup"><span data-stu-id="ee99f-386">The scope of name defined by an *extern_alias_directive* extends over the *using_directive*s, *global_attributes* and *namespace_member_declaration*s of its immediately containing compilation unit or namespace body.</span></span> <span data-ttu-id="ee99f-387">Ein *extern_alias_directive* führt keine neuen Member zum zugrunde liegenden Deklarations Bereich ein.</span><span class="sxs-lookup"><span data-stu-id="ee99f-387">An *extern_alias_directive* does not contribute any new members to the underlying declaration space.</span></span> <span data-ttu-id="ee99f-388">Anders ausgedrückt: ein *extern_alias_directive* -Wert ist nicht transitiv, sondern wirkt sich nur auf die Kompilierungseinheit oder den Namespace Körper aus, in dem er auftritt.</span><span class="sxs-lookup"><span data-stu-id="ee99f-388">In other words, an *extern_alias_directive* is not transitive, but, rather, affects only the compilation unit or namespace body in which it occurs.</span></span>
*  <span data-ttu-id="ee99f-389">Der Bereich eines Namens, der von einem *using_directive* (using-[Direktiven](namespaces.md#using-directives)) definiert oder importiert wird, erstreckt sich über die *namespace_member_declaration*s von *compilation_unit* oder *namespace_body* , in denen das *using_directive* tritt auf.</span><span class="sxs-lookup"><span data-stu-id="ee99f-389">The scope of a name defined or imported by a *using_directive* ([Using directives](namespaces.md#using-directives)) extends over the *namespace_member_declaration*s of the *compilation_unit* or *namespace_body* in which the *using_directive* occurs.</span></span> <span data-ttu-id="ee99f-390">Ein *using_directive* kann NULL oder mehr Namespace-, Typ-oder Elementnamen innerhalb eines bestimmten *compilation_unit* oder *namespace_body*zur Verfügung stellen, führt jedoch keine neuen Member zum zugrunde liegenden Deklarations Bereich.</span><span class="sxs-lookup"><span data-stu-id="ee99f-390">A *using_directive* may make zero or more namespace, type or member names available within a particular *compilation_unit* or *namespace_body*, but does not contribute any new members to the underlying declaration space.</span></span> <span data-ttu-id="ee99f-391">Anders ausgedrückt: ein *using_directive* -Wert ist nicht transitiv, sondern wirkt sich nur auf den *compilation_unit* oder *namespace_body* aus, in dem er auftritt.</span><span class="sxs-lookup"><span data-stu-id="ee99f-391">In other words, a *using_directive* is not transitive but rather affects only the *compilation_unit* or *namespace_body* in which it occurs.</span></span>
*  <span data-ttu-id="ee99f-392">Der Gültigkeitsbereich eines Typparameters, der von einem *type_parameter_list* -Wert in einem *class_declaration* ([Klassen Deklarationen](classes.md#class-declarations)) deklariert wird, sind *class_base*, *type_parameter_constraints_clause*s und *class_body* der  *class_declaration*.</span><span class="sxs-lookup"><span data-stu-id="ee99f-392">The scope of a type parameter declared by a *type_parameter_list* on a *class_declaration* ([Class declarations](classes.md#class-declarations)) is the *class_base*, *type_parameter_constraints_clause*s, and *class_body* of that *class_declaration*.</span></span>
*  <span data-ttu-id="ee99f-393">Der Gültigkeitsbereich eines Typparameters, der durch eine *type_parameter_list* -Deklaration in einem *struct_declaration* ([Struktur Deklarationen](structs.md#struct-declarations)) deklariert wird, sind *struct_interfaces*, *type_parameter_constraints_clause*s und *struct_body* von Diese *struct_declaration*.</span><span class="sxs-lookup"><span data-stu-id="ee99f-393">The scope of a type parameter declared by a *type_parameter_list* on a *struct_declaration* ([Struct declarations](structs.md#struct-declarations)) is the *struct_interfaces*, *type_parameter_constraints_clause*s, and *struct_body* of that *struct_declaration*.</span></span>
*  <span data-ttu-id="ee99f-394">Der Gültigkeitsbereich eines Typparameters, der durch eine *type_parameter_list* -Deklaration in einer *interface_declaration* ([Schnittstellen Deklaration](interfaces.md#interface-declarations)) deklariert wird, sind *interface_base*, *type_parameter_constraints_clause*s und *interface_body* dieses *interface_declaration*.</span><span class="sxs-lookup"><span data-stu-id="ee99f-394">The scope of a type parameter declared by a *type_parameter_list* on an *interface_declaration* ([Interface declarations](interfaces.md#interface-declarations)) is the *interface_base*, *type_parameter_constraints_clause*s, and *interface_body* of that *interface_declaration*.</span></span>
*  <span data-ttu-id="ee99f-395">Der Gültigkeitsbereich eines Typparameters, der von einem *type_parameter_list* -Objekt in einem *delegate_declaration* ([Delegatdeklarationen](delegates.md#delegate-declarations)) deklariert wird, sind *return_type*, *formal_parameter_list*und *type_parameter_constraints_clause.* s dieses *delegate_declaration*.</span><span class="sxs-lookup"><span data-stu-id="ee99f-395">The scope of a type parameter declared by a *type_parameter_list* on a *delegate_declaration* ([Delegate declarations](delegates.md#delegate-declarations)) is the *return_type*, *formal_parameter_list*, and *type_parameter_constraints_clause*s of that *delegate_declaration*.</span></span>
*  <span data-ttu-id="ee99f-396">Der Gültigkeitsbereich eines Members, der von einem *class_member_declaration* ([Klassen Text](classes.md#class-body)) deklariert wird, ist die *class_body* , in der die Deklaration auftritt.</span><span class="sxs-lookup"><span data-stu-id="ee99f-396">The scope of a member declared by a *class_member_declaration* ([Class body](classes.md#class-body)) is the *class_body* in which the declaration occurs.</span></span> <span data-ttu-id="ee99f-397">Außerdem erstreckt sich der Gültigkeitsbereich eines Klassenmembers auf den *class_body* der abgeleiteten Klassen, die in der Zugriffs Domäne ([Barrierefreiheits Domänen](basic-concepts.md#accessibility-domains)) des Members enthalten sind.</span><span class="sxs-lookup"><span data-stu-id="ee99f-397">In addition, the scope of a class member extends to the *class_body* of those derived classes that are included in the accessibility domain ([Accessibility domains](basic-concepts.md#accessibility-domains)) of the member.</span></span>
*  <span data-ttu-id="ee99f-398">Der Gültigkeitsbereich eines Members, der von einem *struct_member_declaration* ([Strukturmember](structs.md#struct-members)) deklariert wird, ist die *struct_body* , in der die Deklaration erfolgt.</span><span class="sxs-lookup"><span data-stu-id="ee99f-398">The scope of a member declared by a *struct_member_declaration* ([Struct members](structs.md#struct-members)) is the *struct_body* in which the declaration occurs.</span></span>
*  <span data-ttu-id="ee99f-399">Der Gültigkeitsbereich eines Members, der von einem *enum_member_declaration* ([enum](enums.md#enum-members)-Member) deklariert wird, ist die *enum_body* , in der die Deklaration erfolgt.</span><span class="sxs-lookup"><span data-stu-id="ee99f-399">The scope of a member declared by an *enum_member_declaration*  ([Enum members](enums.md#enum-members)) is the *enum_body* in which the declaration occurs.</span></span>
*  <span data-ttu-id="ee99f-400">Der Gültigkeitsbereich eines in *method_declaration* ([Methoden](classes.md#methods)) deklarierten Parameters ist der *method_body* dieses *method_declaration*.</span><span class="sxs-lookup"><span data-stu-id="ee99f-400">The scope of a parameter declared in a *method_declaration* ([Methods](classes.md#methods)) is the *method_body* of that *method_declaration*.</span></span>
*  <span data-ttu-id="ee99f-401">Der Gültigkeitsbereich eines in einem *indexer_declaration* ([Indexer](classes.md#indexers)) deklarierten Parameters ist der *accessor_declarations* dieses *indexer_declaration*.</span><span class="sxs-lookup"><span data-stu-id="ee99f-401">The scope of a parameter declared in an *indexer_declaration* ([Indexers](classes.md#indexers)) is the *accessor_declarations* of that *indexer_declaration*.</span></span>
*  <span data-ttu-id="ee99f-402">Der Gültigkeitsbereich eines in *operator_declaration* ([Operatoren](classes.md#operators)) deklarierten Parameters ist der *Block* dieser *operator_declaration*.</span><span class="sxs-lookup"><span data-stu-id="ee99f-402">The scope of a parameter declared in an *operator_declaration* ([Operators](classes.md#operators)) is the *block* of that *operator_declaration*.</span></span>
*  <span data-ttu-id="ee99f-403">Der Gültigkeitsbereich eines in einem *constructor_declaration* ([Instanzkonstruktors](classes.md#instance-constructors)) deklarierten Parameters ist der *constructor_initializer* und *Block* dieses *constructor_declaration*.</span><span class="sxs-lookup"><span data-stu-id="ee99f-403">The scope of a parameter declared in a *constructor_declaration* ([Instance constructors](classes.md#instance-constructors)) is the *constructor_initializer* and *block* of that *constructor_declaration*.</span></span>
*  <span data-ttu-id="ee99f-404">Der Gültigkeitsbereich eines in einem *lambda_expression* ([anonymen Funktions Ausdruck](expressions.md#anonymous-function-expressions)) deklarierten Parameters ist *anonymous_function_body* dieser *lambda_expression*</span><span class="sxs-lookup"><span data-stu-id="ee99f-404">The scope of a parameter declared in a *lambda_expression* ([Anonymous function expressions](expressions.md#anonymous-function-expressions)) is the *anonymous_function_body* of that *lambda_expression*</span></span>
*  <span data-ttu-id="ee99f-405">Der Gültigkeitsbereich eines in einem *anonymous_method_expression* ([anonymen Funktions Ausdruck](expressions.md#anonymous-function-expressions)) deklarierten Parameters ist der *Block* dieser *anonymous_method_expression*.</span><span class="sxs-lookup"><span data-stu-id="ee99f-405">The scope of a parameter declared in an *anonymous_method_expression* ([Anonymous function expressions](expressions.md#anonymous-function-expressions)) is the *block* of that *anonymous_method_expression*.</span></span>
*  <span data-ttu-id="ee99f-406">Der Gültigkeitsbereich einer Bezeichnung, die in einer *labeled_statement* -[Anweisung (bezeichnet](statements.md#labeled-statements)) deklariert ist, ist der *Block* , in dem die Deklaration auftritt.</span><span class="sxs-lookup"><span data-stu-id="ee99f-406">The scope of a label declared in a *labeled_statement* ([Labeled statements](statements.md#labeled-statements)) is the *block* in which the declaration occurs.</span></span>
*  <span data-ttu-id="ee99f-407">Der Gültigkeitsbereich einer lokalen Variablen, die in einem *local_variable_declaration* ([lokale Variablen Deklarationen](statements.md#local-variable-declarations)) deklariert ist, ist der Block, in dem die Deklaration auftritt.</span><span class="sxs-lookup"><span data-stu-id="ee99f-407">The scope of a local variable declared in a *local_variable_declaration* ([Local variable declarations](statements.md#local-variable-declarations)) is the block in which the declaration occurs.</span></span>
*  <span data-ttu-id="ee99f-408">Der Gültigkeitsbereich einer lokalen Variablen, die in einer *switch_block* -Anweisung einer `switch`-Anweisung ([der Switch-Anweisung](statements.md#the-switch-statement)) deklariert ist, ist *switch_block*.</span><span class="sxs-lookup"><span data-stu-id="ee99f-408">The scope of a local variable declared in a *switch_block* of a `switch` statement ([The switch statement](statements.md#the-switch-statement)) is the *switch_block*.</span></span>
*  <span data-ttu-id="ee99f-409">Der Gültigkeitsbereich einer lokalen Variablen, die in einer *for_initializer* -Anweisung einer `for`-Anweisung deklariert ist ([for-Anweisung](statements.md#the-for-statement)), ist *for_initializer*, *for_condition*, *for_iterator*und die enthaltene *Anweisung* von `for`-Anweisung.</span><span class="sxs-lookup"><span data-stu-id="ee99f-409">The scope of a local variable declared in a *for_initializer* of a `for` statement ([The for statement](statements.md#the-for-statement)) is the *for_initializer*, the *for_condition*, the *for_iterator*, and the contained *statement* of the `for` statement.</span></span>
*  <span data-ttu-id="ee99f-410">Der Gültigkeitsbereich einer lokalen Konstante, die in *local_constant_declaration* ([lokale Konstante Deklarationen](statements.md#local-constant-declarations)) deklariert ist, ist der Block, in dem die Deklaration auftritt.</span><span class="sxs-lookup"><span data-stu-id="ee99f-410">The scope of a local constant declared in a *local_constant_declaration* ([Local constant declarations](statements.md#local-constant-declarations)) is the block in which the declaration occurs.</span></span> <span data-ttu-id="ee99f-411">Es handelt sich um einen Kompilierzeitfehler, der auf eine lokale Konstante in einer Textposition verweist, die dem *constant_declarator*vorangestellt ist.</span><span class="sxs-lookup"><span data-stu-id="ee99f-411">It is a compile-time error to refer to a local constant in a textual position that precedes its *constant_declarator*.</span></span>
*  <span data-ttu-id="ee99f-412">Der Gültigkeitsbereich einer Variablen, die als Teil von *foreach_statement*, *using_statement*, *lock_statement* oder *query_expression* deklariert ist, wird durch die Erweiterung des angegebenen Konstrukts bestimmt.</span><span class="sxs-lookup"><span data-stu-id="ee99f-412">The scope of a variable declared as part of a *foreach_statement*, *using_statement*, *lock_statement* or *query_expression* is determined by the expansion of the given construct.</span></span>

<span data-ttu-id="ee99f-413">Innerhalb des Gültigkeits Bereichs eines Namespace, einer Klasse, einer Struktur oder eines Enumerationsmembers kann auf das Element in einer Textposition verwiesen werden, die der Deklaration des Members vorangestellt ist.</span><span class="sxs-lookup"><span data-stu-id="ee99f-413">Within the scope of a namespace, class, struct, or enumeration member it is possible to refer to the member in a textual position that precedes the declaration of the member.</span></span> <span data-ttu-id="ee99f-414">Beispiel:</span><span class="sxs-lookup"><span data-stu-id="ee99f-414">For example</span></span>
```csharp
class A
{
    void F() {
        i = 1;
    }

    int i = 0;
}
```
<span data-ttu-id="ee99f-415">Hier ist es gültig, dass `F` auf `i` verweist, bevor es deklariert wird.</span><span class="sxs-lookup"><span data-stu-id="ee99f-415">Here, it is valid for `F` to refer to `i` before it is declared.</span></span>

<span data-ttu-id="ee99f-416">Innerhalb des Gültigkeits Bereichs einer lokalen Variablen ist dies ein Kompilierzeitfehler, der auf die lokale Variable in einer Textposition verweist, die dem *local_variable_declarator* der lokalen Variablen vorangestellt ist.</span><span class="sxs-lookup"><span data-stu-id="ee99f-416">Within the scope of a local variable, it is a compile-time error to refer to the local variable in a textual position that precedes the *local_variable_declarator* of the local variable.</span></span> <span data-ttu-id="ee99f-417">Beispiel:</span><span class="sxs-lookup"><span data-stu-id="ee99f-417">For example</span></span>
```csharp
class A
{
    int i = 0;

    void F() {
        i = 1;                  // Error, use precedes declaration
        int i;
        i = 2;
    }

    void G() {
        int j = (j = 1);        // Valid
    }

    void H() {
        int a = 1, b = ++a;    // Valid
    }
}
```

<span data-ttu-id="ee99f-418">In der obigen Methode `F` verweist die erste Zuweisung an `i` nicht auf das im äußeren Gültigkeitsbereich deklarierte Feld.</span><span class="sxs-lookup"><span data-stu-id="ee99f-418">In the `F` method above, the first assignment to `i` specifically does not refer to the field declared in the outer scope.</span></span> <span data-ttu-id="ee99f-419">Stattdessen verweist Sie auf die lokale Variable und führt zu einem Kompilierzeitfehler, da Sie sich textumal der Deklaration der Variablen vorangestellt ist.</span><span class="sxs-lookup"><span data-stu-id="ee99f-419">Rather, it refers to the local variable and it results in a compile-time error because it textually precedes the declaration of the variable.</span></span> <span data-ttu-id="ee99f-420">In der `G`-Methode ist die Verwendung von `j` im Initialisierer für die Deklaration von `j` gültig, da die Verwendung dem *local_variable_declarator*nicht vorangestellt ist.</span><span class="sxs-lookup"><span data-stu-id="ee99f-420">In the `G` method, the use of `j` in the initializer for the declaration of `j` is valid because the use does not precede the *local_variable_declarator*.</span></span> <span data-ttu-id="ee99f-421">In der `H`-Methode verweist eine nachfolgende *local_variable_declarator* ordnungsgemäß auf eine lokale Variable, die in einem früheren *local_variable_declarator* innerhalb desselben *local_variable_declaration*deklariert wurde.</span><span class="sxs-lookup"><span data-stu-id="ee99f-421">In the `H` method, a subsequent *local_variable_declarator* correctly refers to a local variable declared in an earlier *local_variable_declarator* within the same *local_variable_declaration*.</span></span>

<span data-ttu-id="ee99f-422">Die Bereichs Regeln für lokale Variablen dienen dazu, sicherzustellen, dass die Bedeutung eines Namens, der in einem Ausdrucks Kontext verwendet wird, innerhalb eines-Blocks immer identisch ist.</span><span class="sxs-lookup"><span data-stu-id="ee99f-422">The scoping rules for local variables are designed to guarantee that the meaning of a name used in an expression context is always the same within a block.</span></span> <span data-ttu-id="ee99f-423">Wenn der Gültigkeitsbereich einer lokalen Variablen nur von der Deklaration bis zum Ende des Blocks erweitert werden soll, wird im obigen Beispiel die erste Zuweisung der Instanzvariablen zugewiesen, und die zweite Zuweisung würde der lokalen Variablen zugewiesen, was möglicherweise zu Kompilierzeitfehler, wenn die Anweisungen des Blocks später neu angeordnet wurden.</span><span class="sxs-lookup"><span data-stu-id="ee99f-423">If the scope of a local variable were to extend only from its declaration to the end of the block, then in the example above, the first assignment would assign to the instance variable and the second assignment would assign to the local variable, possibly leading to compile-time errors if the statements of the block were later to be rearranged.</span></span>

<span data-ttu-id="ee99f-424">Die Bedeutung eines Namens innerhalb eines-Blocks kann sich je nach Kontext unterscheiden, in dem der Name verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="ee99f-424">The meaning of a name within a block may differ based on the context in which the name is used.</span></span> <span data-ttu-id="ee99f-425">Im Beispiel</span><span class="sxs-lookup"><span data-stu-id="ee99f-425">In the example</span></span>
```csharp
using System;

class A {}

class Test
{
    static void Main() {
        string A = "hello, world";
        string s = A;                            // expression context

        Type t = typeof(A);                      // type context

        Console.WriteLine(s);                    // writes "hello, world"
        Console.WriteLine(t);                    // writes "A"
    }
}
```
<span data-ttu-id="ee99f-426">der Name `A` wird in einem Ausdrucks Kontext verwendet, um auf die lokale Variable `A` und in einem typkontext zu verweisen, um auf die-Klasse `A` zu verweisen.</span><span class="sxs-lookup"><span data-stu-id="ee99f-426">the name `A` is used in an expression context to refer to the local variable `A` and in a type context to refer to the class `A`.</span></span>

### <a name="name-hiding"></a><span data-ttu-id="ee99f-427">Namens ausblenden</span><span class="sxs-lookup"><span data-stu-id="ee99f-427">Name hiding</span></span>

<span data-ttu-id="ee99f-428">Der Gültigkeitsbereich einer Entität umfasst in der Regel mehr Programmtext als der Deklarations Bereich der Entität.</span><span class="sxs-lookup"><span data-stu-id="ee99f-428">The scope of an entity typically encompasses more program text than the declaration space of the entity.</span></span> <span data-ttu-id="ee99f-429">Der Gültigkeitsbereich einer Entität kann insbesondere Deklarationen enthalten, die neue Deklarations Bereiche mit Entitäten mit demselben Namen enthalten.</span><span class="sxs-lookup"><span data-stu-id="ee99f-429">In particular, the scope of an entity may include declarations that introduce new declaration spaces containing entities of the same name.</span></span> <span data-ttu-id="ee99f-430">Diese Deklarationen bewirken, dass die ursprüngliche Entität ***ausgeblendet***wird.</span><span class="sxs-lookup"><span data-stu-id="ee99f-430">Such declarations cause the original entity to become ***hidden***.</span></span> <span data-ttu-id="ee99f-431">Umgekehrt wird eine Entität als ***sichtbar*** angezeigt, wenn Sie nicht ausgeblendet ist.</span><span class="sxs-lookup"><span data-stu-id="ee99f-431">Conversely, an entity is said to be ***visible*** when it is not hidden.</span></span>

<span data-ttu-id="ee99f-432">Das Ausblenden von Namen tritt auf, wenn sich Bereiche überlappen</span><span class="sxs-lookup"><span data-stu-id="ee99f-432">Name hiding occurs when scopes overlap through nesting and when scopes overlap through inheritance.</span></span> <span data-ttu-id="ee99f-433">Die Merkmale der beiden Arten von ausblenden werden in den folgenden Abschnitten beschrieben.</span><span class="sxs-lookup"><span data-stu-id="ee99f-433">The characteristics of the two types of hiding are described in the following sections.</span></span>

#### <a name="hiding-through-nesting"></a><span data-ttu-id="ee99f-434">Ausblenden durch Schachtelung</span><span class="sxs-lookup"><span data-stu-id="ee99f-434">Hiding through nesting</span></span>

<span data-ttu-id="ee99f-435">Der Name, der durch Schachtelung ausgeblendet wird, kann als Ergebnis der Schachtelung von Namespaces oder Typen innerhalb von Namespaces auftreten, als Ergebnis der Schachtelung von Typen in Klassen oder Strukturen, und als Ergebnis von Parameter-und lokalen Variablen Deklarationen.</span><span class="sxs-lookup"><span data-stu-id="ee99f-435">Name hiding through nesting can occur as a result of nesting namespaces or types within namespaces, as a result of nesting types within classes or structs, and as a result of parameter and local variable declarations.</span></span>

<span data-ttu-id="ee99f-436">Im Beispiel</span><span class="sxs-lookup"><span data-stu-id="ee99f-436">In the example</span></span>
```csharp
class A
{
    int i = 0;

    void F() {
        int i = 1;
    }

    void G() {
        i = 1;
    }
}
```
<span data-ttu-id="ee99f-437">innerhalb der `F`-Methode wird die Instanzvariable `i` von der lokalen Variablen `i` ausgeblendet, aber innerhalb der `G`-Methode verweist `i` immer noch auf die Instanzvariable.</span><span class="sxs-lookup"><span data-stu-id="ee99f-437">within the `F` method, the instance variable `i` is hidden by the local variable `i`, but within the `G` method, `i` still refers to the instance variable.</span></span>

<span data-ttu-id="ee99f-438">Wenn ein Name in einem inneren Gültigkeitsbereich einen Namen in einem äußeren Gültigkeitsbereich verbirgt, werden alle überladenen Vorkommen dieses Namens ausgeblendet.</span><span class="sxs-lookup"><span data-stu-id="ee99f-438">When a name in an inner scope hides a name in an outer scope, it hides all overloaded occurrences of that name.</span></span> <span data-ttu-id="ee99f-439">Im Beispiel</span><span class="sxs-lookup"><span data-stu-id="ee99f-439">In the example</span></span>
```csharp
class Outer
{
    static void F(int i) {}

    static void F(string s) {}

    class Inner
    {
        void G() {
            F(1);              // Invokes Outer.Inner.F
            F("Hello");        // Error
        }

        static void F(long l) {}
    }
}
```
<span data-ttu-id="ee99f-440">der Aufruf `F(1)` ruft die in `Inner` deklarierte `F` auf, da alle äußeren Vorkommen von `F` durch die innere Deklaration ausgeblendet werden.</span><span class="sxs-lookup"><span data-stu-id="ee99f-440">the call `F(1)` invokes the `F` declared in `Inner` because all outer occurrences of `F` are hidden by the inner declaration.</span></span> <span data-ttu-id="ee99f-441">Aus demselben Grund führt der Aufruf `F("Hello")` zu einem Kompilierzeitfehler.</span><span class="sxs-lookup"><span data-stu-id="ee99f-441">For the same reason, the call `F("Hello")` results in a compile-time error.</span></span>

#### <a name="hiding-through-inheritance"></a><span data-ttu-id="ee99f-442">Ausblenden durch Vererbung</span><span class="sxs-lookup"><span data-stu-id="ee99f-442">Hiding through inheritance</span></span>

<span data-ttu-id="ee99f-443">Das Ausblenden des Namens durch Vererbung tritt auf, wenn Klassen oder Strukturen Namen, die von Basisklassen geerbt wurden, neu deklarieren.</span><span class="sxs-lookup"><span data-stu-id="ee99f-443">Name hiding through inheritance occurs when classes or structs redeclare names that were inherited from base classes.</span></span> <span data-ttu-id="ee99f-444">Diese Art von namens ausblenden hat eine der folgenden Formen:</span><span class="sxs-lookup"><span data-stu-id="ee99f-444">This type of name hiding takes one of the following forms:</span></span>

*  <span data-ttu-id="ee99f-445">Eine Konstante, ein Feld, eine Eigenschaft, ein Ereignis oder ein Typ, die in einer Klasse oder Struktur eingeführt wurde, verbergen alle Basisklassenmember mit demselben Namen.</span><span class="sxs-lookup"><span data-stu-id="ee99f-445">A constant, field, property, event, or type introduced in a class or struct hides all base class members with the same name.</span></span>
*  <span data-ttu-id="ee99f-446">Eine Methode, die in einer Klasse oder Struktur eingeführt wurde, verbirgt alle nicht-Method-Basisklassenmember mit demselben Namen und alle Basisklassen Methoden mit der gleichen Signatur (Methodenname und Parameter Anzahl, Modifizierer und Typen).</span><span class="sxs-lookup"><span data-stu-id="ee99f-446">A method introduced in a class or struct hides all non-method base class members with the same name, and all base class methods with the same signature (method name and parameter count, modifiers, and types).</span></span>
*  <span data-ttu-id="ee99f-447">Ein Indexer, der in einer Klasse oder Struktur eingeführt wurde, verbirgt alle Basisklassenindexer mit der gleichen Signatur (Parameter Anzahl und-Typen).</span><span class="sxs-lookup"><span data-stu-id="ee99f-447">An indexer introduced in a class or struct hides all base class indexers with the same signature (parameter count and types).</span></span>

<span data-ttu-id="ee99f-448">Die Regeln für Operator Deklarationen ([Operatoren](classes.md#operators)) machen es für eine abgeleitete Klasse unmöglich, einen Operator mit derselben Signatur wie ein Operator in einer Basisklasse zu deklarieren.</span><span class="sxs-lookup"><span data-stu-id="ee99f-448">The rules governing operator declarations ([Operators](classes.md#operators)) make it impossible for a derived class to declare an operator with the same signature as an operator in a base class.</span></span> <span data-ttu-id="ee99f-449">Folglich verbergen Operatoren nie eine andere.</span><span class="sxs-lookup"><span data-stu-id="ee99f-449">Thus, operators never hide one another.</span></span>

<span data-ttu-id="ee99f-450">Im Gegensatz zum Ausblenden eines Namens aus einem äußeren Gültigkeitsbereich bewirkt das Ausblenden eines zugänglichen namens aus einem geerbten Bereich, dass eine Warnung ausgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="ee99f-450">Contrary to hiding a name from an outer scope, hiding an accessible name from an inherited scope causes a warning to be reported.</span></span> <span data-ttu-id="ee99f-451">Im Beispiel</span><span class="sxs-lookup"><span data-stu-id="ee99f-451">In the example</span></span>
```csharp
class Base
{
    public void F() {}
}

class Derived: Base
{
    public void F() {}        // Warning, hiding an inherited name
}
```
<span data-ttu-id="ee99f-452">die Deklaration von "`F`" in `Derived` bewirkt, dass eine Warnung gemeldet wird.</span><span class="sxs-lookup"><span data-stu-id="ee99f-452">the declaration of `F` in `Derived` causes a warning to be reported.</span></span> <span data-ttu-id="ee99f-453">Das Ausblenden eines geerbten Namens ist kein Fehler, da dies die getrennte Weiterentwicklung von Basisklassen ausschließen würde.</span><span class="sxs-lookup"><span data-stu-id="ee99f-453">Hiding an inherited name is specifically not an error, since that would preclude separate evolution of base classes.</span></span> <span data-ttu-id="ee99f-454">Die obige Situation könnte z. b. eintreten, weil eine neuere Version von `Base` eine `F`-Methode eingeführt hat, die in einer früheren Version der Klasse nicht vorhanden war.</span><span class="sxs-lookup"><span data-stu-id="ee99f-454">For example, the above situation might have come about because a later version of `Base` introduced an `F` method that wasn't present in an earlier version of the class.</span></span> <span data-ttu-id="ee99f-455">Hätte die obige Situation einen Fehler verursacht, kann jede Änderung, die an einer Basisklasse in einer separat versionierten Klassenbibliothek vorgenommen wurde, möglicherweise dazu führen, dass abgeleitete Klassen ungültig werden.</span><span class="sxs-lookup"><span data-stu-id="ee99f-455">Had the above situation been an error, then any change made to a base class in a separately versioned class library could potentially cause derived classes to become invalid.</span></span>

<span data-ttu-id="ee99f-456">Die Warnung, die durch das Ausblenden eines geerbten Namens verursacht wurde, kann durch die Verwendung des `new`-Modifizierers gelöscht werden:</span><span class="sxs-lookup"><span data-stu-id="ee99f-456">The warning caused by hiding an inherited name can be eliminated through use of the `new` modifier:</span></span>
```csharp
class Base
{
    public void F() {}
}

class Derived: Base
{
    new public void F() {}
}
```

<span data-ttu-id="ee99f-457">Der `new`-Modifizierer gibt an, dass der `F` in `Derived` "New" ist, und dass er tatsächlich dazu gedacht ist, den geerbten Member auszublenden.</span><span class="sxs-lookup"><span data-stu-id="ee99f-457">The `new` modifier indicates that the `F` in `Derived` is "new", and that it is indeed intended to hide the inherited member.</span></span>

<span data-ttu-id="ee99f-458">Eine Deklaration eines neuen Members verbirgt einen geerbten Member nur innerhalb des Gültigkeits Bereichs des neuen Members.</span><span class="sxs-lookup"><span data-stu-id="ee99f-458">A declaration of a new member hides an inherited member only within the scope of the new member.</span></span>

```csharp
class Base
{
    public static void F() {}
}

class Derived: Base
{
    new private static void F() {}    // Hides Base.F in Derived only
}

class MoreDerived: Derived
{
    static void G() { F(); }          // Invokes Base.F
}
```

<span data-ttu-id="ee99f-459">Im obigen Beispiel blendet die Deklaration von `F` in `Derived` die `F` aus, die von `Base` geerbt wurde. da der neue `F` in `Derived` jedoch über privaten Zugriff verfügt, wird sein Bereich nicht auf `MoreDerived` erweitert.</span><span class="sxs-lookup"><span data-stu-id="ee99f-459">In the example above, the declaration of `F` in `Derived` hides the `F` that was inherited from `Base`, but since the new `F` in `Derived` has private access, its scope does not extend to `MoreDerived`.</span></span> <span data-ttu-id="ee99f-460">Daher ist der Aufruf `F()` in `MoreDerived.G` gültig und wird `Base.F` aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="ee99f-460">Thus, the call `F()` in `MoreDerived.G` is valid and will invoke `Base.F`.</span></span>

## <a name="namespace-and-type-names"></a><span data-ttu-id="ee99f-461">Namespace-und Typnamen</span><span class="sxs-lookup"><span data-stu-id="ee99f-461">Namespace and type names</span></span>

<span data-ttu-id="ee99f-462">Mehrere Kontexte in einem C# Programm erfordern, dass ein *namespace_name* oder ein *TYPE_NAME* angegeben wird.</span><span class="sxs-lookup"><span data-stu-id="ee99f-462">Several contexts in a C# program require a *namespace_name* or a *type_name* to be specified.</span></span>

```antlr
namespace_name
    : namespace_or_type_name
    ;

type_name
    : namespace_or_type_name
    ;

namespace_or_type_name
    : identifier type_argument_list?
    | namespace_or_type_name '.' identifier type_argument_list?
    | qualified_alias_member
    ;
```

<span data-ttu-id="ee99f-463">Ein *namespace_name* ist eine *namespace_or_type_name* , die auf einen Namespace verweist.</span><span class="sxs-lookup"><span data-stu-id="ee99f-463">A *namespace_name* is a *namespace_or_type_name* that refers to a namespace.</span></span> <span data-ttu-id="ee99f-464">Gemäß der unten beschriebenen Auflösung muss *namespace_or_type_name* eines *namespace_name* auf einen Namespace verweisen, andernfalls tritt ein Kompilierzeitfehler auf.</span><span class="sxs-lookup"><span data-stu-id="ee99f-464">Following resolution as described below, the *namespace_or_type_name* of a *namespace_name* must refer to a namespace, or otherwise a compile-time error occurs.</span></span> <span data-ttu-id="ee99f-465">In einem *namespace_name* -Typ können keine Typargumente ([Typargumente](types.md#type-arguments)) vorhanden sein (nur Typen können Typargumente aufweisen).</span><span class="sxs-lookup"><span data-stu-id="ee99f-465">No type arguments ([Type arguments](types.md#type-arguments)) can be present in a *namespace_name* (only types can have type arguments).</span></span>

<span data-ttu-id="ee99f-466">Ein *TYPE_NAME* ist ein *namespace_or_type_name* , das auf einen Typ verweist.</span><span class="sxs-lookup"><span data-stu-id="ee99f-466">A *type_name* is a *namespace_or_type_name* that refers to a type.</span></span> <span data-ttu-id="ee99f-467">Gemäß der unten beschriebenen Auflösung muss *namespace_or_type_name* eines *TYPE_NAME* auf einen Typ verweisen, andernfalls tritt ein Kompilierzeitfehler auf.</span><span class="sxs-lookup"><span data-stu-id="ee99f-467">Following resolution as described below, the *namespace_or_type_name* of a *type_name* must refer to a type, or otherwise a compile-time error occurs.</span></span>

<span data-ttu-id="ee99f-468">Wenn *namespace_or_type_name* ein Qualified-Alias-Member ist, wird die Bedeutung in [Namespacealias-Qualifizierern](namespaces.md#namespace-alias-qualifiers)beschrieben.</span><span class="sxs-lookup"><span data-stu-id="ee99f-468">If the *namespace_or_type_name* is a qualified-alias-member its meaning is as described in [Namespace alias qualifiers](namespaces.md#namespace-alias-qualifiers).</span></span> <span data-ttu-id="ee99f-469">Andernfalls hat eine *namespace_or_type_name* eine von vier Formularen:</span><span class="sxs-lookup"><span data-stu-id="ee99f-469">Otherwise, a *namespace_or_type_name* has one of four forms:</span></span>

*  `I`
*  `I<A1, ..., Ak>`
*  `N.I`
*  `N.I<A1, ..., Ak>`

<span data-ttu-id="ee99f-470">Wenn `I` ein einzelner Bezeichner ist, ist `N` ein *namespace_or_type_name* und `<A1, ..., Ak>` ein optionales *type_argument_list*.</span><span class="sxs-lookup"><span data-stu-id="ee99f-470">where `I` is a single identifier, `N` is a *namespace_or_type_name* and `<A1, ..., Ak>` is an optional *type_argument_list*.</span></span> <span data-ttu-id="ee99f-471">Wenn *type_argument_list* nicht angegeben ist, sollten Sie `k` NULL sein.</span><span class="sxs-lookup"><span data-stu-id="ee99f-471">When no *type_argument_list* is specified, consider `k` to be zero.</span></span>

<span data-ttu-id="ee99f-472">Die Bedeutung eines *namespace_or_type_name* wird wie folgt bestimmt:</span><span class="sxs-lookup"><span data-stu-id="ee99f-472">The meaning of a *namespace_or_type_name* is determined as follows:</span></span>

*   <span data-ttu-id="ee99f-473">Wenn der *namespace_or_type_name* die Form `I` oder der Form `I<A1, ..., Ak>` hat:</span><span class="sxs-lookup"><span data-stu-id="ee99f-473">If the *namespace_or_type_name* is of the form `I` or of the form `I<A1, ..., Ak>`:</span></span>
    * <span data-ttu-id="ee99f-474">Wenn `K` 0 (null) ist und die *namespace_or_type_name* innerhalb einer generischen Methoden Deklaration ([Methoden](classes.md#methods)) enthalten ist und diese Deklaration einen Typparameter ([Typparameter](classes.md#type-parameters)) mit dem Namen @ no__t-4 enthält, wird *namespace_or_type_ Name* verweist auf diesen Typparameter.</span><span class="sxs-lookup"><span data-stu-id="ee99f-474">If `K` is zero and the *namespace_or_type_name* appears within a generic method declaration ([Methods](classes.md#methods)) and if that declaration includes a type parameter ([Type parameters](classes.md#type-parameters)) with name `I`, then the *namespace_or_type_name* refers to that type parameter.</span></span>
    * <span data-ttu-id="ee99f-475">Andernfalls, wenn *namespace_or_type_name* innerhalb einer Typdeklaration angezeigt wird, dann für jeden Instanztyp @ no__t-1 ([der Instanztyp](classes.md#the-instance-type)), beginnend mit dem Instanztyp dieser Typdeklaration und fortsetzen mit dem Instanztyp der einzelnen umschließende Klassen-oder Struktur Deklaration (sofern vorhanden):</span><span class="sxs-lookup"><span data-stu-id="ee99f-475">Otherwise, if the *namespace_or_type_name* appears within a type declaration, then for each instance type `T` ([The instance type](classes.md#the-instance-type)), starting with the instance type of that type declaration and continuing with the instance type of each enclosing class or struct declaration (if any):</span></span>
        * <span data-ttu-id="ee99f-476">Wenn `K` 0 (null) ist und die Deklaration von `T` einen Typparameter mit dem Namen @ no__t-2 enthält, verweist *namespace_or_type_name* auf diesen Typparameter.</span><span class="sxs-lookup"><span data-stu-id="ee99f-476">If `K` is zero and the declaration of `T` includes a type parameter with name `I`, then the *namespace_or_type_name* refers to that type parameter.</span></span>
        * <span data-ttu-id="ee99f-477">Andernfalls, wenn *namespace_or_type_name* innerhalb des Texts der Typdeklaration angezeigt wird und `T` oder einer der zugehörigen Basis Typen einen geschachtelten zugänglichen Typ mit den Parametern Name @ no__t-2 und `K` @ no__t-4type enthält, dann wird *namespace_or_type _name* verweist auf diesen Typ, der mit den angegebenen Typargumenten erstellt wurde.</span><span class="sxs-lookup"><span data-stu-id="ee99f-477">Otherwise, if the *namespace_or_type_name* appears within the body of the type declaration, and `T` or any of its base types contain a nested accessible type having name `I` and `K` type parameters, then the *namespace_or_type_name* refers to that type constructed with the given type arguments.</span></span> <span data-ttu-id="ee99f-478">Wenn mehr als ein solcher Typ vorhanden ist, wird der in einem stärker abgeleiteten Typ deklarierte Typ ausgewählt.</span><span class="sxs-lookup"><span data-stu-id="ee99f-478">If there is more than one such type, the type declared within the more derived type is selected.</span></span> <span data-ttu-id="ee99f-479">Beachten Sie, dass nicht-Typmember (Konstanten, Felder, Methoden, Eigenschaften, Indexer, Operatoren, Instanzkonstruktoren, Dekonstruktoren und statische Konstruktoren) und Typmember mit einer anderen Anzahl von Typparametern ignoriert werden, wenn die Bedeutung des *namespace_or_type_name*.</span><span class="sxs-lookup"><span data-stu-id="ee99f-479">Note that non-type members (constants, fields, methods, properties, indexers, operators, instance constructors, destructors, and static constructors) and type members with a different number of type parameters are ignored when determining the meaning of the *namespace_or_type_name*.</span></span>
    * <span data-ttu-id="ee99f-480">Wenn die vorherigen Schritte nicht erfolgreich waren, dann für jeden Namespace @ no__t-0, beginnend mit dem Namespace, in dem der *namespace_or_type_name* auftritt, den Vorgang mit jedem einschließenden Namespace (sofern vorhanden) und Ende mit dem globalen Namespace: Folgendes die Schritte werden ausgewertet, bis eine Entität gefunden wird:</span><span class="sxs-lookup"><span data-stu-id="ee99f-480">If the previous steps were unsuccessful then, for each namespace `N`, starting with the namespace in which the *namespace_or_type_name* occurs, continuing with each enclosing namespace (if any), and ending with the global namespace, the following steps are evaluated until an entity is located:</span></span>
        * <span data-ttu-id="ee99f-481">Wenn `K` 0 (null) und `I` der Name eines Namespace in @ no__t-2 ist, dann gilt Folgendes:</span><span class="sxs-lookup"><span data-stu-id="ee99f-481">If `K` is zero and `I` is the name of a namespace in `N`, then:</span></span>
            * <span data-ttu-id="ee99f-482">Wenn der Speicherort, an dem der *namespace_or_type_name* auftritt, von einer Namespace Deklaration für `N` eingeschlossen wird und die Namespace Deklaration ein *extern_alias_directive* oder *using_alias_directive* enthält, das den Namen @ No zuordnet. __t-4 mit einem Namespace oder Typ, dann ist *namespace_or_type_name* mehrdeutig, und ein Kompilierzeitfehler tritt auf.</span><span class="sxs-lookup"><span data-stu-id="ee99f-482">If the location where the *namespace_or_type_name* occurs is enclosed by a namespace declaration for `N` and the namespace declaration contains an *extern_alias_directive* or *using_alias_directive* that associates the name `I` with a namespace or type, then the *namespace_or_type_name* is ambiguous and a compile-time error occurs.</span></span>
            * <span data-ttu-id="ee99f-483">Andernfalls verweist *namespace_or_type_name* auf den Namespace mit dem Namen "`I`" in `N`.</span><span class="sxs-lookup"><span data-stu-id="ee99f-483">Otherwise, the *namespace_or_type_name* refers to the namespace named `I` in `N`.</span></span>
        * <span data-ttu-id="ee99f-484">Wenn `N` einen zugänglichen Typ mit den Parametern "Name @ no__t-1" und "`K` @ no__t-3type" enthält, wird Folgendes angezeigt:</span><span class="sxs-lookup"><span data-stu-id="ee99f-484">Otherwise, if `N` contains an accessible type having name `I` and `K` type parameters, then:</span></span>
            * <span data-ttu-id="ee99f-485">Wenn `K` 0 (null) ist und die Position, an der das *namespace_or_type_name* auftritt, von einer Namespace Deklaration für `N` eingeschlossen wird und die Namespace Deklaration ein *extern_alias_directive* oder *using_alias_directive* enthält, das ordnet den Namen @ no__t-5 einem Namespace oder Typ zu, dann ist *namespace_or_type_name* mehrdeutig, und ein Kompilierzeitfehler tritt auf.</span><span class="sxs-lookup"><span data-stu-id="ee99f-485">If `K` is zero and the location where the *namespace_or_type_name* occurs is enclosed by a namespace declaration for `N` and the namespace declaration contains an *extern_alias_directive* or *using_alias_directive* that associates the name `I` with a namespace or type, then the *namespace_or_type_name* is ambiguous and a compile-time error occurs.</span></span>
            * <span data-ttu-id="ee99f-486">Andernfalls verweist der *namespace_or_type_name* auf den Typ, der mit den angegebenen Typargumenten erstellt wurde.</span><span class="sxs-lookup"><span data-stu-id="ee99f-486">Otherwise, the *namespace_or_type_name* refers to the type constructed with the given type arguments.</span></span>
        * <span data-ttu-id="ee99f-487">Andernfalls, wenn der Speicherort, an dem der *namespace_or_type_name* auftritt, von einer Namespace Deklaration für `N` eingeschlossen wird:</span><span class="sxs-lookup"><span data-stu-id="ee99f-487">Otherwise, if the location where the *namespace_or_type_name* occurs is enclosed by a namespace declaration for `N`:</span></span>
            * <span data-ttu-id="ee99f-488">Wenn `K` 0 (null) ist und die Namespace Deklaration ein *extern_alias_directive* -oder *using_alias_directive* -Wert enthält, der den Namen @ no__t-3 einem importierten Namespace oder Typ zuordnet, bezieht sich *namespace_or_type_name* auf das Namespace oder Typ.</span><span class="sxs-lookup"><span data-stu-id="ee99f-488">If `K` is zero and the namespace declaration contains an *extern_alias_directive* or *using_alias_directive* that associates the name `I` with an imported namespace or type, then the *namespace_or_type_name* refers to that namespace or type.</span></span>
            * <span data-ttu-id="ee99f-489">Andernfalls, wenn die von den *using_namespace_directive*s und *using_alias_directive*s der Namespace Deklaration importierten Namespaces und Typdeklarationen genau einen zugänglichen Typ mit dem Namen @ no__t-2 und `K` @ no__t-4type enthalten. Parameter, dann verweist das *namespace_or_type_name* auf diesen Typ, der mit den angegebenen Typargumenten erstellt wurde.</span><span class="sxs-lookup"><span data-stu-id="ee99f-489">Otherwise, if the namespaces and type declarations imported by the *using_namespace_directive*s and *using_alias_directive*s of the namespace declaration contain exactly one accessible type having name `I` and `K` type parameters, then the *namespace_or_type_name* refers to that type constructed with the given type arguments.</span></span>
            * <span data-ttu-id="ee99f-490">Andernfalls, wenn die Namespaces und Typdeklarationen, die von den *using_namespace_directive*s und *using_alias_directive*s der Namespace Deklaration importiert werden, mehr als einen zugänglichen Typ mit dem Namen @ no__t-2 und `K` @ no__t-4type enthalten. Parameter, dann ist *namespace_or_type_name* mehrdeutig, und es tritt ein Fehler auf.</span><span class="sxs-lookup"><span data-stu-id="ee99f-490">Otherwise, if the namespaces and type declarations imported by the *using_namespace_directive*s and *using_alias_directive*s of the namespace declaration contain more than one accessible type having name `I` and `K` type parameters, then the *namespace_or_type_name* is ambiguous and an error occurs.</span></span>
    * <span data-ttu-id="ee99f-491">Andernfalls ist *namespace_or_type_name* nicht definiert, und es tritt ein Kompilierzeitfehler auf.</span><span class="sxs-lookup"><span data-stu-id="ee99f-491">Otherwise, the *namespace_or_type_name* is undefined and a compile-time error occurs.</span></span>
*  <span data-ttu-id="ee99f-492">Andernfalls hat das *namespace_or_type_name* -Format den Wert `N.I` oder das Formular `N.I<A1, ..., Ak>`.</span><span class="sxs-lookup"><span data-stu-id="ee99f-492">Otherwise, the *namespace_or_type_name* is of the form `N.I` or of the form `N.I<A1, ..., Ak>`.</span></span> <span data-ttu-id="ee99f-493">`N` wird zuerst als *namespace_or_type_name*aufgelöst.</span><span class="sxs-lookup"><span data-stu-id="ee99f-493">`N` is first resolved as a *namespace_or_type_name*.</span></span> <span data-ttu-id="ee99f-494">Wenn die Auflösung von `N` nicht erfolgreich ist, tritt ein Kompilierzeitfehler auf.</span><span class="sxs-lookup"><span data-stu-id="ee99f-494">If the resolution of `N` is not successful, a compile-time error occurs.</span></span> <span data-ttu-id="ee99f-495">Andernfalls wird `N.I` oder `N.I<A1, ..., Ak>` wie folgt aufgelöst:</span><span class="sxs-lookup"><span data-stu-id="ee99f-495">Otherwise, `N.I` or `N.I<A1, ..., Ak>` is resolved as follows:</span></span>
    * <span data-ttu-id="ee99f-496">Wenn `K` 0 (null) ist und `N` auf einen Namespace verweist und `N` einen schsted Namespace mit dem Namen "`I`" enthält, verweist der *namespace_or_type_name* auf diesen schsted Namespace.</span><span class="sxs-lookup"><span data-stu-id="ee99f-496">If `K` is zero and `N` refers to a namespace and `N` contains a nested namespace with name `I`, then the *namespace_or_type_name* refers to that nested namespace.</span></span>
    * <span data-ttu-id="ee99f-497">Wenn `N` auf einen Namespace verweist und `N` einen zugreif baren Typ mit dem Namen @ no__t-2 und `K` @ no__t-4type-Parameter enthält, verweist *namespace_or_type_name* auf diesen Typ, der mit den angegebenen Typargumenten erstellt wurde.</span><span class="sxs-lookup"><span data-stu-id="ee99f-497">Otherwise, if `N` refers to a namespace and `N` contains an accessible type having name `I` and `K` type parameters, then the *namespace_or_type_name* refers to that type constructed with the given type arguments.</span></span>
    * <span data-ttu-id="ee99f-498">Wenn sich `N` auf eine (möglicherweise konstruierte) Klasse oder einen Strukturtyp bezieht und `N` oder eine der zugehörigen Basisklassen einen für den nsted Typ zugänglichen Typ mit den Parametern Name @ no__t-2 und `K` @ no__t-4type enthält, verweist *namespace_or_type_name* auf der Typ, der mit den angegebenen Typargumenten erstellt wurde.</span><span class="sxs-lookup"><span data-stu-id="ee99f-498">Otherwise, if `N` refers to a (possibly constructed) class or struct type and `N` or any of its base classes contain a nested accessible type having name `I` and `K` type parameters, then the *namespace_or_type_name* refers to that type constructed with the given type arguments.</span></span> <span data-ttu-id="ee99f-499">Wenn mehr als ein solcher Typ vorhanden ist, wird der in einem stärker abgeleiteten Typ deklarierte Typ ausgewählt.</span><span class="sxs-lookup"><span data-stu-id="ee99f-499">If there is more than one such type, the type declared within the more derived type is selected.</span></span> <span data-ttu-id="ee99f-500">Beachten Sie Folgendes: Wenn die Bedeutung von `N.I` als Teil der Auflösung der Basisklassen Spezifikation von `N` festgelegt wird, wird die direkte Basisklasse von `N` als Object ([Basisklassen](classes.md#base-classes)) betrachtet.</span><span class="sxs-lookup"><span data-stu-id="ee99f-500">Note that if the meaning of `N.I` is being determined as part of resolving the base class specification of `N` then the direct base class of `N` is considered to be object ([Base classes](classes.md#base-classes)).</span></span>
    * <span data-ttu-id="ee99f-501">Andernfalls ist `N.I` ein ungültiges *namespace_or_type_name*, und es tritt ein Kompilierzeitfehler auf.</span><span class="sxs-lookup"><span data-stu-id="ee99f-501">Otherwise, `N.I` is an invalid *namespace_or_type_name*, and a compile-time error occurs.</span></span>

<span data-ttu-id="ee99f-502">Ein *namespace_or_type_name* -Wert darf nur dann auf eine statische Klasse ([statische Klassen](classes.md#static-classes)) verweisen, wenn</span><span class="sxs-lookup"><span data-stu-id="ee99f-502">A *namespace_or_type_name* is permitted to reference a static class ([Static classes](classes.md#static-classes)) only if</span></span>

*  <span data-ttu-id="ee99f-503">*Namespace_or_type_name* ist der `T` in einem *namespace_or_type_name* -Format `T.I` oder</span><span class="sxs-lookup"><span data-stu-id="ee99f-503">The *namespace_or_type_name* is the `T` in a *namespace_or_type_name* of the form `T.I`, or</span></span>
*  <span data-ttu-id="ee99f-504">*Namespace_or_type_name* ist der `T` in einer *typeof_expression* ([Argument Liste](expressions.md#argument-lists)1) der Form `typeof(T)`.</span><span class="sxs-lookup"><span data-stu-id="ee99f-504">The *namespace_or_type_name* is the `T` in a *typeof_expression* ([Argument lists](expressions.md#argument-lists)1) of the form `typeof(T)`.</span></span>

### <a name="fully-qualified-names"></a><span data-ttu-id="ee99f-505">Vollqualifizierte Namen</span><span class="sxs-lookup"><span data-stu-id="ee99f-505">Fully qualified names</span></span>

<span data-ttu-id="ee99f-506">Jeder Namespace und Typ verfügt über einen ***voll qualifizierten Namen***, der den Namespace oder den Typ unter allen anderen eindeutig identifiziert.</span><span class="sxs-lookup"><span data-stu-id="ee99f-506">Every namespace and type has a ***fully qualified name***, which uniquely identifies the namespace or type amongst all others.</span></span> <span data-ttu-id="ee99f-507">Der voll qualifizierte Name eines Namespace oder Typs `N` wird wie folgt bestimmt:</span><span class="sxs-lookup"><span data-stu-id="ee99f-507">The fully qualified name of a namespace or type `N` is determined as follows:</span></span>

*  <span data-ttu-id="ee99f-508">Wenn `N` ein Member des globalen Namespace ist, lautet der voll qualifizierte Name `N`.</span><span class="sxs-lookup"><span data-stu-id="ee99f-508">If `N` is a member of the global namespace, its fully qualified name is `N`.</span></span>
*  <span data-ttu-id="ee99f-509">Andernfalls ist der voll qualifizierte Name `S.N`, wobei `S` der voll qualifizierte Name des Namespace oder Typs ist, in dem `N` deklariert ist.</span><span class="sxs-lookup"><span data-stu-id="ee99f-509">Otherwise, its fully qualified name is `S.N`, where `S` is the fully qualified name of the namespace or type in which `N` is declared.</span></span>

<span data-ttu-id="ee99f-510">Anders ausgedrückt: der voll qualifizierte Name `N` ist der vollständige hierarchische Pfad der Bezeichner, die zu `N` führen, beginnend beim globalen Namespace.</span><span class="sxs-lookup"><span data-stu-id="ee99f-510">In other words, the fully qualified name of `N` is the complete hierarchical path of identifiers that lead to `N`, starting from the global namespace.</span></span> <span data-ttu-id="ee99f-511">Da jeder Member eines Namespaces oder Typs einen eindeutigen Namen haben muss, folgt der voll qualifizierte Name eines Namespace oder Typs immer eindeutig.</span><span class="sxs-lookup"><span data-stu-id="ee99f-511">Because every member of a namespace or type must have a unique name, it follows that the fully qualified name of a namespace or type is always unique.</span></span>

<span data-ttu-id="ee99f-512">Das folgende Beispiel zeigt mehrere Namespace-und Typdeklarationen zusammen mit den zugehörigen voll qualifizierten Namen.</span><span class="sxs-lookup"><span data-stu-id="ee99f-512">The example below shows several namespace and type declarations along with their associated fully qualified names.</span></span>
```csharp
class A {}                // A

namespace X               // X
{
    class B               // X.B
    {
        class C {}        // X.B.C
    }

    namespace Y           // X.Y
    {
        class D {}        // X.Y.D
    }
}

namespace X.Y             // X.Y
{
    class E {}            // X.Y.E
}
```

## <a name="automatic-memory-management"></a><span data-ttu-id="ee99f-513">Automatische Speicherverwaltung</span><span class="sxs-lookup"><span data-stu-id="ee99f-513">Automatic memory management</span></span>

<span data-ttu-id="ee99f-514">C#verwendet die automatische Speicherverwaltung, mit der Entwickler den von-Objekten belegten Arbeitsspeicher manuell zuordnen und freigeben können.</span><span class="sxs-lookup"><span data-stu-id="ee99f-514">C# employs automatic memory management, which frees developers from manually allocating and freeing the memory occupied by objects.</span></span> <span data-ttu-id="ee99f-515">Automatische Speicher Verwaltungsrichtlinien werden von einem ***Garbage Collector***implementiert.</span><span class="sxs-lookup"><span data-stu-id="ee99f-515">Automatic memory management policies are implemented by a ***garbage collector***.</span></span> <span data-ttu-id="ee99f-516">Der Lebenszyklus der Speicherverwaltung eines Objekts lautet wie folgt:</span><span class="sxs-lookup"><span data-stu-id="ee99f-516">The memory management life cycle of an object is as follows:</span></span>

1. <span data-ttu-id="ee99f-517">Wenn das Objekt erstellt wird, wird Arbeitsspeicher zugeordnet, der Konstruktor wird ausgeführt, und das Objekt wird als Live-Objekt betrachtet.</span><span class="sxs-lookup"><span data-stu-id="ee99f-517">When the object is created, memory is allocated for it, the constructor is run, and the object is considered live.</span></span>
2. <span data-ttu-id="ee99f-518">Wenn auf das Objekt oder einen Teil davon nicht durch eine mögliche Fortsetzung der Ausführung zugegriffen werden kann, abgesehen von der Ausführung von dedededededektoren, wird das Objekt als nicht mehr verwendet und ist für die Zerstörung infrage.</span><span class="sxs-lookup"><span data-stu-id="ee99f-518">If the object, or any part of it, cannot be accessed by any possible continuation of execution, other than the running of destructors, the object is considered no longer in use, and it becomes eligible for destruction.</span></span> <span data-ttu-id="ee99f-519">Der C# Compiler und der Garbage Collector können Code analysieren, um zu bestimmen, welche Verweise auf ein Objekt in Zukunft verwendet werden können.</span><span class="sxs-lookup"><span data-stu-id="ee99f-519">The C# compiler and the garbage collector may choose to analyze code to determine which references to an object may be used in the future.</span></span> <span data-ttu-id="ee99f-520">Wenn beispielsweise eine lokale Variable, die sich im Gültigkeitsbereich befindet, der einzige vorhandene Verweis auf ein Objekt ist, aber auf diese lokale Variable in keiner möglichen Fortsetzung der Ausführung vom aktuellen Ausführungs Punkt in der Prozedur verwiesen wird, wird der Garbage Collector möglicherweise (aber nicht erforderlich für) behandeln Sie das Objekt als nicht mehr verwendende.</span><span class="sxs-lookup"><span data-stu-id="ee99f-520">For instance, if a local variable that is in scope is the only existing reference to an object, but that local variable is never referred to in any possible continuation of execution from the current execution point in the procedure, the garbage collector may (but is not required to) treat the object as no longer in use.</span></span>
3. <span data-ttu-id="ee99f-521">Sobald das Objekt für die Zerstörung geeignet ist, wird zu einem späteren Zeitpunkt der Dekonstruktor ([Dekonstruktoren](classes.md#destructors)) für das Objekt ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="ee99f-521">Once the object is eligible for destruction, at some unspecified later time the destructor ([Destructors](classes.md#destructors)) (if any) for the object is run.</span></span> <span data-ttu-id="ee99f-522">Unter normalen Umständen wird der debugtor für das Objekt nur einmal ausgeführt, obwohl Implementierungs spezifische APIs das Überschreiben dieses Verhaltens zulassen können.</span><span class="sxs-lookup"><span data-stu-id="ee99f-522">Under normal circumstances the destructor for the object is run once only, though implementation-specific APIs may allow this behavior to be overridden.</span></span>
4. <span data-ttu-id="ee99f-523">Sobald der Dekonstruktor für ein Objekt ausgeführt wird, und der Zugriff auf das Objekt oder einen Teil davon durch eine mögliche Fortsetzung der Ausführung (einschließlich der Ausführung von Dekonstruktoren) nicht möglich ist, wird das Objekt als nicht zugänglich angesehen, und das Objekt wird für die Auflistung qualifiziert.</span><span class="sxs-lookup"><span data-stu-id="ee99f-523">Once the destructor for an object is run, if that object, or any part of it, cannot be accessed by any possible continuation of execution, including the running of destructors, the object is considered inaccessible and the object becomes eligible for collection.</span></span>
5. <span data-ttu-id="ee99f-524">Schließlich gibt der Garbage Collector zu einem späteren Zeitpunkt, nachdem das Objekt für die Auflistung infrage kommt, den diesem Objekt zugeordneten Arbeitsspeicher frei.</span><span class="sxs-lookup"><span data-stu-id="ee99f-524">Finally, at some time after the object becomes eligible for collection, the garbage collector frees the memory associated with that object.</span></span>

<span data-ttu-id="ee99f-525">Der Garbage Collector verwaltet Informationen zur Objekt Verwendung und verwendet diese Informationen, um Entscheidungen hinsichtlich der Speicherverwaltung zu treffen, z. b. wo im Arbeitsspeicher ein neu erstelltes Objekt zu finden ist, wann ein Objekt verschoben werden soll und wann ein Objekt nicht mehr verwendet wird oder nicht.</span><span class="sxs-lookup"><span data-stu-id="ee99f-525">The garbage collector maintains information about object usage, and uses this information to make memory management decisions, such as where in memory to locate a newly created object, when to relocate an object, and when an object is no longer in use or inaccessible.</span></span>

<span data-ttu-id="ee99f-526">Wie andere Sprachen, die voraussetzen, dass eine Garbage Collector C# vorhanden ist, ist so konzipiert, dass die Garbage Collector eine Vielzahl von Speicher Verwaltungsrichtlinien implementieren kann.</span><span class="sxs-lookup"><span data-stu-id="ee99f-526">Like other languages that assume the existence of a garbage collector, C# is designed so that the garbage collector may implement a wide range of memory management policies.</span></span> <span data-ttu-id="ee99f-527">C# Beispielsweise ist nicht erforderlich, dass Dekonstruktoren ausgeführt werden oder dass Objekte gesammelt werden, sobald Sie qualifiziert sind oder dass Dekonstruktoren in einer bestimmten Reihenfolge oder in einem bestimmten Thread ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="ee99f-527">For instance, C# does not require that destructors be run or that objects be collected as soon as they are eligible, or that destructors be run in any particular order, or on any particular thread.</span></span>

<span data-ttu-id="ee99f-528">Das Verhalten des Garbage Collector kann in gewissem Maße über statische Methoden für die Klasse `System.GC` gesteuert werden.</span><span class="sxs-lookup"><span data-stu-id="ee99f-528">The behavior of the garbage collector can be controlled, to some degree, via static methods on the class `System.GC`.</span></span> <span data-ttu-id="ee99f-529">Diese Klasse kann verwendet werden, um eine Auflistung anzufordern, Dekonstruktoren auszuführen (oder nicht ausgeführt) usw.</span><span class="sxs-lookup"><span data-stu-id="ee99f-529">This class can be used to request a collection to occur, destructors to be run (or not run), and so forth.</span></span>

<span data-ttu-id="ee99f-530">Da die Garbage Collector den Breitengrad der Entscheidung, wann Objekte gesammelt werden sollen, und die Ausführung von Debuggern unterstützt, kann eine konforme Implementierung eine Ausgabe ergeben, die sich von der im folgenden Code gezeigten unterscheidet.</span><span class="sxs-lookup"><span data-stu-id="ee99f-530">Since the garbage collector is allowed wide latitude in deciding when to collect objects and run destructors, a conforming implementation may produce output that differs from that shown by the following code.</span></span> <span data-ttu-id="ee99f-531">Das Programm</span><span class="sxs-lookup"><span data-stu-id="ee99f-531">The program</span></span>
```csharp
using System;

class A
{
    ~A() {
        Console.WriteLine("Destruct instance of A");
    }
}

class B
{
    object Ref;

    public B(object o) {
        Ref = o;
    }

    ~B() {
        Console.WriteLine("Destruct instance of B");
    }
}

class Test
{
    static void Main() {
        B b = new B(new A());
        b = null;
        GC.Collect();
        GC.WaitForPendingFinalizers();
    }
}
```
<span data-ttu-id="ee99f-532">erstellt eine Instanz der-Klasse `A` und eine Instanz der-Klasse `B`.</span><span class="sxs-lookup"><span data-stu-id="ee99f-532">creates an instance of class `A` and an instance of class `B`.</span></span> <span data-ttu-id="ee99f-533">Diese Objekte sind für Garbage Collection qualifiziert, wenn der Wert `b` der Wert `null` zugewiesen wird, da nach diesem Zeitpunkt kein Benutzer geschriebener Code mehr darauf zugreifen kann.</span><span class="sxs-lookup"><span data-stu-id="ee99f-533">These objects become eligible for garbage collection when the variable `b` is assigned the value `null`, since after this time it is impossible for any user-written code to access them.</span></span> <span data-ttu-id="ee99f-534">Die Ausgabe kann entweder</span><span class="sxs-lookup"><span data-stu-id="ee99f-534">The output could be either</span></span>

```console
Destruct instance of A
Destruct instance of B
```
<span data-ttu-id="ee99f-535">oder</span><span class="sxs-lookup"><span data-stu-id="ee99f-535">or</span></span>
```console
Destruct instance of B
Destruct instance of A
```
<span data-ttu-id="ee99f-536">Da in der Sprache keine Einschränkungen für die Reihenfolge auferlegt werden, in der Objekte in die Garbage Collection aufgenommen werden.</span><span class="sxs-lookup"><span data-stu-id="ee99f-536">because the language imposes no constraints on the order in which objects are garbage collected.</span></span>

<span data-ttu-id="ee99f-537">In einigen Fällen kann es wichtig sein, den Unterschied zwischen "berechtigte für Zerstörung" und "berechtigte Sammlung" zu unterscheiden.</span><span class="sxs-lookup"><span data-stu-id="ee99f-537">In subtle cases, the distinction between "eligible for destruction" and "eligible for collection" can be important.</span></span> <span data-ttu-id="ee99f-538">Ein auf ein Objekt angewendeter</span><span class="sxs-lookup"><span data-stu-id="ee99f-538">For example,</span></span>
```csharp
using System;

class A
{
    ~A() {
        Console.WriteLine("Destruct instance of A");
    }

    public void F() {
        Console.WriteLine("A.F");
        Test.RefA = this;
    }
}

class B
{
    public A Ref;

    ~B() {
        Console.WriteLine("Destruct instance of B");
        Ref.F();
    }
}

class Test
{
    public static A RefA;
    public static B RefB;

    static void Main() {
        RefB = new B();
        RefA = new A();
        RefB.Ref = RefA;
        RefB = null;
        RefA = null;

        // A and B now eligible for destruction
        GC.Collect();
        GC.WaitForPendingFinalizers();

        // B now eligible for collection, but A is not
        if (RefA != null)
            Console.WriteLine("RefA is not null");
    }
}
```

<span data-ttu-id="ee99f-539">Wenn im obigen Programm der Garbage Collector den debugtor von `A` vor dem debugtor von `B` ausführen möchte, könnte die Ausgabe dieses Programms wie folgt lauten:</span><span class="sxs-lookup"><span data-stu-id="ee99f-539">In the above program, if the garbage collector chooses to run the destructor of `A` before the destructor of `B`, then the output of this program might be:</span></span>
```console
Destruct instance of A
Destruct instance of B
A.F
RefA is not null
```

<span data-ttu-id="ee99f-540">Beachten Sie, dass zwar die Instanz von `A` nicht verwendet wurde und der Dekonstruktor von `A` ausgeführt wurde, aber es ist weiterhin möglich, dass die Methoden von `A` (in diesem Fall `F`) von einem anderen Dekonstruktor aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="ee99f-540">Note that although the instance of `A` was not in use and `A`'s destructor was run, it is still possible for methods of `A` (in this case, `F`) to be called from another destructor.</span></span> <span data-ttu-id="ee99f-541">Beachten Sie außerdem, dass das Ausführen eines Dekonstruktors dazu führen kann, dass ein Objekt erneut aus dem Haupt-Programm verwendet werden kann.</span><span class="sxs-lookup"><span data-stu-id="ee99f-541">Also, note that running of a destructor may cause an object to become usable from the mainline program again.</span></span> <span data-ttu-id="ee99f-542">In diesem Fall hat die Ausführung des Dekonstruktors von `B` bewirkt, dass eine Instanz von `A`, die zuvor nicht verwendet wurde, über den Live Verweis `Test.RefA` zugänglich ist.</span><span class="sxs-lookup"><span data-stu-id="ee99f-542">In this case, the running of `B`'s destructor caused an instance of `A` that was previously not in use to become accessible from the live reference `Test.RefA`.</span></span> <span data-ttu-id="ee99f-543">Nach dem `WaitForPendingFinalizers`-Auflistungs Wert ist die Instanz von `B` für die Auflistung qualifiziert, aber die Instanz von `A` ist aufgrund des Verweises `Test.RefA` nicht verfügbar.</span><span class="sxs-lookup"><span data-stu-id="ee99f-543">After the call to `WaitForPendingFinalizers`, the instance of `B` is eligible for collection, but the instance of `A` is not, because of the reference `Test.RefA`.</span></span>

<span data-ttu-id="ee99f-544">Um Verwirrung und unerwartetes Verhalten zu vermeiden, ist es im Allgemeinen eine gute Idee, dass debugtoren nur die Bereinigung für Daten ausführen, die in den eigenen Feldern Ihres Objekts gespeichert sind, und keine Aktionen für referenzierte Objekte oder statische Felder durchführen.</span><span class="sxs-lookup"><span data-stu-id="ee99f-544">To avoid confusion and unexpected behavior, it is generally a good idea for destructors to only perform cleanup on data stored in their object's own fields, and not to perform any actions on referenced objects or static fields.</span></span>

<span data-ttu-id="ee99f-545">Eine Alternative zur Verwendung von Dekonstruktoren besteht darin, dass eine Klasse die `System.IDisposable`-Schnittstelle implementiert.</span><span class="sxs-lookup"><span data-stu-id="ee99f-545">An alternative to using destructors is to let a class implement the `System.IDisposable` interface.</span></span> <span data-ttu-id="ee99f-546">Dies ermöglicht es dem Client des-Objekts zu bestimmen, wann die Ressourcen des Objekts freigegeben werden sollen. Dies geschieht in der Regel durch den Zugriff auf das-Objekt als Ressource in einer `using`-Anweisung ([using-Anweisung](statements.md#the-using-statement)).</span><span class="sxs-lookup"><span data-stu-id="ee99f-546">This allows the client of the object to determine when to release the resources of the object, typically by accessing the object as a resource in a `using` statement ([The using statement](statements.md#the-using-statement)).</span></span>

## <a name="execution-order"></a><span data-ttu-id="ee99f-547">Ausführungsreihenfolge</span><span class="sxs-lookup"><span data-stu-id="ee99f-547">Execution order</span></span>

<span data-ttu-id="ee99f-548">Die Ausführung eines C# Programms wird so fortgesetzt, dass die Nebeneffekte der einzelnen ausführenden Threads an kritischen Ausführungs Punkten beibehalten werden.</span><span class="sxs-lookup"><span data-stu-id="ee99f-548">Execution of a C# program proceeds such that the side effects of each executing thread are preserved at critical execution points.</span></span> <span data-ttu-id="ee99f-549">Ein ***Nebeneffekt*** wird als Lese-oder Schreibvorgang eines flüchtigen Felds, eines Schreibzugriffs auf eine nicht flüchtige Variable, eines Schreibzugriffs auf eine externe Ressource und das Auslösen einer Ausnahme definiert.</span><span class="sxs-lookup"><span data-stu-id="ee99f-549">A ***side effect*** is defined as a read or write of a volatile field, a write to a non-volatile variable, a write to an external resource, and the throwing of an exception.</span></span> <span data-ttu-id="ee99f-550">Die kritischen Ausführungs Punkte, bei denen die Reihenfolge dieser Nebeneffekte beibehalten werden muss, sind Verweise auf flüchtige Felder ([flüchtige Felder](classes.md#volatile-fields)), `lock`-Anweisungen ([lock-Anweisung](statements.md#the-lock-statement)) und Thread Erstellung und-Beendigung.</span><span class="sxs-lookup"><span data-stu-id="ee99f-550">The critical execution points at which the order of these side effects must be preserved are references to volatile fields ([Volatile fields](classes.md#volatile-fields)), `lock` statements ([The lock statement](statements.md#the-lock-statement)), and thread creation and termination.</span></span> <span data-ttu-id="ee99f-551">In der Ausführungsumgebung kann die Reihenfolge der Ausführung eines C# Programms geändert werden, wobei die folgenden Einschränkungen gelten:</span><span class="sxs-lookup"><span data-stu-id="ee99f-551">The execution environment is free to change the order of execution of a C# program, subject to the following constraints:</span></span>

*  <span data-ttu-id="ee99f-552">Die Daten Abhängigkeit wird innerhalb eines Ausführungs Threads beibehalten.</span><span class="sxs-lookup"><span data-stu-id="ee99f-552">Data dependence is preserved within a thread of execution.</span></span> <span data-ttu-id="ee99f-553">Das heißt, der Wert jeder Variablen wird berechnet, als ob alle Anweisungen im Thread in der ursprünglichen Programm Reihenfolge ausgeführt wurden.</span><span class="sxs-lookup"><span data-stu-id="ee99f-553">That is, the value of each variable is computed as if all statements in the thread were executed in original program order.</span></span>
*  <span data-ttu-id="ee99f-554">Die Regeln für die Initialisierungs Reihenfolge werden beibehalten ([Feld Initialisierung](classes.md#field-initialization) und [Variableninitialisierer](classes.md#variable-initializers)).</span><span class="sxs-lookup"><span data-stu-id="ee99f-554">Initialization ordering rules are preserved ([Field initialization](classes.md#field-initialization) and [Variable initializers](classes.md#variable-initializers)).</span></span>
*  <span data-ttu-id="ee99f-555">Die Reihenfolge von Nebeneffekten wird in Bezug auf flüchtige Lese-und Schreibvorgänge ([flüchtige Felder](classes.md#volatile-fields)) beibehalten.</span><span class="sxs-lookup"><span data-stu-id="ee99f-555">The ordering of side effects is preserved with respect to volatile reads and writes ([Volatile fields](classes.md#volatile-fields)).</span></span> <span data-ttu-id="ee99f-556">Darüber hinaus muss die Ausführungsumgebung einen Teil eines Ausdrucks nicht auswerten, wenn er ableiten kann, dass der Wert des Ausdrucks nicht verwendet wird und keine erforderlichen Nebeneffekte erzeugt werden (einschließlich der durch Aufrufen einer Methode oder zugreifen auf ein flüchtiges Feld verursachten).</span><span class="sxs-lookup"><span data-stu-id="ee99f-556">Additionally, the execution environment need not evaluate part of an expression if it can deduce that that expression's value is not used and that no needed side effects are produced (including any caused by calling a method or accessing a volatile field).</span></span> <span data-ttu-id="ee99f-557">Wenn die Programmausführung durch ein asynchrones Ereignis (z. b. eine von einem anderen Thread ausgelöste Ausnahme) unterbrochen wird, ist es nicht sichergestellt, dass die wahrnehmbaren Nebeneffekte in der ursprünglichen Programm Reihenfolge sichtbar sind.</span><span class="sxs-lookup"><span data-stu-id="ee99f-557">When program execution is interrupted by an asynchronous event (such as an exception thrown by another thread), it is not guaranteed that the observable side effects are visible in the original program order.</span></span>
