---
ms.openlocfilehash: 088c4a77cecde490c556c44c239a3496f896582e
ms.sourcegitcommit: 4ddf18d000734c1b6d0a48127bf338086fc3f2c3
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 11/05/2019
ms.locfileid: "73616141"
---
# <a name="types"></a><span data-ttu-id="99f15-101">Typen</span><span class="sxs-lookup"><span data-stu-id="99f15-101">Types</span></span>

<span data-ttu-id="99f15-102">Die Typen der C# Sprache sind in zwei Hauptkategorien unterteilt: ***Werttypen*** und ***Verweis Typen***.</span><span class="sxs-lookup"><span data-stu-id="99f15-102">The types of the C# language are divided into two main categories: ***value types*** and ***reference types***.</span></span> <span data-ttu-id="99f15-103">Sowohl Werttypen als auch Verweis Typen können ***generische Typen***sein, die einen oder mehrere ***Typparameter***annehmen.</span><span class="sxs-lookup"><span data-stu-id="99f15-103">Both value types and reference types may be ***generic types***, which take one or more ***type parameters***.</span></span> <span data-ttu-id="99f15-104">Typparameter können sowohl Werttypen als auch Verweis Typen bestimmen.</span><span class="sxs-lookup"><span data-stu-id="99f15-104">Type parameters can designate both value types and reference types.</span></span>

```antlr
type
    : value_type
    | reference_type
    | type_parameter
    | type_unsafe
    ;
```

<span data-ttu-id="99f15-105">Die letzte Kategorie von Typen, Zeiger, ist nur in unsicherem Code verfügbar.</span><span class="sxs-lookup"><span data-stu-id="99f15-105">The final category of types, pointers, is available only in unsafe code.</span></span> <span data-ttu-id="99f15-106">Dies wird in [Zeiger Typen](unsafe-code.md#pointer-types)ausführlicher erläutert.</span><span class="sxs-lookup"><span data-stu-id="99f15-106">This is discussed further in [Pointer types](unsafe-code.md#pointer-types).</span></span>

<span data-ttu-id="99f15-107">Werttypen unterscheiden sich von Verweis Typen in den Variablen der Werttypen, die Ihre Daten direkt enthalten, wohingegen Variablen der Verweis Typen ***Verweise*** auf Ihre Daten speichern. Letztere werden als ***Objekte***bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="99f15-107">Value types differ from reference types in that variables of the value types directly contain their data, whereas variables of the reference types store ***references*** to their data, the latter being known as ***objects***.</span></span> <span data-ttu-id="99f15-108">Bei Verweis Typen können zwei Variablen auf das gleiche Objekt verweisen, und so können Vorgänge in einer Variablen das Objekt beeinflussen, auf das von der anderen Variablen verwiesen wird.</span><span class="sxs-lookup"><span data-stu-id="99f15-108">With reference types, it is possible for two variables to reference the same object, and thus possible for operations on one variable to affect the object referenced by the other variable.</span></span> <span data-ttu-id="99f15-109">Bei Werttypen verfügen die Variablen jeweils über eine eigene Kopie der Daten, und es ist nicht möglich, dass sich der Vorgang auf einen anderen auswirkt.</span><span class="sxs-lookup"><span data-stu-id="99f15-109">With value types, the variables each have their own copy of the data, and it is not possible for operations on one to affect the other.</span></span>

<span data-ttu-id="99f15-110">C#das Typsystem ist einheitlich, sodass ein Wert eines beliebigen Typs als Objekt behandelt werden kann.</span><span class="sxs-lookup"><span data-stu-id="99f15-110">C#'s type system is unified such that a value of any type can be treated as an object.</span></span> <span data-ttu-id="99f15-111">Jeder Typ in C# ist direkt oder indirekt vom `object`-Klassentyp abgeleitet, und `object` ist die ultimative Basisklasse aller Typen.</span><span class="sxs-lookup"><span data-stu-id="99f15-111">Every type in C# directly or indirectly derives from the `object` class type, and `object` is the ultimate base class of all types.</span></span> <span data-ttu-id="99f15-112">Werte von Verweistypen werden als Objekte behandelt, indem die Werte einfach als Typ `object` angezeigt werden.</span><span class="sxs-lookup"><span data-stu-id="99f15-112">Values of reference types are treated as objects simply by viewing the values as type `object`.</span></span> <span data-ttu-id="99f15-113">Werte von Werttypen werden als Objekte behandelt, indem Boxing-und Unboxing-Vorgänge ([Boxing und Unboxing](types.md#boxing-and-unboxing)) durchgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="99f15-113">Values of value types are treated as objects by performing boxing and unboxing operations ([Boxing and unboxing](types.md#boxing-and-unboxing)).</span></span>

## <a name="value-types"></a><span data-ttu-id="99f15-114">Werttypen</span><span class="sxs-lookup"><span data-stu-id="99f15-114">Value types</span></span>

<span data-ttu-id="99f15-115">Ein Werttyp ist entweder ein Strukturtyp oder ein Enumerationstyp.</span><span class="sxs-lookup"><span data-stu-id="99f15-115">A value type is either a struct type or an enumeration type.</span></span> <span data-ttu-id="99f15-116">C#stellt einen Satz vordefinierter Strukturtypen bereit, die als ***einfache Typen***bezeichnet werden.</span><span class="sxs-lookup"><span data-stu-id="99f15-116">C# provides a set of predefined struct types called the ***simple types***.</span></span> <span data-ttu-id="99f15-117">Die einfachen Typen werden mithilfe von reservierten Wörtern identifiziert.</span><span class="sxs-lookup"><span data-stu-id="99f15-117">The simple types are identified through reserved words.</span></span>

```antlr
value_type
    : struct_type
    | enum_type
    ;

struct_type
    : type_name
    | simple_type
    | nullable_type
    ;

simple_type
    : numeric_type
    | 'bool'
    ;

numeric_type
    : integral_type
    | floating_point_type
    | 'decimal'
    ;

integral_type
    : 'sbyte'
    | 'byte'
    | 'short'
    | 'ushort'
    | 'int'
    | 'uint'
    | 'long'
    | 'ulong'
    | 'char'
    ;

floating_point_type
    : 'float'
    | 'double'
    ;

nullable_type
    : non_nullable_value_type '?'
    ;

non_nullable_value_type
    : type
    ;

enum_type
    : type_name
    ;
```

<span data-ttu-id="99f15-118">Anders als bei einer Variablen eines Verweis Typs kann eine Variable eines Werttyps den Wert `null` nur enthalten, wenn der Werttyp ein Typ ist, der NULL-Werte zulässt.</span><span class="sxs-lookup"><span data-stu-id="99f15-118">Unlike a variable of a reference type, a variable of a value type can contain the value `null` only if the value type is a nullable type.</span></span>  <span data-ttu-id="99f15-119">Für jeden Werttyp, der nicht auf NULL festgelegt werden kann, gibt es einen entsprechenden Werte zulässt-Werttyp, der denselben Satz von Werten sowie den Wert `null`bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="99f15-119">For every non-nullable value type there is a corresponding nullable value type denoting the same set of values plus the value `null`.</span></span>

<span data-ttu-id="99f15-120">Durch die Zuweisung zu einer Variablen eines Werttyps wird eine Kopie des zugewiesenen Werts erstellt.</span><span class="sxs-lookup"><span data-stu-id="99f15-120">Assignment to a variable of a value type creates a copy of the value being assigned.</span></span> <span data-ttu-id="99f15-121">Dies unterscheidet sich von der Zuweisung zu einer Variablen eines Verweis Typs, die den Verweis, aber nicht das durch den Verweis identifizierte Objekt kopiert.</span><span class="sxs-lookup"><span data-stu-id="99f15-121">This differs from assignment to a variable of a reference type, which copies the reference but not the object identified by the reference.</span></span>

### <a name="the-systemvaluetype-type"></a><span data-ttu-id="99f15-122">Der Typ "System. ValueType"</span><span class="sxs-lookup"><span data-stu-id="99f15-122">The System.ValueType type</span></span>

<span data-ttu-id="99f15-123">Alle Werttypen erben implizit von der-Klasse `System.ValueType`, die wiederum von der-Klasse `object`erbt.</span><span class="sxs-lookup"><span data-stu-id="99f15-123">All value types implicitly inherit from the class `System.ValueType`, which, in turn, inherits from class `object`.</span></span> <span data-ttu-id="99f15-124">Es ist nicht möglich, dass ein Typ von einem Werttyp abgeleitet wird. Werttypen sind daher implizit versiegelt ([versiegelte Klassen](classes.md#sealed-classes)).</span><span class="sxs-lookup"><span data-stu-id="99f15-124">It is not possible for any type to derive from a value type, and value types are thus implicitly sealed ([Sealed classes](classes.md#sealed-classes)).</span></span>

<span data-ttu-id="99f15-125">Beachten Sie, dass `System.ValueType` nicht selbst ein *value_type*ist.</span><span class="sxs-lookup"><span data-stu-id="99f15-125">Note that `System.ValueType` is not itself a *value_type*.</span></span> <span data-ttu-id="99f15-126">Vielmehr handelt es sich um eine *class_type* , von der alle *value_type*s automatisch abgeleitet werden.</span><span class="sxs-lookup"><span data-stu-id="99f15-126">Rather, it is a *class_type* from which all *value_type*s are automatically derived.</span></span>

### <a name="default-constructors"></a><span data-ttu-id="99f15-127">Standardkonstruktoren</span><span class="sxs-lookup"><span data-stu-id="99f15-127">Default constructors</span></span>

<span data-ttu-id="99f15-128">Alle Werttypen deklarieren implizit einen öffentlichen Parameter losen Instanzenkonstruktor, der als ***Standardkonstruktor***bezeichnet wird.</span><span class="sxs-lookup"><span data-stu-id="99f15-128">All value types implicitly declare a public parameterless instance constructor called the ***default constructor***.</span></span> <span data-ttu-id="99f15-129">Der Standardkonstruktor gibt eine NULL initialisierte Instanz zurück, die als ***Standardwert*** für den Werttyp bezeichnet wird:</span><span class="sxs-lookup"><span data-stu-id="99f15-129">The default constructor returns a zero-initialized instance known as the ***default value*** for the value type:</span></span>

*  <span data-ttu-id="99f15-130">Der Standardwert für alle *Simple_Type*s ist der Wert, der von einem Bitmuster aller Nullen erzeugt wird:</span><span class="sxs-lookup"><span data-stu-id="99f15-130">For all *simple_type*s, the default value is the value produced by a bit pattern of all zeros:</span></span>
    * <span data-ttu-id="99f15-131">Für `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`und `ulong`ist der Standardwert `0`.</span><span class="sxs-lookup"><span data-stu-id="99f15-131">For `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, and `ulong`, the default value is `0`.</span></span>
    * <span data-ttu-id="99f15-132">Der Standardwert für `char`ist `'\x0000'`.</span><span class="sxs-lookup"><span data-stu-id="99f15-132">For `char`, the default value is `'\x0000'`.</span></span>
    * <span data-ttu-id="99f15-133">Der Standardwert für `float`ist `0.0f`.</span><span class="sxs-lookup"><span data-stu-id="99f15-133">For `float`, the default value is `0.0f`.</span></span>
    * <span data-ttu-id="99f15-134">Der Standardwert für `double`ist `0.0d`.</span><span class="sxs-lookup"><span data-stu-id="99f15-134">For `double`, the default value is `0.0d`.</span></span>
    * <span data-ttu-id="99f15-135">Der Standardwert für `decimal`ist `0.0m`.</span><span class="sxs-lookup"><span data-stu-id="99f15-135">For `decimal`, the default value is `0.0m`.</span></span>
    * <span data-ttu-id="99f15-136">Der Standardwert für `bool`ist `false`.</span><span class="sxs-lookup"><span data-stu-id="99f15-136">For `bool`, the default value is `false`.</span></span>
*  <span data-ttu-id="99f15-137">Bei einem *enum_type* `E`wird der Standardwert `0`in den Typ `E`konvertiert.</span><span class="sxs-lookup"><span data-stu-id="99f15-137">For an *enum_type* `E`, the default value is `0`, converted to the type `E`.</span></span>
*  <span data-ttu-id="99f15-138">Bei einem *struct_type*ist der Standardwert der Wert, der erzeugt wird, indem alle Werttyp Felder auf ihren Standardwert und alle Verweistyp Felder auf `null`festgelegt werden.</span><span class="sxs-lookup"><span data-stu-id="99f15-138">For a *struct_type*, the default value is the value produced by setting all value type fields to their default value and all reference type fields to `null`.</span></span>
*  <span data-ttu-id="99f15-139">Bei einem- *nullable_type* ist der Standardwert eine-Instanz, für die die `HasValue`-Eigenschaft false ist und die `Value`-Eigenschaft nicht definiert ist.</span><span class="sxs-lookup"><span data-stu-id="99f15-139">For a *nullable_type* the default value is an instance for which the `HasValue` property is false and the `Value` property is undefined.</span></span> <span data-ttu-id="99f15-140">Der Standardwert wird auch als NULL- ***Wert*** des Typs bezeichnet, der NULL-Werte zulässt.</span><span class="sxs-lookup"><span data-stu-id="99f15-140">The default value is also known as the ***null value*** of the nullable type.</span></span>

<span data-ttu-id="99f15-141">Wie jeder andere Instanzkonstruktor wird der Standardkonstruktor eines Werttyps mit dem `new`-Operator aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="99f15-141">Like any other instance constructor, the default constructor of a value type is invoked using the `new` operator.</span></span> <span data-ttu-id="99f15-142">Aus Effizienzgründen ist diese Anforderung nicht dafür vorgesehen, dass die Implementierung einen konstruktorbefehl generiert.</span><span class="sxs-lookup"><span data-stu-id="99f15-142">For efficiency reasons, this requirement is not intended to actually have the implementation generate a constructor call.</span></span> <span data-ttu-id="99f15-143">Im folgenden Beispiel werden die Variablen `i` und `j` beide mit 0 (null) initialisiert.</span><span class="sxs-lookup"><span data-stu-id="99f15-143">In the example below, variables `i` and `j` are both initialized to zero.</span></span>

```csharp
class A
{
    void F() {
        int i = 0;
        int j = new int();
    }
}
```

<span data-ttu-id="99f15-144">Da jeder Werttyp implizit über einen öffentlichen Parameter losen Instanzenkonstruktor verfügt, ist es nicht möglich, dass ein Strukturtyp eine explizite Deklaration eines Parameter losen Konstruktors enthält.</span><span class="sxs-lookup"><span data-stu-id="99f15-144">Because every value type implicitly has a public parameterless instance constructor, it is not possible for a struct type to contain an explicit declaration of a parameterless constructor.</span></span> <span data-ttu-id="99f15-145">Ein Strukturtyp ist jedoch zulässig, um parametrisierte Instanzkonstruktoren ([Konstruktoren](structs.md#constructors)) zu deklarieren.</span><span class="sxs-lookup"><span data-stu-id="99f15-145">A struct type is however permitted to declare parameterized instance constructors ([Constructors](structs.md#constructors)).</span></span>

### <a name="struct-types"></a><span data-ttu-id="99f15-146">Strukturtypen</span><span class="sxs-lookup"><span data-stu-id="99f15-146">Struct types</span></span>

<span data-ttu-id="99f15-147">Ein Strukturtyp ist ein Werttyp, der Konstanten, Felder, Methoden, Eigenschaften, Indexer, Operatoren, Instanzkonstruktoren, statische Konstruktoren und Strukturtypen deklarieren kann.</span><span class="sxs-lookup"><span data-stu-id="99f15-147">A struct type is a value type that can declare constants, fields, methods, properties, indexers, operators, instance constructors, static constructors, and nested types.</span></span> <span data-ttu-id="99f15-148">Die Deklaration von Strukturtypen wird in [Struktur Deklarationen](structs.md#struct-declarations)beschrieben.</span><span class="sxs-lookup"><span data-stu-id="99f15-148">The declaration of struct types is described in [Struct declarations](structs.md#struct-declarations).</span></span>

### <a name="simple-types"></a><span data-ttu-id="99f15-149">Einfache Typen</span><span class="sxs-lookup"><span data-stu-id="99f15-149">Simple types</span></span>

<span data-ttu-id="99f15-150">C#stellt einen Satz vordefinierter Strukturtypen bereit, die als ***einfache Typen***bezeichnet werden.</span><span class="sxs-lookup"><span data-stu-id="99f15-150">C# provides a set of predefined struct types called the ***simple types***.</span></span> <span data-ttu-id="99f15-151">Die einfachen Typen werden mithilfe von reservierten Wörtern identifiziert. diese reservierten Wörter sind jedoch einfach Aliase für vordefinierte Strukturtypen im `System` Namespace, wie in der folgenden Tabelle beschrieben.</span><span class="sxs-lookup"><span data-stu-id="99f15-151">The simple types are identified through reserved words, but these reserved words are simply aliases for predefined struct types in the `System` namespace, as described in the table below.</span></span>


| <span data-ttu-id="99f15-152">__Reserviertes Wort__</span><span class="sxs-lookup"><span data-stu-id="99f15-152">__Reserved word__</span></span> | <span data-ttu-id="99f15-153">__Alias-Typ__</span><span class="sxs-lookup"><span data-stu-id="99f15-153">__Aliased type__</span></span> |
|-------------------|------------------|
| `sbyte`           | `System.SByte`   | 
| `byte`            | `System.Byte`    | 
| `short`           | `System.Int16`   | 
| `ushort`          | `System.UInt16`  | 
| `int`             | `System.Int32`   | 
| `uint`            | `System.UInt32`  | 
| `long`            | `System.Int64`   | 
| `ulong`           | `System.UInt64`  | 
| `char`            | `System.Char`    | 
| `float`           | `System.Single`  | 
| `double`          | `System.Double`  | 
| `bool`            | `System.Boolean` | 
| `decimal`         | `System.Decimal` | 

<span data-ttu-id="99f15-154">Da ein einfacher Typ einen Strukturtyp Aliase, verfügt jeder einfache Typ über Member.</span><span class="sxs-lookup"><span data-stu-id="99f15-154">Because a simple type aliases a struct type, every simple type has members.</span></span> <span data-ttu-id="99f15-155">Beispielsweise `int` die in `System.Int32` deklarierten Member und die Member, die von `System.Object`geerbt werden, und die folgenden Anweisungen sind zulässig:</span><span class="sxs-lookup"><span data-stu-id="99f15-155">For example, `int` has the members declared in `System.Int32` and the members inherited from `System.Object`, and the following statements are permitted:</span></span>

```csharp
int i = int.MaxValue;           // System.Int32.MaxValue constant
string s = i.ToString();        // System.Int32.ToString() instance method
string t = 123.ToString();      // System.Int32.ToString() instance method
```

<span data-ttu-id="99f15-156">Die einfachen Typen unterscheiden sich von anderen Strukturtypen dadurch, dass sie bestimmte zusätzliche Vorgänge ermöglichen:</span><span class="sxs-lookup"><span data-stu-id="99f15-156">The simple types differ from other struct types in that they permit certain additional operations:</span></span>

*  <span data-ttu-id="99f15-157">Bei den meisten einfachen Typen können Werte erstellt werden, indem *Literale* ([Literale](lexical-structure.md#literals)) geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="99f15-157">Most simple types permit values to be created by writing *literals* ([Literals](lexical-structure.md#literals)).</span></span> <span data-ttu-id="99f15-158">`123` ist z. b. ein Literaltyp `int`, und `'a'` ist ein Literaltyp `char`.</span><span class="sxs-lookup"><span data-stu-id="99f15-158">For example, `123` is a literal of type `int` and `'a'` is a literal of type `char`.</span></span> <span data-ttu-id="99f15-159">C#stellt im Allgemeinen keine Bereitstellung von literalen von Strukturtypen bereit, und nicht standardmäßige Werte anderer Strukturtypen werden letztendlich immer durch Instanzkonstruktoren dieser Strukturtypen erstellt.</span><span class="sxs-lookup"><span data-stu-id="99f15-159">C# makes no provision for literals of struct types in general, and non-default values of other struct types are ultimately always created through instance constructors of those struct types.</span></span>
*  <span data-ttu-id="99f15-160">Wenn es sich bei den Operanden eines Ausdrucks um einfache Typkonstanten handelt, kann der Compiler den Ausdruck zur Kompilierzeit auswerten.</span><span class="sxs-lookup"><span data-stu-id="99f15-160">When the operands of an expression are all simple type constants, it is possible for the compiler to evaluate the expression at compile-time.</span></span> <span data-ttu-id="99f15-161">Ein solcher Ausdruck wird als *constant_expression* ([Konstante Ausdrücke](expressions.md#constant-expressions)) bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="99f15-161">Such an expression is known as a *constant_expression* ([Constant expressions](expressions.md#constant-expressions)).</span></span> <span data-ttu-id="99f15-162">Ausdrücke mit Operatoren, die von anderen Strukturtypen definiert werden, werden nicht als Konstante Ausdrücke betrachtet.</span><span class="sxs-lookup"><span data-stu-id="99f15-162">Expressions involving operators defined by other struct types are not considered to be constant expressions.</span></span>
*  <span data-ttu-id="99f15-163">Durch `const` Deklarationen ist es möglich, Konstanten der einfachen Typen ([Konstanten](classes.md#constants)) zu deklarieren.</span><span class="sxs-lookup"><span data-stu-id="99f15-163">Through `const` declarations it is possible to declare constants of the simple types ([Constants](classes.md#constants)).</span></span> <span data-ttu-id="99f15-164">Es ist nicht möglich, Konstanten anderer Strukturtypen zu haben, aber ein ähnlicher Effekt wird durch `static readonly` Felder bereitgestellt.</span><span class="sxs-lookup"><span data-stu-id="99f15-164">It is not possible to have constants of other struct types, but a similar effect is provided by `static readonly` fields.</span></span>
*  <span data-ttu-id="99f15-165">Konvertierungen, die einfache Typen umfassen, können an der Auswertung von Konvertierungs Operatoren teilnehmen, die von anderen Strukturtypen definiert werden, aber ein benutzerdefinierter Konvertierungs Operator kann nie an der Auswertung eines anderen benutzerdefinierten Operators teilnehmen ([Auswertung benutzerdefinierter Konvertierungen](conversions.md#evaluation-of-user-defined-conversions)).</span><span class="sxs-lookup"><span data-stu-id="99f15-165">Conversions involving simple types can participate in evaluation of conversion operators defined by other struct types, but a user-defined conversion operator can never participate in evaluation of another user-defined operator ([Evaluation of user-defined conversions](conversions.md#evaluation-of-user-defined-conversions)).</span></span>

### <a name="integral-types"></a><span data-ttu-id="99f15-166">Ganzzahlige Typen</span><span class="sxs-lookup"><span data-stu-id="99f15-166">Integral types</span></span>

<span data-ttu-id="99f15-167">C#unterstützt neun ganzzahlige Typen: `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`und `char`.</span><span class="sxs-lookup"><span data-stu-id="99f15-167">C# supports nine integral types: `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, and `char`.</span></span> <span data-ttu-id="99f15-168">Die ganzzahligen Typen weisen die folgenden Größen und Wertebereiche auf:</span><span class="sxs-lookup"><span data-stu-id="99f15-168">The integral types have the following sizes and ranges of values:</span></span>

*  <span data-ttu-id="99f15-169">Der `sbyte`-Typ stellt signierte 8-Bit-Ganzzahlen mit Werten zwischen-128 und 127 dar.</span><span class="sxs-lookup"><span data-stu-id="99f15-169">The `sbyte` type represents signed 8-bit integers with values between -128 and 127.</span></span>
*  <span data-ttu-id="99f15-170">Der `byte`-Typ stellt ganze 8-Bit-Ganzzahlen ohne Vorzeichen mit Werten zwischen 0 und 255 dar.</span><span class="sxs-lookup"><span data-stu-id="99f15-170">The `byte` type represents unsigned 8-bit integers with values between 0 and 255.</span></span>
*  <span data-ttu-id="99f15-171">Der `short` Typ stellt signierte 16-Bit-Ganzzahlen mit Werten zwischen-32768 und 32767 dar.</span><span class="sxs-lookup"><span data-stu-id="99f15-171">The `short` type represents signed 16-bit integers with values between -32768 and 32767.</span></span>
*  <span data-ttu-id="99f15-172">Der `ushort`-Typ stellt ganze 16-Bit-Ganzzahlen ohne Vorzeichen mit Werten zwischen 0 und 65535 dar.</span><span class="sxs-lookup"><span data-stu-id="99f15-172">The `ushort` type represents unsigned 16-bit integers with values between 0 and 65535.</span></span>
*  <span data-ttu-id="99f15-173">Der `int`-Typ stellt signierte 32-Bit-Ganzzahlen mit Werten zwischen-2147483648 und 2147483647 dar.</span><span class="sxs-lookup"><span data-stu-id="99f15-173">The `int` type represents signed 32-bit integers with values between -2147483648 and 2147483647.</span></span>
*  <span data-ttu-id="99f15-174">Der `uint`-Typ stellt ganzzahlige 32-Bit-Ganzzahlen ohne Vorzeichen mit Werten zwischen 0 und 4294967295 dar.</span><span class="sxs-lookup"><span data-stu-id="99f15-174">The `uint` type represents unsigned 32-bit integers with values between 0 and 4294967295.</span></span>
*  <span data-ttu-id="99f15-175">Der `long`-Typ stellt signierte 64-Bit-Ganzzahlen mit Werten zwischen-9.223.372.036.854.775.808 und 9223372036854775807 dar.</span><span class="sxs-lookup"><span data-stu-id="99f15-175">The `long` type represents signed 64-bit integers with values between -9223372036854775808 and 9223372036854775807.</span></span>
*  <span data-ttu-id="99f15-176">Der `ulong`-Typ stellt ganzzahlige 64-Bit-Ganzzahlen ohne Vorzeichen mit Werten zwischen 0 und 18446744073709551615 dar.</span><span class="sxs-lookup"><span data-stu-id="99f15-176">The `ulong` type represents unsigned 64-bit integers with values between 0 and 18446744073709551615.</span></span>
*  <span data-ttu-id="99f15-177">Der `char`-Typ stellt ganze 16-Bit-Ganzzahlen ohne Vorzeichen mit Werten zwischen 0 und 65535 dar.</span><span class="sxs-lookup"><span data-stu-id="99f15-177">The `char` type represents unsigned 16-bit integers with values between 0 and 65535.</span></span> <span data-ttu-id="99f15-178">Der Satz möglicher Werte für den `char` Typ entspricht dem Unicode-Zeichensatz.</span><span class="sxs-lookup"><span data-stu-id="99f15-178">The set of possible values for the `char` type corresponds to the Unicode character set.</span></span> <span data-ttu-id="99f15-179">Obwohl `char` die gleiche Darstellung wie `ushort`hat, sind nicht alle Vorgänge zulässig, die für einen Typ zulässig sind.</span><span class="sxs-lookup"><span data-stu-id="99f15-179">Although `char` has the same representation as `ushort`, not all operations permitted on one type are permitted on the other.</span></span>

<span data-ttu-id="99f15-180">Der unäre und binäre Operator des ganzzahligen Typs funktionieren immer mit der signierten 32-Bit-Genauigkeit, der 32-Bit-Genauigkeit ohne Vorzeichen, der 64-Bit-Genauigkeit mit Vorzeichen oder der 64-Bit-Genauigkeit ohne Vorzeichen:</span><span class="sxs-lookup"><span data-stu-id="99f15-180">The integral-type unary and binary operators always operate with signed 32-bit precision, unsigned 32-bit precision, signed 64-bit precision, or unsigned 64-bit precision:</span></span>

*  <span data-ttu-id="99f15-181">Für die unären `+` und `~` Operatoren wird der Operand in den Typ `T`konvertiert, wobei `T` der erste von `int`, `uint`, `long`und `ulong` ist, die alle möglichen Werte des Operanden vollständig darstellen können.</span><span class="sxs-lookup"><span data-stu-id="99f15-181">For the unary `+` and `~` operators, the operand is converted to type `T`, where `T` is the first of `int`, `uint`, `long`, and `ulong` that can fully represent all possible values of the operand.</span></span> <span data-ttu-id="99f15-182">Der Vorgang wird dann mit der Genauigkeit des Typs `T`ausgeführt, und der Ergebnistyp ist `T`.</span><span class="sxs-lookup"><span data-stu-id="99f15-182">The operation is then performed using the precision of type `T`, and the type of the result is `T`.</span></span>
*  <span data-ttu-id="99f15-183">Für den unären `-` Operator wird der Operand in den Typ `T`konvertiert, wobei `T` der erste von `int` und `long` ist, der alle möglichen Werte des Operanden vollständig darstellen kann.</span><span class="sxs-lookup"><span data-stu-id="99f15-183">For the unary `-` operator, the operand is converted to type `T`, where `T` is the first of `int` and `long` that can fully represent all possible values of the operand.</span></span> <span data-ttu-id="99f15-184">Der Vorgang wird dann mit der Genauigkeit des Typs `T`ausgeführt, und der Ergebnistyp ist `T`.</span><span class="sxs-lookup"><span data-stu-id="99f15-184">The operation is then performed using the precision of type `T`, and the type of the result is `T`.</span></span> <span data-ttu-id="99f15-185">Der unäre `-`-Operator kann nicht auf Operanden vom Typ "`ulong`" angewendet werden.</span><span class="sxs-lookup"><span data-stu-id="99f15-185">The unary `-` operator cannot be applied to operands of type `ulong`.</span></span>
*  <span data-ttu-id="99f15-186">Die Operatoren Binary `+`, `-`, `*`, `/`, `%`, `&`, `^`, `|`, `==`, `!=`, `>`, `<`, `>=`und `<=` werden die Operanden in den Typ `T`konvertiert, wobei `T` der erste von `int`, `uint`, `long`und `ulong` ist, die alle möglichen Werte beider Operanden vollständig darstellen können.</span><span class="sxs-lookup"><span data-stu-id="99f15-186">For the binary `+`, `-`, `*`, `/`, `%`, `&`, `^`, `|`, `==`, `!=`, `>`, `<`, `>=`, and `<=` operators, the operands are converted to type `T`, where `T` is the first of `int`, `uint`, `long`, and `ulong` that can fully represent all possible values of both operands.</span></span> <span data-ttu-id="99f15-187">Der Vorgang wird dann mit der Genauigkeit des Typs `T`ausgeführt, und der Ergebnistyp ist `T` (oder `bool` für die relationalen Operatoren).</span><span class="sxs-lookup"><span data-stu-id="99f15-187">The operation is then performed using the precision of type `T`, and the type of the result is `T` (or `bool` for the relational operators).</span></span> <span data-ttu-id="99f15-188">Es ist nicht zulässig, dass ein Operand vom Typ `long` und der andere vom Typ ist, der mit den binären Operatoren `ulong` ist.</span><span class="sxs-lookup"><span data-stu-id="99f15-188">It is not permitted for one operand to be of type `long` and the other to be of type `ulong` with the binary operators.</span></span>
*  <span data-ttu-id="99f15-189">Für die binären `<<`-und `>>` Operatoren wird der linke Operand in den Typ `T`konvertiert, wobei `T` der erste von `int`, `uint`, `long`und `ulong` ist, die alle möglichen Werte des Operanden vollständig darstellen können.</span><span class="sxs-lookup"><span data-stu-id="99f15-189">For the binary `<<` and `>>` operators, the left operand is converted to type `T`, where `T` is the first of `int`, `uint`, `long`, and `ulong` that can fully represent all possible values of the operand.</span></span> <span data-ttu-id="99f15-190">Der Vorgang wird dann mit der Genauigkeit des Typs `T`ausgeführt, und der Ergebnistyp ist `T`.</span><span class="sxs-lookup"><span data-stu-id="99f15-190">The operation is then performed using the precision of type `T`, and the type of the result is `T`.</span></span>

<span data-ttu-id="99f15-191">Der `char` Typ wird als ganzzahliger Typ klassifiziert, aber er unterscheidet sich von den anderen ganzzahligen Typen auf zwei Arten:</span><span class="sxs-lookup"><span data-stu-id="99f15-191">The `char` type is classified as an integral type, but it differs from the other integral types in two ways:</span></span>

*  <span data-ttu-id="99f15-192">Es gibt keine impliziten Konvertierungen anderen Typen in Typ `char`.</span><span class="sxs-lookup"><span data-stu-id="99f15-192">There are no implicit conversions from other types to the `char` type.</span></span> <span data-ttu-id="99f15-193">Insbesondere wenn die Typen `sbyte`, `byte`und `ushort` Wertebereiche aufweisen, die mithilfe des `char` Typs vollständig Darstell Bar sind, sind implizite Konvertierungen von `sbyte`, `byte`oder `ushort` `char` nicht vorhanden.</span><span class="sxs-lookup"><span data-stu-id="99f15-193">In particular, even though the `sbyte`, `byte`, and `ushort` types have ranges of values that are fully representable using the `char` type, implicit conversions from `sbyte`, `byte`, or `ushort` to `char` do not exist.</span></span>
*  <span data-ttu-id="99f15-194">Konstanten des `char` Typs müssen als *character_literal*s oder als *integer_literal*en in Kombination mit einer Umwandlung in den Typ `char`geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="99f15-194">Constants of the `char` type must be written as *character_literal*s or as *integer_literal*s in combination with a cast to type `char`.</span></span> <span data-ttu-id="99f15-195">`(char)10` entspricht beispielsweise `'\x000A'`.</span><span class="sxs-lookup"><span data-stu-id="99f15-195">For example, `(char)10` is the same as `'\x000A'`.</span></span>

<span data-ttu-id="99f15-196">Mithilfe der Operatoren "`checked`" und "`unchecked`" werden Überlauf Prüfungen bei arithmetischen Operationen und Konvertierungen von ganzzahligen Typen gesteuert (die aktivierten und deaktivierten[Operatoren](expressions.md#the-checked-and-unchecked-operators)).</span><span class="sxs-lookup"><span data-stu-id="99f15-196">The `checked` and `unchecked` operators and statements are used to control overflow checking for integral-type arithmetic operations and conversions ([The checked and unchecked operators](expressions.md#the-checked-and-unchecked-operators)).</span></span> <span data-ttu-id="99f15-197">In einem `checked` Kontext erzeugt ein Überlauf einen Kompilierzeitfehler oder bewirkt, dass eine `System.OverflowException` ausgelöst wird.</span><span class="sxs-lookup"><span data-stu-id="99f15-197">In a `checked` context, an overflow produces a compile-time error or causes a `System.OverflowException` to be thrown.</span></span> <span data-ttu-id="99f15-198">In einem `unchecked` Kontext werden Überläufe ignoriert, und alle höherwertigen Bits, die nicht in den Zieltyp passen, werden verworfen.</span><span class="sxs-lookup"><span data-stu-id="99f15-198">In an `unchecked` context, overflows are ignored and any high-order bits that do not fit in the destination type are discarded.</span></span>

### <a name="floating-point-types"></a><span data-ttu-id="99f15-199">Gleit Komma Typen</span><span class="sxs-lookup"><span data-stu-id="99f15-199">Floating point types</span></span>

<span data-ttu-id="99f15-200">C#unterstützt zwei Gleit Komma Typen: `float` und `double`.</span><span class="sxs-lookup"><span data-stu-id="99f15-200">C# supports two floating point types: `float` and `double`.</span></span> <span data-ttu-id="99f15-201">Die `float`-und `double` Typen werden mithilfe der 32-Bit-Formate für die einfache Genauigkeit und 64 Bit mit doppelter Genauigkeit mit doppelter 754 Genauigkeit dargestellt, die die folgenden Werte Sätze bereitstellen:</span><span class="sxs-lookup"><span data-stu-id="99f15-201">The `float` and `double` types are represented using the 32-bit single-precision and 64-bit double-precision IEEE 754 formats, which provide the following sets of values:</span></span>

*  <span data-ttu-id="99f15-202">Positive NULL und negative Null.</span><span class="sxs-lookup"><span data-stu-id="99f15-202">Positive zero and negative zero.</span></span> <span data-ttu-id="99f15-203">In den meisten Fällen verhalten sich positiv NULL und negatives NULL identisch mit dem einfachen Wert 0 (null), aber bestimmte Vorgänge unterscheiden zwischen den beiden ([Divisions Operator](expressions.md#division-operator)).</span><span class="sxs-lookup"><span data-stu-id="99f15-203">In most situations, positive zero and negative zero behave identically as the simple value zero, but certain operations distinguish between the two ([Division operator](expressions.md#division-operator)).</span></span>
*  <span data-ttu-id="99f15-204">Positiv unendlich und minus unendlich.</span><span class="sxs-lookup"><span data-stu-id="99f15-204">Positive infinity and negative infinity.</span></span> <span data-ttu-id="99f15-205">Infinities werden von solchen Vorgängen erzeugt, die eine Zahl ungleich 0 (null) durch Null aufteilen.</span><span class="sxs-lookup"><span data-stu-id="99f15-205">Infinities are produced by such operations as dividing a non-zero number by zero.</span></span> <span data-ttu-id="99f15-206">`1.0 / 0.0` ergibt beispielsweise positive unendlich, und `-1.0 / 0.0` ergibt negative unendlich.</span><span class="sxs-lookup"><span data-stu-id="99f15-206">For example, `1.0 / 0.0` yields positive infinity, and `-1.0 / 0.0` yields negative infinity.</span></span>
*  <span data-ttu-id="99f15-207">Der ***not-a-Number-*** Wert, häufig als NaN abgekürzt.</span><span class="sxs-lookup"><span data-stu-id="99f15-207">The ***Not-a-Number*** value, often abbreviated NaN.</span></span> <span data-ttu-id="99f15-208">Nane werden durch ungültige Gleit Komma Vorgänge erstellt, z. b. durch die Division von NULL durch Null.</span><span class="sxs-lookup"><span data-stu-id="99f15-208">NaNs are produced by invalid floating-point operations, such as dividing zero by zero.</span></span>
*  <span data-ttu-id="99f15-209">Der endliche Satz von Werten ungleich 0 (null) `s * m * 2^e`, wobei `s` 1 oder-1 ist, und `m` und `e` durch den jeweiligen Gleit kommatyp bestimmt werden: für `float`, `0 < m < 2^24` und `-149 <= e <= 104`sowie `double`und `0 < m < 2^53`.`-1075 <= e <= 970`</span><span class="sxs-lookup"><span data-stu-id="99f15-209">The finite set of non-zero values of the form `s * m * 2^e`, where `s` is 1 or -1, and `m` and `e` are determined by the particular floating-point type: For `float`, `0 < m < 2^24` and `-149 <= e <= 104`, and for `double`, `0 < m < 2^53` and `-1075 <= e <= 970`.</span></span> <span data-ttu-id="99f15-210">Denormalisierte Gleit Komma Zahlen gelten als gültige Werte ungleich 0 (null).</span><span class="sxs-lookup"><span data-stu-id="99f15-210">Denormalized floating-point numbers are considered valid non-zero values.</span></span>

<span data-ttu-id="99f15-211">Der `float`-Typ kann Werte darstellen, die von ungefähr `1.5 * 10^-45` bis `3.4 * 10^38` mit einer Genauigkeit von 7 Ziffern reichen.</span><span class="sxs-lookup"><span data-stu-id="99f15-211">The `float` type can represent values ranging from approximately `1.5 * 10^-45` to `3.4 * 10^38` with a precision of 7 digits.</span></span>

<span data-ttu-id="99f15-212">Der `double`-Typ kann Werte darstellen, die von ungefähr `5.0 * 10^-324` bis `1.7 × 10^308` mit einer Genauigkeit von 15-16 Ziffern reichen.</span><span class="sxs-lookup"><span data-stu-id="99f15-212">The `double` type can represent values ranging from approximately `5.0 * 10^-324` to `1.7 × 10^308` with a precision of 15-16 digits.</span></span>

<span data-ttu-id="99f15-213">Wenn einer der Operanden eines binären Operators ein Gleit kommatyp ist, muss der andere Operand ein ganzzahliger Typ oder ein Gleit kommatyp sein, und der Vorgang wird wie folgt ausgewertet:</span><span class="sxs-lookup"><span data-stu-id="99f15-213">If one of the operands of a binary operator is of a floating-point type, then the other operand must be of an integral type or a floating-point type, and the operation is evaluated as follows:</span></span>

*  <span data-ttu-id="99f15-214">Wenn einer der Operanden ein ganzzahliger Typ ist, wird dieser Operand in den Gleit kommatyp des anderen Operanden konvertiert.</span><span class="sxs-lookup"><span data-stu-id="99f15-214">If one of the operands is of an integral type, then that operand is converted to the floating-point type of the other operand.</span></span>
*  <span data-ttu-id="99f15-215">Wenn einer der Operanden vom Typ `double`ist, wird der andere Operand in `double`konvertiert, der Vorgang wird mit mindestens `double` Bereich und Genauigkeit durchgeführt, und der Ergebnistyp wird `double` (oder `bool` für die relationalen Operatoren).</span><span class="sxs-lookup"><span data-stu-id="99f15-215">Then, if either of the operands is of type `double`, the other operand is converted to `double`, the operation is performed using at least `double` range and precision, and the type of the result is `double` (or `bool` for the relational operators).</span></span>
*  <span data-ttu-id="99f15-216">Andernfalls wird der Vorgang mit mindestens `float` Bereich und Genauigkeit durchgeführt, und der Ergebnistyp wird `float` (oder für die relationalen Operatoren `bool`).</span><span class="sxs-lookup"><span data-stu-id="99f15-216">Otherwise, the operation is performed using at least `float` range and precision, and the type of the result is `float` (or `bool` for the relational operators).</span></span>

<span data-ttu-id="99f15-217">Die Gleit Komma Operatoren, einschließlich der Zuweisungs Operatoren, führen niemals zu Ausnahmen.</span><span class="sxs-lookup"><span data-stu-id="99f15-217">The floating-point operators, including the assignment operators, never produce exceptions.</span></span> <span data-ttu-id="99f15-218">In Ausnahmefällen wird von Gleit Komma Vorgängen, wie unten beschrieben, NULL, unendlich oder NaN erzeugt:</span><span class="sxs-lookup"><span data-stu-id="99f15-218">Instead, in exceptional situations, floating-point operations produce zero, infinity, or NaN, as described below:</span></span>

*  <span data-ttu-id="99f15-219">Wenn das Ergebnis einer Gleit Komma Operation für das Zielformat zu klein ist, wird das Ergebnis des Vorgangs positiv 0 (null) oder negativ 0 (null).</span><span class="sxs-lookup"><span data-stu-id="99f15-219">If the result of a floating-point operation is too small for the destination format, the result of the operation becomes positive zero or negative zero.</span></span>
*  <span data-ttu-id="99f15-220">Wenn das Ergebnis einer Gleit Komma Operation für das Zielformat zu groß ist, wird das Ergebnis des Vorgangs positiv unendlich oder negativ unendlich.</span><span class="sxs-lookup"><span data-stu-id="99f15-220">If the result of a floating-point operation is too large for the destination format, the result of the operation becomes positive infinity or negative infinity.</span></span>
*  <span data-ttu-id="99f15-221">Wenn ein Gleit Komma Vorgang ungültig ist, wird das Ergebnis des Vorgangs "NaN".</span><span class="sxs-lookup"><span data-stu-id="99f15-221">If a floating-point operation is invalid, the result of the operation becomes NaN.</span></span>
*  <span data-ttu-id="99f15-222">Wenn ein oder beide Operanden einer Gleit Komma Operation NaN sind, wird das Ergebnis des Vorgangs Nan.</span><span class="sxs-lookup"><span data-stu-id="99f15-222">If one or both operands of a floating-point operation is NaN, the result of the operation becomes NaN.</span></span>

<span data-ttu-id="99f15-223">Gleit Komma Operationen können mit höherer Genauigkeit ausgeführt werden als der Ergebnistyp des Vorgangs.</span><span class="sxs-lookup"><span data-stu-id="99f15-223">Floating-point operations may be performed with higher precision than the result type of the operation.</span></span> <span data-ttu-id="99f15-224">Beispielsweise unterstützen einige Hardwarearchitekturen einen "Extended"-oder "long Double"-Gleit kommatyp mit größerem Bereich und präziser als der `double`-Typ und führen implizit alle Gleit Komma Vorgänge mit diesem Typ höherer Genauigkeit aus.</span><span class="sxs-lookup"><span data-stu-id="99f15-224">For example, some hardware architectures support an "extended" or "long double" floating-point type with greater range and precision than the `double` type, and implicitly perform all floating-point operations using this higher precision type.</span></span> <span data-ttu-id="99f15-225">Nur zu hohen Leistungseinbußen können solche Hardwarearchitekturen zum Ausführen von Gleit Komma Vorgängen mit geringerer Genauigkeit gemacht werden, und C# es ist nicht erforderlich, dass eine Implementierung sowohl die Leistung als auch die Genauigkeit beeinträchtigt. , der für alle Gleit Komma Operationen verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="99f15-225">Only at excessive cost in performance can such hardware architectures be made to perform floating-point operations with less precision, and rather than require an implementation to forfeit both performance and precision, C# allows a higher precision type to be used for all floating-point operations.</span></span> <span data-ttu-id="99f15-226">Abgesehen von der Bereitstellung präziseren Ergebnisse hat dies nur selten messbare Auswirkungen.</span><span class="sxs-lookup"><span data-stu-id="99f15-226">Other than delivering more precise results, this rarely has any measurable effects.</span></span> <span data-ttu-id="99f15-227">In Ausdrücken der Form `x * y / z`, wobei die Multiplikation ein Ergebnis erzeugt, das außerhalb des `double` Bereichs liegt, aber die nachfolgende Division das temporäre Ergebnis wieder in den `double` Bereich bringt, wird die Tatsache, dass der Ausdruck ausgewertet wird, in einem ein höheres Bereichs Format kann bewirken, dass ein endliches Ergebnis anstelle von unendlich erzeugt wird.</span><span class="sxs-lookup"><span data-stu-id="99f15-227">However, in expressions of the form `x * y / z`, where the multiplication produces a result that is outside the `double` range, but the subsequent division brings the temporary result back into the `double` range, the fact that the expression is evaluated in a higher range format may cause a finite result to be produced instead of an infinity.</span></span>

### <a name="the-decimal-type"></a><span data-ttu-id="99f15-228">Der Decimal-Typ.</span><span class="sxs-lookup"><span data-stu-id="99f15-228">The decimal type</span></span>

<span data-ttu-id="99f15-229">Der `decimal`-Typ ist ein für Finanz-und Währungsberechnungen geeigneter 128-Bit-Datentyp.</span><span class="sxs-lookup"><span data-stu-id="99f15-229">The `decimal` type is a 128-bit data type suitable for financial and monetary calculations.</span></span> <span data-ttu-id="99f15-230">Der `decimal`-Typ kann Werte zwischen `1.0 * 10^-28` und ungefähr `7.9 * 10^28` mit 28-29 signifikanten Ziffern darstellen.</span><span class="sxs-lookup"><span data-stu-id="99f15-230">The `decimal` type can represent values ranging from `1.0 * 10^-28` to approximately `7.9 * 10^28` with 28-29 significant digits.</span></span>

<span data-ttu-id="99f15-231">Der endliche Satz von Werten vom Typ `decimal` hat die Form `(-1)^s * c * 10^-e`, wobei das Vorzeichen `s` 0 oder 1 ist, der Koeffizienten `c` von `0 <= *c* < 2^96`angegeben wird und die Skalierungs `e` `0 <= e <= 28`. Der `decimal`-Typ unterstützt keine signierten Nullen, Infinities oder NaN-.</span><span class="sxs-lookup"><span data-stu-id="99f15-231">The finite set of values of type `decimal` are of the form `(-1)^s * c * 10^-e`, where the sign `s` is 0 or 1, the coefficient `c` is given by `0 <= *c* < 2^96`, and the scale `e` is such that `0 <= e <= 28`.The `decimal` type does not support signed zeros, infinities, or NaN's.</span></span> <span data-ttu-id="99f15-232">Ein `decimal` wird als eine ganze Zahl mit einer Länge von 96 dargestellt, die durch eine Potenz von zehn skaliert wird.</span><span class="sxs-lookup"><span data-stu-id="99f15-232">A `decimal` is represented as a 96-bit integer scaled by a power of ten.</span></span> <span data-ttu-id="99f15-233">Bei `decimal`s mit einem absoluten Wert, der kleiner als `1.0m`ist, entspricht der Wert exakt dem 28. Dezimaltrennzeichen, aber nicht weiter.</span><span class="sxs-lookup"><span data-stu-id="99f15-233">For `decimal`s with an absolute value less than `1.0m`, the value is exact to the 28th decimal place, but no further.</span></span> <span data-ttu-id="99f15-234">Bei `decimal`s mit einem absoluten Wert, der größer oder gleich `1.0m`ist, entspricht der Wert exakt 28 oder 29 Ziffern.</span><span class="sxs-lookup"><span data-stu-id="99f15-234">For `decimal`s with an absolute value greater than or equal to `1.0m`, the value is exact to 28 or 29 digits.</span></span> <span data-ttu-id="99f15-235">Im Gegensatz zu den Datentypen `float` und `double` können dezimale Bruchzahlen wie 0,1 genau in der `decimal` Darstellung dargestellt werden.</span><span class="sxs-lookup"><span data-stu-id="99f15-235">Contrary to the `float` and `double` data types, decimal fractional numbers such as 0.1 can be represented exactly in the `decimal` representation.</span></span> <span data-ttu-id="99f15-236">In den `float`-und `double` Darstellungen sind solche Zahlen häufig unendliche Bruchzahlen, sodass diese Darstellungen anfälliger für Fehler sind.</span><span class="sxs-lookup"><span data-stu-id="99f15-236">In the `float` and `double` representations, such numbers are often infinite fractions, making those representations more prone to round-off errors.</span></span>

<span data-ttu-id="99f15-237">Wenn einer der Operanden eines binären Operators vom Typ `decimal`ist, muss der andere Operand ein ganzzahliger Typ oder vom Typ `decimal`sein.</span><span class="sxs-lookup"><span data-stu-id="99f15-237">If one of the operands of a binary operator is of type `decimal`, then the other operand must be of an integral type or of type `decimal`.</span></span> <span data-ttu-id="99f15-238">Wenn ein ganzzahliger Typoperand vorhanden ist, wird er in `decimal` konvertiert, bevor der Vorgang durchgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="99f15-238">If an integral type operand is present, it is converted to `decimal` before the operation is performed.</span></span>

<span data-ttu-id="99f15-239">Das Ergebnis eines Vorgangs für Werte des Typs `decimal` ist, dass die Berechnung eines exakten Ergebnisses (wie für jeden Operator definiert) zu einem Ergebnis führt und dann an die Darstellung angepasst wird.</span><span class="sxs-lookup"><span data-stu-id="99f15-239">The result of an operation on values of type `decimal` is that which would result from calculating an exact result (preserving scale, as defined for each operator) and then rounding to fit the representation.</span></span> <span data-ttu-id="99f15-240">Die Ergebnisse werden auf den nächstgelegenen darstellbaren Wert gerundet und, wenn ein Ergebnis gleich nah bei zwei darstellbaren Werten ist, bis zu dem Wert, der eine gerade Zahl in der am wenigsten wichtigen Ziffern Position aufweist (Dies wird als "Banker srundung" bezeichnet).</span><span class="sxs-lookup"><span data-stu-id="99f15-240">Results are rounded to the nearest representable value, and, when a result is equally close to two representable values, to the value that has an even number in the least significant digit position (this is known as "banker's rounding").</span></span> <span data-ttu-id="99f15-241">Ein NULL-Ergebnis hat immer ein Vorzeichen von 0 und eine Skala von 0.</span><span class="sxs-lookup"><span data-stu-id="99f15-241">A zero result always has a sign of 0 and a scale of 0.</span></span>

<span data-ttu-id="99f15-242">Wenn eine arithmetische decimal-Operation einen Wert erzeugt, der kleiner als oder gleich `5 * 10^-29` im absoluten Wert ist, wird das Ergebnis des Vorgangs 0 (null).</span><span class="sxs-lookup"><span data-stu-id="99f15-242">If a decimal arithmetic operation produces a value less than or equal to `5 * 10^-29` in absolute value, the result of the operation becomes zero.</span></span> <span data-ttu-id="99f15-243">Wenn ein `decimal` arithmetischer Vorgang ein Ergebnis erzeugt, das für das `decimal` Format zu groß ist, wird ein `System.OverflowException` ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="99f15-243">If a `decimal` arithmetic operation produces a result that is too large for the `decimal` format, a `System.OverflowException` is thrown.</span></span>

<span data-ttu-id="99f15-244">Der `decimal` Typ hat eine höhere Genauigkeit, aber einen kleineren Bereich als die Gleit Komma Typen.</span><span class="sxs-lookup"><span data-stu-id="99f15-244">The `decimal` type has greater precision but smaller range than the floating-point types.</span></span> <span data-ttu-id="99f15-245">Folglich können Konvertierungen von Gleit Komma Typen in `decimal` Überlauf Ausnahmen erzeugen, und Konvertierungen aus `decimal` in die Gleit Komma Typen können zu Genauigkeits Verlusten führen.</span><span class="sxs-lookup"><span data-stu-id="99f15-245">Thus, conversions from the floating-point types to `decimal` might produce overflow exceptions, and conversions from `decimal` to the floating-point types might cause loss of precision.</span></span> <span data-ttu-id="99f15-246">Aus diesen Gründen sind keine impliziten Konvertierungen zwischen Gleit Komma Typen und `decimal`vorhanden, und ohne explizite Umwandlungen ist es nicht möglich, Gleit Komma-und `decimal` Operanden im gleichen Ausdruck zu mischen.</span><span class="sxs-lookup"><span data-stu-id="99f15-246">For these reasons, no implicit conversions exist between the floating-point types and `decimal`, and without explicit casts, it is not possible to mix floating-point and `decimal` operands in the same expression.</span></span>

### <a name="the-bool-type"></a><span data-ttu-id="99f15-247">Der boolesche Typ</span><span class="sxs-lookup"><span data-stu-id="99f15-247">The bool type</span></span>

<span data-ttu-id="99f15-248">Der `bool` Typ stellt boolesche logische Mengen dar.</span><span class="sxs-lookup"><span data-stu-id="99f15-248">The `bool` type represents boolean logical quantities.</span></span> <span data-ttu-id="99f15-249">Die möglichen Werte vom Typ `bool` sind `true` und `false`.</span><span class="sxs-lookup"><span data-stu-id="99f15-249">The possible values of type `bool` are `true` and `false`.</span></span>

<span data-ttu-id="99f15-250">Zwischen `bool` und anderen Typen sind keine Standard Konvertierungen vorhanden.</span><span class="sxs-lookup"><span data-stu-id="99f15-250">No standard conversions exist between `bool` and other types.</span></span> <span data-ttu-id="99f15-251">Der `bool` Typ ist insbesondere eindeutig und getrennt von den ganzzahligen Typen, und ein `bool` Wert kann nicht anstelle eines ganzzahligen Werts verwendet werden und umgekehrt.</span><span class="sxs-lookup"><span data-stu-id="99f15-251">In particular, the `bool` type is distinct and separate from the integral types, and a `bool` value cannot be used in place of an integral value, and vice versa.</span></span>

<span data-ttu-id="99f15-252">In den Programmiersprachen C++ C und kann ein ganzzahliger Wert von 0 (null) oder ein Gleit Komma Wert oder ein NULL-Zeiger in den booleschen Wert `false`konvertiert werden, und ein ganzzahliger oder Gleit Komma Wert ungleich NULL oder ein nicht-NULL-Zeiger kann in den booleschen Wert `true`konvertiert werden.</span><span class="sxs-lookup"><span data-stu-id="99f15-252">In the C and C++ languages, a zero integral or floating-point value, or a null pointer can be converted to the boolean value `false`, and a non-zero integral or floating-point value, or a non-null pointer can be converted to the boolean value `true`.</span></span> <span data-ttu-id="99f15-253">In C#werden solche Konvertierungen durch explizites Vergleichen eines ganzzahligen oder Gleit Komma Werts mit 0 (null) oder durch explizites Vergleichen eines Objekt Verweises mit `null`erreicht.</span><span class="sxs-lookup"><span data-stu-id="99f15-253">In C#, such conversions are accomplished by explicitly comparing an integral or floating-point value to zero, or by explicitly comparing an object reference to `null`.</span></span>

### <a name="enumeration-types"></a><span data-ttu-id="99f15-254">Enumerationstypen</span><span class="sxs-lookup"><span data-stu-id="99f15-254">Enumeration types</span></span>

<span data-ttu-id="99f15-255">Ein Enumerationstyp ist ein eindeutiger Typ mit benannten Konstanten.</span><span class="sxs-lookup"><span data-stu-id="99f15-255">An enumeration type is a distinct type with named constants.</span></span> <span data-ttu-id="99f15-256">Jeder Enumerationstyp verfügt über einen zugrunde liegenden Typ, der `byte`, `sbyte`, `short`, `ushort`, `int`, `uint`, `long` oder `ulong`sein muss.</span><span class="sxs-lookup"><span data-stu-id="99f15-256">Every enumeration type has an underlying type, which must be `byte`, `sbyte`, `short`, `ushort`, `int`, `uint`, `long` or `ulong`.</span></span> <span data-ttu-id="99f15-257">Der Satz von Werten des Enumerationstyps ist mit dem Satz von Werten des zugrunde liegenden Typs identisch.</span><span class="sxs-lookup"><span data-stu-id="99f15-257">The set of values of the enumeration type is the same as the set of values of the underlying type.</span></span> <span data-ttu-id="99f15-258">Werte des Enumerationstyps sind nicht auf die Werte der benannten Konstanten beschränkt.</span><span class="sxs-lookup"><span data-stu-id="99f15-258">Values of the enumeration type are not restricted to the values of the named constants.</span></span> <span data-ttu-id="99f15-259">Enumerationstypen werden durch Enumerationsdeklarationen (Enumerationsdeklarationen[)](enums.md#enum-declarations)definiert.</span><span class="sxs-lookup"><span data-stu-id="99f15-259">Enumeration types are defined through enumeration declarations ([Enum declarations](enums.md#enum-declarations)).</span></span>

### <a name="nullable-types"></a><span data-ttu-id="99f15-260">Auf NULL festlegbare Typen</span><span class="sxs-lookup"><span data-stu-id="99f15-260">Nullable types</span></span>

<span data-ttu-id="99f15-261">Ein Typ, der NULL-Werte zulässt, kann alle Werte seines ***zugrunde liegenden Typs*** und einen zusätzlichen NULL-Wert darstellen.</span><span class="sxs-lookup"><span data-stu-id="99f15-261">A nullable type can represent all values of its ***underlying type*** plus an additional null value.</span></span> <span data-ttu-id="99f15-262">Ein Typ, der NULL-Werte zulässt, wird `T?`geschrieben, wobei `T` der zugrunde liegende Typ ist.</span><span class="sxs-lookup"><span data-stu-id="99f15-262">A nullable type is written `T?`, where `T` is the underlying type.</span></span> <span data-ttu-id="99f15-263">Diese Syntax ist eine Kurzform für `System.Nullable<T>`, und die beiden Formen können austauschbar verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="99f15-263">This syntax is shorthand for `System.Nullable<T>`, and the two forms can be used interchangeably.</span></span>

<span data-ttu-id="99f15-264">Ein ***Werttyp*** , der nicht auf NULL festgelegt werden kann, ist umgekehrt ein beliebiger Werttyp als `System.Nullable<T>` und seine Kurzform `T?` (für alle `T`) sowie alle Typparameter, die auf einen Werttyp beschränkt sind, der keine NULL-Werte zulässt (d. h. alle Typparameter mit einer `struct`-Einschränkung).</span><span class="sxs-lookup"><span data-stu-id="99f15-264">A ***non-nullable value type*** conversely is any value type other than `System.Nullable<T>` and its shorthand `T?` (for any `T`), plus any type parameter that is constrained to be a non-nullable value type (that is, any type parameter with a `struct` constraint).</span></span> <span data-ttu-id="99f15-265">Der `System.Nullable<T>` Typ gibt die Werttyp Einschränkung für `T` ([Typparameter Einschränkungen](classes.md#type-parameter-constraints)) an. Dies bedeutet, dass der zugrunde liegende Typ eines Typs, der NULL-Werte zulässt, jeder Werttyp sein kann, der keine NULL-Werte zulässt.</span><span class="sxs-lookup"><span data-stu-id="99f15-265">The `System.Nullable<T>` type specifies the value type constraint for `T` ([Type parameter constraints](classes.md#type-parameter-constraints)), which means that the underlying type of a nullable type can be any non-nullable value type.</span></span> <span data-ttu-id="99f15-266">Der zugrunde liegende Typ eines Typs, der NULL-Werte zulässt, kann kein Typ oder Verweistyp sein, der NULL-Werte zulässt.</span><span class="sxs-lookup"><span data-stu-id="99f15-266">The underlying type of a nullable type cannot be a nullable type or a reference type.</span></span> <span data-ttu-id="99f15-267">`int??` und `string?` sind z. b. ungültige Typen.</span><span class="sxs-lookup"><span data-stu-id="99f15-267">For example, `int??` and `string?` are invalid types.</span></span>

<span data-ttu-id="99f15-268">Eine Instanz eines Typs, der NULL-Werte zulässt `T?` hat zwei öffentliche schreibgeschützte Eigenschaften:</span><span class="sxs-lookup"><span data-stu-id="99f15-268">An instance of a nullable type `T?` has two public read-only properties:</span></span>

*  <span data-ttu-id="99f15-269">Eine `HasValue`-Eigenschaft des Typs `bool`</span><span class="sxs-lookup"><span data-stu-id="99f15-269">A `HasValue` property of type `bool`</span></span>
*  <span data-ttu-id="99f15-270">Eine `Value`-Eigenschaft des Typs `T`</span><span class="sxs-lookup"><span data-stu-id="99f15-270">A `Value` property of type `T`</span></span>

<span data-ttu-id="99f15-271">Eine-Instanz, für die `HasValue` true ist, wird als ungleich NULL bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="99f15-271">An instance for which `HasValue` is true is said to be non-null.</span></span> <span data-ttu-id="99f15-272">Eine Instanz, die nicht NULL ist, enthält einen bekannten Wert, und `Value` gibt diesen Wert zurück.</span><span class="sxs-lookup"><span data-stu-id="99f15-272">A non-null instance contains a known value and `Value` returns that value.</span></span>

<span data-ttu-id="99f15-273">Eine-Instanz, für die `HasValue` false ist, wird als NULL bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="99f15-273">An instance for which `HasValue` is false is said to be null.</span></span> <span data-ttu-id="99f15-274">Eine NULL-Instanz hat einen nicht definierten Wert.</span><span class="sxs-lookup"><span data-stu-id="99f15-274">A null instance has an undefined value.</span></span> <span data-ttu-id="99f15-275">Der Versuch, den `Value` einer NULL-Instanz zu lesen, bewirkt, dass eine `System.InvalidOperationException` ausgelöst wird.</span><span class="sxs-lookup"><span data-stu-id="99f15-275">Attempting to read the `Value` of a null instance causes a `System.InvalidOperationException` to be thrown.</span></span> <span data-ttu-id="99f15-276">Der Prozess des Zugriffs auf die `Value`-Eigenschaft einer Instanz, die NULL-Werte zulässt, wird als ***zum Entpacken***bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="99f15-276">The process of accessing the `Value` property of a nullable instance is referred to as ***unwrapping***.</span></span>

<span data-ttu-id="99f15-277">Zusätzlich zum Standardkonstruktor hat jeder Typ, der NULL-Werte zulässt, `T?` einen öffentlichen Konstruktor, der ein einzelnes Argument vom Typ "`T`" annimmt.</span><span class="sxs-lookup"><span data-stu-id="99f15-277">In addition to the default constructor, every nullable type `T?` has a public constructor that takes a single argument of type `T`.</span></span> <span data-ttu-id="99f15-278">Wenn ein Wert `x` vom Typ `T`ist, wird ein Konstruktoraufruf des Formulars ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="99f15-278">Given a value `x` of type `T`, a constructor invocation of the form</span></span>

```csharp
new T?(x)
```
<span data-ttu-id="99f15-279">erstellt eine Instanz von, die keine NULL-`T?` ist, für die die `Value` Eigenschaft `x`ist.</span><span class="sxs-lookup"><span data-stu-id="99f15-279">creates a non-null instance of `T?` for which the `Value` property is `x`.</span></span> <span data-ttu-id="99f15-280">Das Erstellen einer nicht-NULL-Instanz eines Typs, der NULL-Werte zulässt, wird als ***Wrapping***bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="99f15-280">The process of creating a non-null instance of a nullable type for a given value is referred to as ***wrapping***.</span></span>

<span data-ttu-id="99f15-281">Implizite Konvertierungen sind vom `null` literalen für `T?` ([null-literalkonvertierungen](conversions.md#null-literal-conversions)) und von `T` bis `T?` ([implizite Konvertierungen](conversions.md#implicit-nullable-conversions), die NULL-Werte zulassen) verfügbar.</span><span class="sxs-lookup"><span data-stu-id="99f15-281">Implicit conversions are available from the `null` literal to `T?` ([Null literal conversions](conversions.md#null-literal-conversions)) and from `T` to `T?` ([Implicit nullable conversions](conversions.md#implicit-nullable-conversions)).</span></span>

## <a name="reference-types"></a><span data-ttu-id="99f15-282">Verweistypen</span><span class="sxs-lookup"><span data-stu-id="99f15-282">Reference types</span></span>

<span data-ttu-id="99f15-283">Bei einem Verweistyp handelt es sich um einen Klassentyp, einen Schnittstellentyp, einen Arraytyp oder einen Delegattyp.</span><span class="sxs-lookup"><span data-stu-id="99f15-283">A reference type is a class type, an interface type, an array type, or a delegate type.</span></span>

```antlr
reference_type
    : class_type
    | interface_type
    | array_type
    | delegate_type
    ;

class_type
    : type_name
    | 'object'
    | 'dynamic'
    | 'string'
    ;

interface_type
    : type_name
    ;

array_type
    : non_array_type rank_specifier+
    ;

non_array_type
    : type
    ;

rank_specifier
    : '[' dim_separator* ']'
    ;

dim_separator
    : ','
    ;

delegate_type
    : type_name
    ;
```

<span data-ttu-id="99f15-284">Ein Verweistyp Wert ist ein Verweis auf eine ***Instanz*** des Typs, wobei es sich um einen Verweis handelt, der als ***Objekt***bezeichnet wird.</span><span class="sxs-lookup"><span data-stu-id="99f15-284">A reference type value is a reference to an ***instance*** of the type, the latter known as an ***object***.</span></span> <span data-ttu-id="99f15-285">Der spezielle Wert `null` ist mit allen Verweis Typen kompatibel und gibt an, dass keine Instanz vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="99f15-285">The special value `null` is compatible with all reference types and indicates the absence of an instance.</span></span>

### <a name="class-types"></a><span data-ttu-id="99f15-286">Klassentypen</span><span class="sxs-lookup"><span data-stu-id="99f15-286">Class types</span></span>

<span data-ttu-id="99f15-287">Ein Klassentyp definiert eine Datenstruktur, die Datenmember (Konstanten und Felder), Funktionsmember (Methoden, Eigenschaften, Ereignisse, Indexer, Operatoren, Instanzkonstruktoren, destrukturatoren und statische Konstruktoren) und die in der Struktur enthaltenen Typen enthält.</span><span class="sxs-lookup"><span data-stu-id="99f15-287">A class type defines a data structure that contains data members (constants and fields), function members (methods, properties, events, indexers, operators, instance constructors, destructors and static constructors), and nested types.</span></span> <span data-ttu-id="99f15-288">Klassentypen unterstützen Vererbung, einen Mechanismus, bei dem abgeleitete Klassen die Basisklassen erweitern und spezialisieren können.</span><span class="sxs-lookup"><span data-stu-id="99f15-288">Class types support inheritance, a mechanism whereby derived classes can extend and specialize base classes.</span></span> <span data-ttu-id="99f15-289">Instanzen von Klassentypen werden mithilfe von *object_creation_expression*s erstellt ([Objekt Erstellungs Ausdrücke](expressions.md#object-creation-expressions)).</span><span class="sxs-lookup"><span data-stu-id="99f15-289">Instances of class types are created using *object_creation_expression*s ([Object creation expressions](expressions.md#object-creation-expressions)).</span></span>

<span data-ttu-id="99f15-290">Klassentypen werden in [Klassen](classes.md)beschrieben.</span><span class="sxs-lookup"><span data-stu-id="99f15-290">Class types are described in [Classes](classes.md).</span></span>

<span data-ttu-id="99f15-291">Bestimmte vordefinierte Klassentypen haben in der C# Sprache eine besondere Bedeutung, wie in der folgenden Tabelle beschrieben.</span><span class="sxs-lookup"><span data-stu-id="99f15-291">Certain predefined class types have special meaning in the C# language, as described in the table below.</span></span>


| <span data-ttu-id="99f15-292">__Klassentyp__</span><span class="sxs-lookup"><span data-stu-id="99f15-292">__Class type__</span></span>     | <span data-ttu-id="99f15-293">__Beschreibung__</span><span class="sxs-lookup"><span data-stu-id="99f15-293">__Description__</span></span>                                         |
|--------------------|---------------------------------------------------------|
| `System.Object`    | <span data-ttu-id="99f15-294">Die ultimative Basisklasse aller anderen Typen.</span><span class="sxs-lookup"><span data-stu-id="99f15-294">The ultimate base class of all other types.</span></span> <span data-ttu-id="99f15-295">Siehe [Objekttyp](types.md#the-object-type).</span><span class="sxs-lookup"><span data-stu-id="99f15-295">See [The object type](types.md#the-object-type).</span></span> | 
| `System.String`    | <span data-ttu-id="99f15-296">Der Zeichen Folgentyp C# der Sprache.</span><span class="sxs-lookup"><span data-stu-id="99f15-296">The string type of the C# language.</span></span> <span data-ttu-id="99f15-297">Siehe [den String-Typ](types.md#the-string-type).</span><span class="sxs-lookup"><span data-stu-id="99f15-297">See [The string type](types.md#the-string-type).</span></span>         |
| `System.ValueType` | <span data-ttu-id="99f15-298">Die Basisklasse aller Werttypen.</span><span class="sxs-lookup"><span data-stu-id="99f15-298">The base class of all value types.</span></span> <span data-ttu-id="99f15-299">Siehe [den Typ System. ValueType](types.md#the-systemvaluetype-type).</span><span class="sxs-lookup"><span data-stu-id="99f15-299">See [The System.ValueType type](types.md#the-systemvaluetype-type).</span></span>          |
| `System.Enum`      | <span data-ttu-id="99f15-300">Die Basisklasse aller Enumerationstypen.</span><span class="sxs-lookup"><span data-stu-id="99f15-300">The base class of all enum types.</span></span> <span data-ttu-id="99f15-301">Siehe [-](enums.md)Auffinden.</span><span class="sxs-lookup"><span data-stu-id="99f15-301">See [Enums](enums.md).</span></span>              |
| `System.Array`     | <span data-ttu-id="99f15-302">Die Basisklasse aller Array Typen.</span><span class="sxs-lookup"><span data-stu-id="99f15-302">The base class of all array types.</span></span> <span data-ttu-id="99f15-303">Siehe [Arrays](arrays.md).</span><span class="sxs-lookup"><span data-stu-id="99f15-303">See [Arrays](arrays.md).</span></span>             |
| `System.Delegate`  | <span data-ttu-id="99f15-304">Die Basisklasse aller Delegattypen.</span><span class="sxs-lookup"><span data-stu-id="99f15-304">The base class of all delegate types.</span></span> <span data-ttu-id="99f15-305">Siehe [Delegaten](delegates.md).</span><span class="sxs-lookup"><span data-stu-id="99f15-305">See [Delegates](delegates.md).</span></span>          |
| `System.Exception` | <span data-ttu-id="99f15-306">Die Basisklasse aller Ausnahme Typen.</span><span class="sxs-lookup"><span data-stu-id="99f15-306">The base class of all exception types.</span></span> <span data-ttu-id="99f15-307">Siehe [Ausnahmen](exceptions.md).</span><span class="sxs-lookup"><span data-stu-id="99f15-307">See [Exceptions](exceptions.md).</span></span>         |

### <a name="the-object-type"></a><span data-ttu-id="99f15-308">Der Objekttyp</span><span class="sxs-lookup"><span data-stu-id="99f15-308">The object type</span></span>

<span data-ttu-id="99f15-309">Der `object`-Klassentyp ist die ultimative Basisklasse aller anderen Typen.</span><span class="sxs-lookup"><span data-stu-id="99f15-309">The `object` class type is the ultimate base class of all other types.</span></span> <span data-ttu-id="99f15-310">Jeder Typ C# direkt oder indirekt wird vom `object`-Klassentyp abgeleitet.</span><span class="sxs-lookup"><span data-stu-id="99f15-310">Every type in C# directly or indirectly derives from the `object` class type.</span></span>

<span data-ttu-id="99f15-311">Das Schlüsselwort `object` ist einfach ein Alias für die vordefinierte Klasse `System.Object`.</span><span class="sxs-lookup"><span data-stu-id="99f15-311">The keyword `object` is simply an alias for the predefined class `System.Object`.</span></span>

### <a name="the-dynamic-type"></a><span data-ttu-id="99f15-312">Der dynamische Typ</span><span class="sxs-lookup"><span data-stu-id="99f15-312">The dynamic type</span></span>

<span data-ttu-id="99f15-313">Der `dynamic` Typ kann, wie `object`, auf jedes beliebige Objekt verweisen.</span><span class="sxs-lookup"><span data-stu-id="99f15-313">The `dynamic` type, like `object`, can reference any object.</span></span> <span data-ttu-id="99f15-314">Wenn Operatoren auf Ausdrücke vom Typ `dynamic`angewendet werden, wird ihre Auflösung verzögert, bis das Programm ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="99f15-314">When operators are applied to expressions of type `dynamic`, their resolution is deferred until the program is run.</span></span> <span data-ttu-id="99f15-315">Wenn der Operator daher nicht auf das Objekt angewendet werden kann, auf das verwiesen wird, wird während der Kompilierung kein Fehler angegeben.</span><span class="sxs-lookup"><span data-stu-id="99f15-315">Thus, if the operator cannot legally be applied to the referenced object, no error is given during compilation.</span></span> <span data-ttu-id="99f15-316">Stattdessen wird eine Ausnahme ausgelöst, wenn die Auflösung des Operators zur Laufzeit fehlschlägt.</span><span class="sxs-lookup"><span data-stu-id="99f15-316">Instead an exception will be thrown when resolution of the operator fails at run-time.</span></span>

<span data-ttu-id="99f15-317">Der Zweck besteht darin, dynamische Bindungen zuzulassen, die im Detail unter [dynamische Bindung](expressions.md#dynamic-binding)beschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="99f15-317">Its purpose is to allow dynamic binding, which is described in detail in [Dynamic binding](expressions.md#dynamic-binding).</span></span>

<span data-ttu-id="99f15-318">`dynamic` gilt als identisch mit `object`, außer in den folgenden Punkten:</span><span class="sxs-lookup"><span data-stu-id="99f15-318">`dynamic` is considered identical to `object` except in the following respects:</span></span>

*  <span data-ttu-id="99f15-319">Vorgänge für Ausdrücke vom Typ `dynamic` können dynamisch gebunden werden ([dynamische Bindung](expressions.md#dynamic-binding)).</span><span class="sxs-lookup"><span data-stu-id="99f15-319">Operations on expressions of type `dynamic` can be dynamically bound ([Dynamic binding](expressions.md#dynamic-binding)).</span></span>
*  <span data-ttu-id="99f15-320">Beim Typrückschluss ([Typrückschluss](expressions.md#type-inference)) wird die `dynamic` über `object` bevorzugt, wenn beide Kandidaten sind.</span><span class="sxs-lookup"><span data-stu-id="99f15-320">Type inference ([Type inference](expressions.md#type-inference)) will prefer `dynamic` over `object` if both are candidates.</span></span>

<span data-ttu-id="99f15-321">Aufgrund dieser Äquivalenz enthält Folgendes:</span><span class="sxs-lookup"><span data-stu-id="99f15-321">Because of this equivalence, the following holds:</span></span>

*  <span data-ttu-id="99f15-322">Es gibt eine implizite Identitäts Konvertierung zwischen `object` und `dynamic`und zwischen konstruierten Typen, die beim Ersetzen von `dynamic` durch `object`</span><span class="sxs-lookup"><span data-stu-id="99f15-322">There is an implicit identity conversion between `object` and `dynamic`, and between constructed types that are the same when replacing `dynamic` with `object`</span></span>
*  <span data-ttu-id="99f15-323">Implizite und explizite Konvertierungen in und aus `object` gelten auch für und von `dynamic`.</span><span class="sxs-lookup"><span data-stu-id="99f15-323">Implicit and explicit conversions to and from `object` also apply to and from `dynamic`.</span></span>
*  <span data-ttu-id="99f15-324">Methoden Signaturen, die beim Ersetzen von `dynamic` durch `object` identisch sind, gelten als dieselbe Signatur.</span><span class="sxs-lookup"><span data-stu-id="99f15-324">Method signatures that are the same when replacing `dynamic` with `object` are considered the same signature</span></span>
*  <span data-ttu-id="99f15-325">Der Typ `dynamic` kann zur Laufzeit nicht von `object` unterschieden werden.</span><span class="sxs-lookup"><span data-stu-id="99f15-325">The type `dynamic` is indistinguishable from `object` at run-time.</span></span>
*  <span data-ttu-id="99f15-326">Ein Ausdruck des Typs `dynamic` wird als ***dynamischer Ausdruck***bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="99f15-326">An expression of the type `dynamic` is referred to as a ***dynamic expression***.</span></span>

### <a name="the-string-type"></a><span data-ttu-id="99f15-327">Der Zeichenfolgentyp</span><span class="sxs-lookup"><span data-stu-id="99f15-327">The string type</span></span>

<span data-ttu-id="99f15-328">Der `string` Typ ist ein versiegelter Klassentyp, der direkt von `object`erbt.</span><span class="sxs-lookup"><span data-stu-id="99f15-328">The `string` type is a sealed class type that inherits directly from `object`.</span></span> <span data-ttu-id="99f15-329">Instanzen der `string`-Klasse stellen Unicode-Zeichen folgen dar.</span><span class="sxs-lookup"><span data-stu-id="99f15-329">Instances of the `string` class represent Unicode character strings.</span></span>

<span data-ttu-id="99f15-330">Werte des `string` Typs können als Zeichen folgen Literale ([Zeichenfolgenliterale](lexical-structure.md#string-literals)) geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="99f15-330">Values of the `string` type can be written as string literals ([String literals](lexical-structure.md#string-literals)).</span></span>

<span data-ttu-id="99f15-331">Das Schlüsselwort `string` ist einfach ein Alias für die vordefinierte Klasse `System.String`.</span><span class="sxs-lookup"><span data-stu-id="99f15-331">The keyword `string` is simply an alias for the predefined class `System.String`.</span></span>

### <a name="interface-types"></a><span data-ttu-id="99f15-332">Schnittstellentypen</span><span class="sxs-lookup"><span data-stu-id="99f15-332">Interface types</span></span>

<span data-ttu-id="99f15-333">Eine Schnittstelle definiert einen Vertrag.</span><span class="sxs-lookup"><span data-stu-id="99f15-333">An interface defines a contract.</span></span> <span data-ttu-id="99f15-334">Eine Klasse oder Struktur, die eine Schnittstelle implementiert, muss ihren Vertrag einhalten.</span><span class="sxs-lookup"><span data-stu-id="99f15-334">A class or struct that implements an interface must adhere to its contract.</span></span> <span data-ttu-id="99f15-335">Eine Schnittstelle kann von mehreren Basis Schnittstellen erben, und eine Klasse oder Struktur kann mehrere Schnittstellen implementieren.</span><span class="sxs-lookup"><span data-stu-id="99f15-335">An interface may inherit from multiple base interfaces, and a class or struct may implement multiple interfaces.</span></span>

<span data-ttu-id="99f15-336">Schnittstellentypen werden unter [Schnittstellen](interfaces.md)beschrieben.</span><span class="sxs-lookup"><span data-stu-id="99f15-336">Interface types are described in [Interfaces](interfaces.md).</span></span>

### <a name="array-types"></a><span data-ttu-id="99f15-337">Arraytypen</span><span class="sxs-lookup"><span data-stu-id="99f15-337">Array types</span></span>

<span data-ttu-id="99f15-338">Ein Array ist eine Datenstruktur, die NULL oder mehr Variablen enthält, auf die über berechnete Indizes zugegriffen wird.</span><span class="sxs-lookup"><span data-stu-id="99f15-338">An array is a data structure that contains zero or more variables which are accessed through computed indices.</span></span> <span data-ttu-id="99f15-339">Die Variablen, die in einem Array enthalten sind, auch als Elemente des Arrays bezeichnet, sind vom selben Typ, und dieser Typ wird als Elementtyp des Arrays bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="99f15-339">The variables contained in an array, also called the elements of the array, are all of the same type, and this type is called the element type of the array.</span></span>

<span data-ttu-id="99f15-340">Array Typen werden in [Arrays](arrays.md)beschrieben.</span><span class="sxs-lookup"><span data-stu-id="99f15-340">Array types are described in [Arrays](arrays.md).</span></span>

### <a name="delegate-types"></a><span data-ttu-id="99f15-341">Delegattypen</span><span class="sxs-lookup"><span data-stu-id="99f15-341">Delegate types</span></span>

<span data-ttu-id="99f15-342">Bei einem Delegaten handelt es sich um eine Datenstruktur, die auf eine oder mehrere Methoden verweist.</span><span class="sxs-lookup"><span data-stu-id="99f15-342">A delegate is a data structure that refers to one or more methods.</span></span> <span data-ttu-id="99f15-343">Bei Instanzmethoden bezieht sie sich auch auf ihre entsprechenden Objektinstanzen.</span><span class="sxs-lookup"><span data-stu-id="99f15-343">For instance methods, it also refers to their corresponding object instances.</span></span>

<span data-ttu-id="99f15-344">Das nächstliegende Äquivalent eines Delegaten in C C++ oder ist ein Funktionszeiger, während ein Funktionszeiger nur auf statische Funktionen verweisen kann, kann ein Delegat sowohl auf statische Methoden als auch auf Instanzmethoden verweisen.</span><span class="sxs-lookup"><span data-stu-id="99f15-344">The closest equivalent of a delegate in C or C++ is a function pointer, but whereas a function pointer can only reference static functions, a delegate can reference both static and instance methods.</span></span> <span data-ttu-id="99f15-345">Im letzteren Fall speichert der Delegat nicht nur einen Verweis auf den Einstiegspunkt der Methode, sondern auch einen Verweis auf die Objektinstanz, für die die Methode aufgerufen werden soll.</span><span class="sxs-lookup"><span data-stu-id="99f15-345">In the latter case, the delegate stores not only a reference to the method's entry point, but also a reference to the object instance on which to invoke the method.</span></span>

<span data-ttu-id="99f15-346">Delegattypen [werden in](delegates.md)Delegaten beschrieben.</span><span class="sxs-lookup"><span data-stu-id="99f15-346">Delegate types are described in [Delegates](delegates.md).</span></span>

## <a name="boxing-and-unboxing"></a><span data-ttu-id="99f15-347">Boxing und Unboxing</span><span class="sxs-lookup"><span data-stu-id="99f15-347">Boxing and unboxing</span></span>

<span data-ttu-id="99f15-348">Das Konzept von Boxing und Unboxing ist für C#das Typsystem von zentraler Bedeutung.</span><span class="sxs-lookup"><span data-stu-id="99f15-348">The concept of boxing and unboxing is central to C#'s type system.</span></span> <span data-ttu-id="99f15-349">Sie bietet eine Brücke zwischen *value_type*s und *reference_type*s, indem es ermöglicht wird, dass jeder Wert eines *value_type* in und aus dem Typ `object`konvertiert werden kann.</span><span class="sxs-lookup"><span data-stu-id="99f15-349">It provides a bridge between *value_type*s and *reference_type*s by permitting any value of a *value_type* to be converted to and from type `object`.</span></span> <span data-ttu-id="99f15-350">Boxing und Unboxing ermöglichen eine einheitliche Ansicht des Typsystems, wobei ein Wert eines beliebigen Typs letztendlich als Objekt behandelt werden kann.</span><span class="sxs-lookup"><span data-stu-id="99f15-350">Boxing and unboxing enables a unified view of the type system wherein a value of any type can ultimately be treated as an object.</span></span>

### <a name="boxing-conversions"></a><span data-ttu-id="99f15-351">Boxing-Konvertierungen</span><span class="sxs-lookup"><span data-stu-id="99f15-351">Boxing conversions</span></span>

<span data-ttu-id="99f15-352">Eine Boxing-Konvertierung ermöglicht eine implizite Konvertierung einer *value_type* in eine *reference_type*.</span><span class="sxs-lookup"><span data-stu-id="99f15-352">A boxing conversion permits a *value_type* to be implicitly converted to a *reference_type*.</span></span> <span data-ttu-id="99f15-353">Die folgenden boxkonvertierungen sind vorhanden:</span><span class="sxs-lookup"><span data-stu-id="99f15-353">The following boxing conversions exist:</span></span>

*  <span data-ttu-id="99f15-354">Von allen *value_type* bis zum Typ `object`.</span><span class="sxs-lookup"><span data-stu-id="99f15-354">From any *value_type* to the type `object`.</span></span>
*  <span data-ttu-id="99f15-355">Von allen *value_type* bis zum Typ `System.ValueType`.</span><span class="sxs-lookup"><span data-stu-id="99f15-355">From any *value_type* to the type `System.ValueType`.</span></span>
*  <span data-ttu-id="99f15-356">Von allen *non_nullable_value_type* bis *INTERFACE_TYPE* , die vom *value_type*implementiert werden.</span><span class="sxs-lookup"><span data-stu-id="99f15-356">From any *non_nullable_value_type* to any *interface_type* implemented by the *value_type*.</span></span>
*  <span data-ttu-id="99f15-357">Von allen *nullable_type* bis *INTERFACE_TYPE* , die vom zugrunde liegenden Typ des *nullable_type*implementiert werden.</span><span class="sxs-lookup"><span data-stu-id="99f15-357">From any *nullable_type* to any *interface_type* implemented by the underlying type of the *nullable_type*.</span></span>
*  <span data-ttu-id="99f15-358">Von allen *enum_type* bis zum Typ `System.Enum`.</span><span class="sxs-lookup"><span data-stu-id="99f15-358">From any *enum_type* to the type `System.Enum`.</span></span>
*  <span data-ttu-id="99f15-359">Von allen *nullable_type* mit einem zugrunde liegenden *enum_type* bis zum Typ `System.Enum`.</span><span class="sxs-lookup"><span data-stu-id="99f15-359">From any *nullable_type* with an underlying *enum_type* to the type `System.Enum`.</span></span>
*  <span data-ttu-id="99f15-360">Beachten Sie, dass eine implizite Konvertierung von einem Typparameter als Boxing-Konvertierung ausgeführt wird, wenn Sie zur Laufzeit von einem Werttyp in einen Verweistyp konvertiert wird ([implizite Konvertierungen mit Typparametern](conversions.md#implicit-conversions-involving-type-parameters)).</span><span class="sxs-lookup"><span data-stu-id="99f15-360">Note that an implicit conversion from a type parameter will be executed as a boxing conversion if at run-time it ends up converting from a value type to a reference type ([Implicit conversions involving type parameters](conversions.md#implicit-conversions-involving-type-parameters)).</span></span>

<span data-ttu-id="99f15-361">Das Boxing eines Werts einer *non_nullable_value_type* besteht aus der Zuordnung einer Objektinstanz und dem Kopieren des *non_nullable_value_type* Werts in diese Instanz.</span><span class="sxs-lookup"><span data-stu-id="99f15-361">Boxing a value of a *non_nullable_value_type* consists of allocating an object instance and copying the *non_nullable_value_type* value into that instance.</span></span>

<span data-ttu-id="99f15-362">Das Boxing eines Werts einer *nullable_type* erzeugt einen NULL-Verweis, wenn es sich um den `null`-Wert (`HasValue` `false`) oder das Entpacken und Boxing des zugrunde liegenden Werts andernfalls handelt.</span><span class="sxs-lookup"><span data-stu-id="99f15-362">Boxing a value of a *nullable_type* produces a null reference if it is the `null` value (`HasValue` is `false`), or the result of unwrapping and boxing the underlying value otherwise.</span></span>

<span data-ttu-id="99f15-363">Der eigentliche Prozess des Boxens eines Werts eines *non_nullable_value_type* wird am besten erläutert, indem das vorhanden sein einer generischen ***Boxing-Klasse***dargestellt wird, die sich so verhält, als wäre sie wie folgt deklariert:</span><span class="sxs-lookup"><span data-stu-id="99f15-363">The actual process of boxing a value of a *non_nullable_value_type* is best explained by imagining the existence of a generic ***boxing class***, which behaves as if it were declared as follows:</span></span>

```csharp
sealed class Box<T>: System.ValueType
{
    T value;

    public Box(T t) {
        value = t;
    }
}
```

<span data-ttu-id="99f15-364">Boxing eines Werts `v` vom Typ "`T`" besteht jetzt aus der Ausführung des Ausdrucks `new Box<T>(v)`und der Rückgabe der resultierenden Instanz als Wert des Typs `object`.</span><span class="sxs-lookup"><span data-stu-id="99f15-364">Boxing of a value `v` of type `T` now consists of executing the expression `new Box<T>(v)`, and returning the resulting instance as a value of type `object`.</span></span> <span data-ttu-id="99f15-365">Folglich werden die Anweisungen</span><span class="sxs-lookup"><span data-stu-id="99f15-365">Thus, the statements</span></span>
```csharp
int i = 123;
object box = i;
```
<span data-ttu-id="99f15-366">konzeptionell entsprechen</span><span class="sxs-lookup"><span data-stu-id="99f15-366">conceptually correspond to</span></span>
```csharp
int i = 123;
object box = new Box<int>(i);
```

<span data-ttu-id="99f15-367">Eine Boxing-Klasse wie `Box<T>` oben ist nicht vorhanden, und der dynamische Typ eines geschachtelten Werts ist nicht tatsächlich ein Klassentyp.</span><span class="sxs-lookup"><span data-stu-id="99f15-367">A boxing class like `Box<T>` above doesn't actually exist and the dynamic type of a boxed value isn't actually a class type.</span></span> <span data-ttu-id="99f15-368">Stattdessen kann ein geachtelter Wert vom Typ `T` den dynamischen Typ `T`haben, und eine dynamische Typüberprüfung mit dem `is`-Operator kann einfach auf den Typ `T`verweisen.</span><span class="sxs-lookup"><span data-stu-id="99f15-368">Instead, a boxed value of type `T` has the dynamic type `T`, and a dynamic type check using the `is` operator can simply reference type `T`.</span></span> <span data-ttu-id="99f15-369">Ein auf ein Objekt angewendeter</span><span class="sxs-lookup"><span data-stu-id="99f15-369">For example,</span></span>
```csharp
int i = 123;
object box = i;
if (box is int) {
    Console.Write("Box contains an int");
}
```
<span data-ttu-id="99f15-370">die Zeichenfolge "`Box contains an int`" wird in der Konsole ausgegeben.</span><span class="sxs-lookup"><span data-stu-id="99f15-370">will output the string "`Box contains an int`" on the console.</span></span>

<span data-ttu-id="99f15-371">Eine Boxing-Konvertierung impliziert das Erstellen einer Kopie des Werts, der gekapselt wird.</span><span class="sxs-lookup"><span data-stu-id="99f15-371">A boxing conversion implies making a copy of the value being boxed.</span></span> <span data-ttu-id="99f15-372">Dies unterscheidet sich von der Konvertierung eines *reference_type* in den Typ `object`, bei dem der Wert weiterhin auf dieselbe Instanz verweist und einfach als weniger abgeleiteter Typ `object`angesehen wird.</span><span class="sxs-lookup"><span data-stu-id="99f15-372">This is different from a conversion of a *reference_type* to type `object`, in which the value continues to reference the same instance and simply is regarded as the less derived type `object`.</span></span> <span data-ttu-id="99f15-373">Beispielsweise mit der Deklaration</span><span class="sxs-lookup"><span data-stu-id="99f15-373">For example, given the declaration</span></span>
```csharp
struct Point
{
    public int x, y;

    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }
}
```
<span data-ttu-id="99f15-374">die folgenden Anweisungen</span><span class="sxs-lookup"><span data-stu-id="99f15-374">the following statements</span></span>
```csharp
Point p = new Point(10, 10);
object box = p;
p.x = 20;
Console.Write(((Point)box).x);
```
<span data-ttu-id="99f15-375">Gibt den Wert 10 in der Konsole aus, da der implizite Boxing-Vorgang, der bei der Zuweisung von `p` zu `box` auftritt, bewirkt, dass der Wert von `p` kopiert wird.</span><span class="sxs-lookup"><span data-stu-id="99f15-375">will output the value 10 on the console because the implicit boxing operation that occurs in the assignment of `p` to `box` causes the value of `p` to be copied.</span></span> <span data-ttu-id="99f15-376">Wenn `Point` stattdessen als `class` deklariert worden wäre, würde der Wert 20 ausgegeben werden, da `p` und `box` auf dieselbe Instanz verweisen würden.</span><span class="sxs-lookup"><span data-stu-id="99f15-376">Had `Point` been declared a `class` instead, the value 20 would be output because `p` and `box` would reference the same instance.</span></span>

### <a name="unboxing-conversions"></a><span data-ttu-id="99f15-377">Unboxing-Konvertierungen</span><span class="sxs-lookup"><span data-stu-id="99f15-377">Unboxing conversions</span></span>

<span data-ttu-id="99f15-378">Eine Unboxing-Konvertierung ermöglicht das explizite Konvertieren eines *reference_type* in eine *value_type*.</span><span class="sxs-lookup"><span data-stu-id="99f15-378">An unboxing conversion permits a *reference_type* to be explicitly converted to a *value_type*.</span></span> <span data-ttu-id="99f15-379">Die folgenden Unboxing-Konvertierungen sind vorhanden:</span><span class="sxs-lookup"><span data-stu-id="99f15-379">The following unboxing conversions exist:</span></span>

*  <span data-ttu-id="99f15-380">Vom Typ `object` bis *value_type*.</span><span class="sxs-lookup"><span data-stu-id="99f15-380">From the type `object` to any *value_type*.</span></span>
*  <span data-ttu-id="99f15-381">Vom Typ `System.ValueType` bis *value_type*.</span><span class="sxs-lookup"><span data-stu-id="99f15-381">From the type `System.ValueType` to any *value_type*.</span></span>
*  <span data-ttu-id="99f15-382">Von allen *INTERFACE_TYPE* bis zu *non_nullable_value_type* , die die *INTERFACE_TYPE*implementiert.</span><span class="sxs-lookup"><span data-stu-id="99f15-382">From any *interface_type* to any *non_nullable_value_type* that implements the *interface_type*.</span></span>
*  <span data-ttu-id="99f15-383">Von allen *INTERFACE_TYPE* zu beliebigen *nullable_type* , deren zugrunde liegender Typ den *INTERFACE_TYPE*implementiert.</span><span class="sxs-lookup"><span data-stu-id="99f15-383">From any *interface_type* to any *nullable_type* whose underlying type implements the *interface_type*.</span></span>
*  <span data-ttu-id="99f15-384">Vom Typ `System.Enum` bis *enum_type*.</span><span class="sxs-lookup"><span data-stu-id="99f15-384">From the type `System.Enum` to any *enum_type*.</span></span>
*  <span data-ttu-id="99f15-385">Vom Typ `System.Enum` bis *nullable_type* mit einem zugrunde liegenden *enum_type*.</span><span class="sxs-lookup"><span data-stu-id="99f15-385">From the type `System.Enum` to any *nullable_type* with an underlying *enum_type*.</span></span>
*  <span data-ttu-id="99f15-386">Beachten Sie, dass eine explizite Konvertierung in einen Typparameter als Unboxing-Konvertierung ausgeführt wird, wenn Sie zur Laufzeit von einem Verweistyp in einen Werttyp ([explizite dynamische Konvertierungen](conversions.md#explicit-dynamic-conversions)) konvertiert wird.</span><span class="sxs-lookup"><span data-stu-id="99f15-386">Note that an explicit conversion to a type parameter will be executed as an unboxing conversion if at run-time it ends up converting from a reference type to a value type ([Explicit dynamic conversions](conversions.md#explicit-dynamic-conversions)).</span></span>

<span data-ttu-id="99f15-387">Ein Unboxing-Vorgang für eine *non_nullable_value_type* besteht darin, zuerst zu überprüfen, ob die Objektinstanz ein geachtelter Wert der angegebenen *non_nullable_value_type*ist, und dann den Wert aus der-Instanz zu kopieren.</span><span class="sxs-lookup"><span data-stu-id="99f15-387">An unboxing operation to a *non_nullable_value_type* consists of first checking that the object instance is a boxed value of the given *non_nullable_value_type*, and then copying the value out of the instance.</span></span>

<span data-ttu-id="99f15-388">Beim Unboxing in eine *nullable_type* wird der NULL-Wert des *nullable_type* erzeugt, wenn der Quell Operand `null`ist, oder das umschließende Ergebnis des Unboxing der Objektinstanz in den zugrunde liegenden Typ des *nullable_type* andernfalls.</span><span class="sxs-lookup"><span data-stu-id="99f15-388">Unboxing to a *nullable_type* produces the null value of the *nullable_type* if the source operand is `null`, or the wrapped result of unboxing the object instance to the underlying type of the *nullable_type* otherwise.</span></span>

<span data-ttu-id="99f15-389">Bei der im vorherigen Abschnitt beschriebenen imaginären Boxingklasse wird eine Unboxing-Konvertierung eines Objekts `box` zu einem *value_type* `T` aus der Ausführung des Ausdrucks `((Box<T>)box).value`.</span><span class="sxs-lookup"><span data-stu-id="99f15-389">Referring to the imaginary boxing class described in the previous section, an unboxing conversion of an object `box` to a *value_type* `T` consists of executing the expression `((Box<T>)box).value`.</span></span> <span data-ttu-id="99f15-390">Folglich werden die Anweisungen</span><span class="sxs-lookup"><span data-stu-id="99f15-390">Thus, the statements</span></span>
```csharp
object box = 123;
int i = (int)box;
```
<span data-ttu-id="99f15-391">konzeptionell entsprechen</span><span class="sxs-lookup"><span data-stu-id="99f15-391">conceptually correspond to</span></span>
```csharp
object box = new Box<int>(123);
int i = ((Box<int>)box).value;
```

<span data-ttu-id="99f15-392">Damit eine Unboxing-Konvertierung in eine angegebene *non_nullable_value_type* zur Laufzeit erfolgreich ausgeführt werden kann, muss der Wert des Quell Operanden ein Verweis auf einen geachtelten Wert dieses *non_nullable_value_type*sein.</span><span class="sxs-lookup"><span data-stu-id="99f15-392">For an unboxing conversion to a given *non_nullable_value_type* to succeed at run-time, the value of the source operand must be a reference to a boxed value of that *non_nullable_value_type*.</span></span> <span data-ttu-id="99f15-393">Wenn der Quell Operand `null`ist, wird eine `System.NullReferenceException` ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="99f15-393">If the source operand is `null`, a `System.NullReferenceException` is thrown.</span></span> <span data-ttu-id="99f15-394">Wenn der Quell Operand ein Verweis auf ein inkompatibles Objekt ist, wird ein `System.InvalidCastException` ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="99f15-394">If the source operand is a reference to an incompatible object, a `System.InvalidCastException` is thrown.</span></span>

<span data-ttu-id="99f15-395">Damit eine Unboxing-Konvertierung in eine angegebene *nullable_type* zur Laufzeit erfolgreich ausgeführt werden kann, muss der Wert des Quell Operanden entweder `null` oder ein Verweis auf einen geachtelten Wert der zugrunde liegenden *non_nullable_value_type* der *nullable_type*sein.</span><span class="sxs-lookup"><span data-stu-id="99f15-395">For an unboxing conversion to a given *nullable_type* to succeed at run-time, the value of the source operand must be either `null` or a reference to a boxed value of the underlying *non_nullable_value_type* of the *nullable_type*.</span></span> <span data-ttu-id="99f15-396">Wenn der Quell Operand ein Verweis auf ein inkompatibles Objekt ist, wird ein `System.InvalidCastException` ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="99f15-396">If the source operand is a reference to an incompatible object, a `System.InvalidCastException` is thrown.</span></span>

## <a name="constructed-types"></a><span data-ttu-id="99f15-397">Konstruierte Typen</span><span class="sxs-lookup"><span data-stu-id="99f15-397">Constructed types</span></span>

<span data-ttu-id="99f15-398">Eine generische Typdeklaration bezeichnet allein einen ***ungebundenen generischen Typ*** , der als "Blueprint" verwendet wird, um viele verschiedene Typen mithilfe von ***Typargumenten***zu bilden.</span><span class="sxs-lookup"><span data-stu-id="99f15-398">A generic type declaration, by itself, denotes an ***unbound generic type*** that is used as a "blueprint" to form many different types, by way of applying ***type arguments***.</span></span> <span data-ttu-id="99f15-399">Die Typargumente werden in spitzen Klammern (`<` und `>`) direkt nach dem Namen des generischen Typs geschrieben.</span><span class="sxs-lookup"><span data-stu-id="99f15-399">The type arguments are written within angle brackets (`<` and `>`) immediately following the name of the generic type.</span></span> <span data-ttu-id="99f15-400">Ein Typ, der mindestens ein Typargument enthält, wird als ***konstruierter Typ***bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="99f15-400">A type that includes at least one type argument is called a ***constructed type***.</span></span> <span data-ttu-id="99f15-401">Ein konstruierter Typ kann an den meisten Stellen in der Sprache verwendet werden, in der ein Typname angezeigt werden kann.</span><span class="sxs-lookup"><span data-stu-id="99f15-401">A constructed type can be used in most places in the language in which a type name can appear.</span></span> <span data-ttu-id="99f15-402">Ein ungebundener generischer Typ kann nur innerhalb eines *typeof_expression* ([der typeof-Operator](expressions.md#the-typeof-operator)) verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="99f15-402">An unbound generic type can only be used within a *typeof_expression* ([The typeof operator](expressions.md#the-typeof-operator)).</span></span>

<span data-ttu-id="99f15-403">Konstruierte Typen können auch in Ausdrücken als einfache Namen ([einfache Namen](expressions.md#simple-names)) oder beim Zugriff auf einen Member ([Member Access](expressions.md#member-access)) verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="99f15-403">Constructed types can also be used in expressions as simple names ([Simple names](expressions.md#simple-names)) or when accessing a member ([Member access](expressions.md#member-access)).</span></span>

<span data-ttu-id="99f15-404">Wenn ein *namespace_or_type_name* ausgewertet wird, werden nur generische Typen mit der richtigen Anzahl von Typparametern berücksichtigt.</span><span class="sxs-lookup"><span data-stu-id="99f15-404">When a *namespace_or_type_name* is evaluated, only generic types with the correct number of type parameters are considered.</span></span> <span data-ttu-id="99f15-405">Daher ist es möglich, denselben Bezeichner zu verwenden, um unterschiedliche Typen zu identifizieren, sofern die Typen eine unterschiedliche Anzahl von Typparametern aufweisen.</span><span class="sxs-lookup"><span data-stu-id="99f15-405">Thus, it is possible to use the same identifier to identify different types, as long as the types have different numbers of type parameters.</span></span> <span data-ttu-id="99f15-406">Dies ist nützlich, wenn generische und nicht generische Klassen in demselben Programm gemischt werden:</span><span class="sxs-lookup"><span data-stu-id="99f15-406">This is useful when mixing generic and non-generic classes in the same program:</span></span>

```csharp
namespace Widgets
{
    class Queue {...}
    class Queue<TElement> {...}
}

namespace MyApplication
{
    using Widgets;

    class X
    {
        Queue q1;            // Non-generic Widgets.Queue
        Queue<int> q2;       // Generic Widgets.Queue
    }
}
```

<span data-ttu-id="99f15-407">Ein *TYPE_NAME* kann einen konstruierten Typ identifizieren, obwohl er keine Typparameter direkt angibt.</span><span class="sxs-lookup"><span data-stu-id="99f15-407">A *type_name* might identify a constructed type even though it doesn't specify type parameters directly.</span></span> <span data-ttu-id="99f15-408">Dies kann vorkommen, wenn ein Typ in einer generischen Klassen Deklaration geschachtelt ist und der Instanztyp der enthaltenden Deklaration implizit für die Namenssuche (geschachtelte[Typen in generischen Klassen](classes.md#nested-types-in-generic-classes)) verwendet wird:</span><span class="sxs-lookup"><span data-stu-id="99f15-408">This can occur where a type is nested within a generic class declaration, and the instance type of the containing declaration is implicitly used for name lookup ([Nested types in generic classes](classes.md#nested-types-in-generic-classes)):</span></span>

```csharp
class Outer<T>
{
    public class Inner {...}

    public Inner i;                // Type of i is Outer<T>.Inner
}
```

<span data-ttu-id="99f15-409">In unsicherem Code kann ein konstruierter Typ nicht als *unmanaged_type* ([Zeiger Typen](unsafe-code.md#pointer-types)) verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="99f15-409">In unsafe code, a constructed type cannot be used as an *unmanaged_type* ([Pointer types](unsafe-code.md#pointer-types)).</span></span>

### <a name="type-arguments"></a><span data-ttu-id="99f15-410">Typargumente</span><span class="sxs-lookup"><span data-stu-id="99f15-410">Type arguments</span></span>

<span data-ttu-id="99f15-411">Jedes Argument in einer Typargument Liste ist einfach ein *Typ*.</span><span class="sxs-lookup"><span data-stu-id="99f15-411">Each argument in a type argument list is simply a *type*.</span></span>

```antlr
type_argument_list
    : '<' type_arguments '>'
    ;

type_arguments
    : type_argument (',' type_argument)*
    ;

type_argument
    : type
    ;
```

<span data-ttu-id="99f15-412">In unsicherem Code ([unsicherer Code](unsafe-code.md)) ist ein *type_argument* möglicherweise kein Zeigertyp.</span><span class="sxs-lookup"><span data-stu-id="99f15-412">In unsafe code ([Unsafe code](unsafe-code.md)), a *type_argument* may not be a pointer type.</span></span> <span data-ttu-id="99f15-413">Jedes Typargument muss alle Einschränkungen für den entsprechenden Typparameter ([Typparameter Einschränkungen](classes.md#type-parameter-constraints)) erfüllen.</span><span class="sxs-lookup"><span data-stu-id="99f15-413">Each type argument must satisfy any constraints on the corresponding type parameter ([Type parameter constraints](classes.md#type-parameter-constraints)).</span></span>

### <a name="open-and-closed-types"></a><span data-ttu-id="99f15-414">Open-und Closed-Typen</span><span class="sxs-lookup"><span data-stu-id="99f15-414">Open and closed types</span></span>

<span data-ttu-id="99f15-415">Alle Typen können als ***offene*** oder ***geschlossene Typen***klassifiziert werden.</span><span class="sxs-lookup"><span data-stu-id="99f15-415">All types can be classified as either ***open types*** or ***closed types***.</span></span> <span data-ttu-id="99f15-416">Ein offener Typ ist ein Typ, der Typparameter umfasst.</span><span class="sxs-lookup"><span data-stu-id="99f15-416">An open type is a type that involves type parameters.</span></span> <span data-ttu-id="99f15-417">Genauer gesagt:</span><span class="sxs-lookup"><span data-stu-id="99f15-417">More specifically:</span></span>

*  <span data-ttu-id="99f15-418">Ein Typparameter definiert einen geöffneten Typ.</span><span class="sxs-lookup"><span data-stu-id="99f15-418">A type parameter defines an open type.</span></span>
*  <span data-ttu-id="99f15-419">Ein Arraytyp ist nur dann ein offener Typ, wenn sein Elementtyp ein offener Typ ist.</span><span class="sxs-lookup"><span data-stu-id="99f15-419">An array type is an open type if and only if its element type is an open type.</span></span>
*  <span data-ttu-id="99f15-420">Ein konstruierter Typ ist ein offener Typ, wenn es sich bei mindestens einem Typargument um einen geöffneten Typ handelt.</span><span class="sxs-lookup"><span data-stu-id="99f15-420">A constructed type is an open type if and only if one or more of its type arguments is an open type.</span></span> <span data-ttu-id="99f15-421">Ein konstruierter, von einem Typ erstellter Typ ist ein offener Typ, wenn es sich bei mindestens einem Typargument oder den Typargumenten der enthaltenden Typen um einen geöffneten Typ handelt.</span><span class="sxs-lookup"><span data-stu-id="99f15-421">A constructed nested type is an open type if and only if one or more of its type arguments or the type arguments of its containing type(s) is an open type.</span></span>

<span data-ttu-id="99f15-422">Ein geschlossener Typ ist ein Typ, bei dem es sich nicht um einen geöffneten Typ handelt.</span><span class="sxs-lookup"><span data-stu-id="99f15-422">A closed type is a type that is not an open type.</span></span>

<span data-ttu-id="99f15-423">Zur Laufzeit wird der gesamte Code in einer generischen Typdeklaration im Kontext eines geschlossenen konstruierten Typs ausgeführt, der durch Anwenden von Typargumenten auf die generische Deklaration erstellt wurde.</span><span class="sxs-lookup"><span data-stu-id="99f15-423">At run-time, all of the code within a generic type declaration is executed in the context of a closed constructed type that was created by applying type arguments to the generic declaration.</span></span> <span data-ttu-id="99f15-424">Jeder Typparameter innerhalb des generischen Typs ist an einen bestimmten Lauf Zeittyp gebunden.</span><span class="sxs-lookup"><span data-stu-id="99f15-424">Each type parameter within the generic type is bound to a particular run-time type.</span></span> <span data-ttu-id="99f15-425">Die Lauf Zeit Verarbeitung aller Anweisungen und Ausdrücke tritt immer bei geschlossenen Typen auf, und offene Typen werden nur während der Kompilierungszeit verarbeitet.</span><span class="sxs-lookup"><span data-stu-id="99f15-425">The run-time processing of all statements and expressions always occurs with closed types, and open types occur only during compile-time processing.</span></span>

<span data-ttu-id="99f15-426">Jeder geschlossene konstruierte Typ verfügt über einen eigenen Satz statischer Variablen, die nicht gemeinsam mit anderen geschlossenen konstruierten Typen verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="99f15-426">Each closed constructed type has its own set of static variables, which are not shared with any other closed constructed types.</span></span> <span data-ttu-id="99f15-427">Da ein offener Typ zur Laufzeit nicht vorhanden ist, sind keine statischen Variablen mit einem geöffneten Typ verknüpft.</span><span class="sxs-lookup"><span data-stu-id="99f15-427">Since an open type does not exist at run-time, there are no static variables associated with an open type.</span></span> <span data-ttu-id="99f15-428">Zwei geschlossene konstruierte Typen weisen denselben Typ auf, wenn Sie aus demselben ungebundenen generischen Typ erstellt werden und die entsprechenden Typargumente denselben Typ haben.</span><span class="sxs-lookup"><span data-stu-id="99f15-428">Two closed constructed types are the same type if they are constructed from the same unbound generic type, and their corresponding type arguments are the same type.</span></span>

### <a name="bound-and-unbound-types"></a><span data-ttu-id="99f15-429">Gebundene und ungebundene Typen</span><span class="sxs-lookup"><span data-stu-id="99f15-429">Bound and unbound types</span></span>

<span data-ttu-id="99f15-430">Der Begriff " ***ungebundener Typ*** " verweist auf einen nicht generischen Typ oder einen ungebundenen generischen Typ.</span><span class="sxs-lookup"><span data-stu-id="99f15-430">The term ***unbound type*** refers to a non-generic type or an unbound generic type.</span></span> <span data-ttu-id="99f15-431">Der Begriff ***gebundene Typ*** verweist auf einen nicht generischen Typ oder einen konstruierten Typ.</span><span class="sxs-lookup"><span data-stu-id="99f15-431">The term ***bound type*** refers to a non-generic type or a constructed type.</span></span>

<span data-ttu-id="99f15-432">Ein ungebundener Typ verweist auf die durch eine Typdeklaration deklarierte Entität.</span><span class="sxs-lookup"><span data-stu-id="99f15-432">An unbound type refers to the entity declared by a type declaration.</span></span> <span data-ttu-id="99f15-433">Ein ungebundener generischer Typ ist nicht selbst ein Typ und kann nicht als Typ einer Variablen, eines Arguments oder eines Rückgabewerts oder als Basistyp verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="99f15-433">An unbound generic type is not itself a type, and cannot be used as the type of a variable, argument or return value, or as a base type.</span></span> <span data-ttu-id="99f15-434">Das einzige Konstrukt, in dem auf einen ungebundenen generischen Typ verwiesen werden kann, ist der `typeof` Ausdruck ([der typeof-Operator](expressions.md#the-typeof-operator)).</span><span class="sxs-lookup"><span data-stu-id="99f15-434">The only construct in which an unbound generic type can be referenced is the `typeof` expression ([The typeof operator](expressions.md#the-typeof-operator)).</span></span>

### <a name="satisfying-constraints"></a><span data-ttu-id="99f15-435">Erfüllen von Einschränkungen</span><span class="sxs-lookup"><span data-stu-id="99f15-435">Satisfying constraints</span></span>

<span data-ttu-id="99f15-436">Wenn auf einen konstruierten Typ oder eine generische Methode verwiesen wird, werden die angegebenen Typargumente mit den Typparameter Einschränkungen überprüft, die für den generischen Typ oder die generische Methode deklariert sind ([Typparameter Einschränkungen](classes.md#type-parameter-constraints)).</span><span class="sxs-lookup"><span data-stu-id="99f15-436">Whenever a constructed type or generic method is referenced, the supplied type arguments are checked against the type parameter constraints declared on the generic type or method ([Type parameter constraints](classes.md#type-parameter-constraints)).</span></span> <span data-ttu-id="99f15-437">Für jede `where`-Klausel wird das Typargument `A`, das dem benannten Typparameter entspricht, wie folgt gegen jede Einschränkung überprüft:</span><span class="sxs-lookup"><span data-stu-id="99f15-437">For each `where` clause, the type argument `A` that corresponds to the named type parameter is checked against each constraint as follows:</span></span>

*  <span data-ttu-id="99f15-438">Wenn es sich bei der Einschränkung um einen Klassentyp, einen Schnittstellentyp oder einen Typparameter handelt, können `C` diese Einschränkung mit den bereitgestellten Typargumenten darstellen, die für Typparameter ersetzt werden, die in der Einschränkung angezeigt werden.</span><span class="sxs-lookup"><span data-stu-id="99f15-438">If the constraint is a class type, an interface type, or a type parameter, let `C` represent that constraint with the supplied type arguments substituted for any type parameters that appear in the constraint.</span></span> <span data-ttu-id="99f15-439">Um die Einschränkung zu erfüllen, muss der Typ `A` in den Typ konvertiert werden können, der von einem der folgenden Typen `C` kann:</span><span class="sxs-lookup"><span data-stu-id="99f15-439">To satisfy the constraint, it must be the case that type `A` is convertible to type `C` by one of the following:</span></span>
    * <span data-ttu-id="99f15-440">Eine Identitäts Konvertierung ([Identitäts Konvertierung](conversions.md#identity-conversion))</span><span class="sxs-lookup"><span data-stu-id="99f15-440">An identity conversion ([Identity conversion](conversions.md#identity-conversion))</span></span>
    * <span data-ttu-id="99f15-441">Implizite Verweis Konvertierung ([implizite Verweis Konvertierungen](conversions.md#implicit-reference-conversions))</span><span class="sxs-lookup"><span data-stu-id="99f15-441">An implicit reference conversion ([Implicit reference conversions](conversions.md#implicit-reference-conversions))</span></span>
    * <span data-ttu-id="99f15-442">Eine Boxing-Konvertierung ([boxkonvertierungen](conversions.md#boxing-conversions)), vorausgesetzt, dass TYPE a ein Werttyp ist, der keine NULL-Werte zulässt.</span><span class="sxs-lookup"><span data-stu-id="99f15-442">A boxing conversion ([Boxing conversions](conversions.md#boxing-conversions)), provided that type A is a non-nullable value type.</span></span>
    * <span data-ttu-id="99f15-443">Eine implizite Verweis-, Boxing-oder Typparameter Konvertierung von einem Typparameter `A` in `C`.</span><span class="sxs-lookup"><span data-stu-id="99f15-443">An implicit reference, boxing or type parameter conversion from a type parameter `A` to `C`.</span></span>
*  <span data-ttu-id="99f15-444">Wenn es sich bei der Einschränkung um die Verweistyp Einschränkung (`class`) handelt, muss der Typ `A` einen der folgenden Bedingungen erfüllen:</span><span class="sxs-lookup"><span data-stu-id="99f15-444">If the constraint is the reference type constraint (`class`), the type `A` must satisfy one of the following:</span></span>
    * <span data-ttu-id="99f15-445">`A` ist ein Schnittstellentyp, Klassentyp, Delegattyp oder Arraytyp.</span><span class="sxs-lookup"><span data-stu-id="99f15-445">`A` is an interface type, class type, delegate type or array type.</span></span> <span data-ttu-id="99f15-446">Beachten Sie, dass `System.ValueType` und `System.Enum` Verweis Typen sind, die diese Einschränkung erfüllen.</span><span class="sxs-lookup"><span data-stu-id="99f15-446">Note that `System.ValueType` and `System.Enum` are reference types that satisfy this constraint.</span></span>
    * <span data-ttu-id="99f15-447">`A` ist ein Typparameter, bei dem es sich um einen Verweistyp ([Typparameter Einschränkungen](classes.md#type-parameter-constraints)) handelt.</span><span class="sxs-lookup"><span data-stu-id="99f15-447">`A` is a type parameter that is known to be a reference type ([Type parameter constraints](classes.md#type-parameter-constraints)).</span></span>
*  <span data-ttu-id="99f15-448">Wenn es sich bei der Einschränkung um die Werttyp Einschränkung (`struct`) handelt, muss der Typ `A` einen der folgenden Bedingungen erfüllen:</span><span class="sxs-lookup"><span data-stu-id="99f15-448">If the constraint is the value type constraint (`struct`), the type `A` must satisfy one of the following:</span></span>
    * <span data-ttu-id="99f15-449">`A` ist ein Strukturtyp oder ein Aufzählungs Typ, aber kein Typ, der NULL-Werte zulässt.</span><span class="sxs-lookup"><span data-stu-id="99f15-449">`A` is a struct type or enum type, but not a nullable type.</span></span> <span data-ttu-id="99f15-450">Beachten Sie, dass `System.ValueType` und `System.Enum` Verweis Typen sind, die diese Einschränkung nicht erfüllen.</span><span class="sxs-lookup"><span data-stu-id="99f15-450">Note that `System.ValueType` and `System.Enum` are reference types that do not satisfy this constraint.</span></span>
    * <span data-ttu-id="99f15-451">`A` ist ein Typparameter mit der Werttyp Einschränkung ([Typparameter Einschränkungen](classes.md#type-parameter-constraints)).</span><span class="sxs-lookup"><span data-stu-id="99f15-451">`A` is a type parameter having the value type constraint ([Type parameter constraints](classes.md#type-parameter-constraints)).</span></span>
*  <span data-ttu-id="99f15-452">Wenn die Einschränkung die konstruktoreinschränkungs `new()`ist, darf der Typ `A` nicht `abstract` sein und muss über einen öffentlichen Parameter losen Konstruktor verfügen.</span><span class="sxs-lookup"><span data-stu-id="99f15-452">If the constraint is the constructor constraint `new()`, the type `A` must not be `abstract` and must have a public parameterless constructor.</span></span> <span data-ttu-id="99f15-453">Dies ist erfüllt, wenn eine der folgenden Bedingungen zutrifft:</span><span class="sxs-lookup"><span data-stu-id="99f15-453">This is satisfied if one of the following is true:</span></span>
    * <span data-ttu-id="99f15-454">`A` ist ein Werttyp, da alle Werttypen über einen öffentlichen Standardkonstruktor ([Standardkonstruktoren](types.md#default-constructors)) verfügen.</span><span class="sxs-lookup"><span data-stu-id="99f15-454">`A` is a value type, since all value types have a public default constructor ([Default constructors](types.md#default-constructors)).</span></span>
    * <span data-ttu-id="99f15-455">`A` ist ein Typparameter mit der Konstruktoreinschränkung ([Typparameter Einschränkungen](classes.md#type-parameter-constraints)).</span><span class="sxs-lookup"><span data-stu-id="99f15-455">`A` is a type parameter having the constructor constraint ([Type parameter constraints](classes.md#type-parameter-constraints)).</span></span>
    * <span data-ttu-id="99f15-456">`A` ist ein Typparameter mit der Werttyp Einschränkung ([Typparameter Einschränkungen](classes.md#type-parameter-constraints)).</span><span class="sxs-lookup"><span data-stu-id="99f15-456">`A` is a type parameter having the value type constraint ([Type parameter constraints](classes.md#type-parameter-constraints)).</span></span>
    * <span data-ttu-id="99f15-457">`A` ist eine Klasse, die nicht `abstract` ist und einen explizit deklarierten `public`-Konstruktor ohne Parameter enthält.</span><span class="sxs-lookup"><span data-stu-id="99f15-457">`A` is a class that is not `abstract` and contains an explicitly declared `public` constructor with no parameters.</span></span>
    * <span data-ttu-id="99f15-458">`A` ist nicht `abstract` und verfügt über einen Standardkonstruktor ([Standardkonstruktoren](classes.md#default-constructors)).</span><span class="sxs-lookup"><span data-stu-id="99f15-458">`A` is not `abstract` and has a default constructor ([Default constructors](classes.md#default-constructors)).</span></span>

<span data-ttu-id="99f15-459">Ein Kompilierzeitfehler tritt auf, wenn eine oder mehrere der Einschränkungen eines Typparameters nicht durch die angegebenen Typargumente erfüllt werden.</span><span class="sxs-lookup"><span data-stu-id="99f15-459">A compile-time error occurs if one or more of a type parameter's constraints are not satisfied by the given type arguments.</span></span>

<span data-ttu-id="99f15-460">Da Typparameter nicht vererbt werden, werden Einschränkungen nie geerbt.</span><span class="sxs-lookup"><span data-stu-id="99f15-460">Since type parameters are not inherited, constraints are never inherited either.</span></span> <span data-ttu-id="99f15-461">Im folgenden Beispiel muss `D` die-Einschränkung für den Typparameter `T` angeben, damit `T` die von der Basisklasse `B<T>`erzwungene Einschränkung erfüllt.</span><span class="sxs-lookup"><span data-stu-id="99f15-461">In the example below, `D` needs to specify the constraint on its type parameter `T` so that `T` satisfies the constraint imposed by the base class `B<T>`.</span></span> <span data-ttu-id="99f15-462">Im Gegensatz dazu muss Class `E` keine Einschränkung angeben, da `List<T>` `IEnumerable` für jede `T`implementiert.</span><span class="sxs-lookup"><span data-stu-id="99f15-462">In contrast, class `E` need not specify a constraint, because `List<T>` implements `IEnumerable` for any `T`.</span></span>

```csharp
class B<T> where T: IEnumerable {...}

class D<T>: B<T> where T: IEnumerable {...}

class E<T>: B<List<T>> {...}
```

## <a name="type-parameters"></a><span data-ttu-id="99f15-463">Typparameter</span><span class="sxs-lookup"><span data-stu-id="99f15-463">Type parameters</span></span>

<span data-ttu-id="99f15-464">Ein Typparameter ist ein Bezeichner, der einen Werttyp oder Verweistyp festlegt, an den der Parameter zur Laufzeit gebunden ist.</span><span class="sxs-lookup"><span data-stu-id="99f15-464">A type parameter is an identifier designating a value type or reference type that the parameter is bound to at run-time.</span></span>

```antlr
type_parameter
    : identifier
    ;
```

<span data-ttu-id="99f15-465">Da ein Typparameter mit vielen verschiedenen tatsächlichen Typargumenten instanziiert werden kann, haben Typparameter etwas andere Vorgänge und Einschränkungen als andere Typen.</span><span class="sxs-lookup"><span data-stu-id="99f15-465">Since a type parameter can be instantiated with many different actual type arguments, type parameters have slightly different operations and restrictions than other types.</span></span> <span data-ttu-id="99f15-466">Dazu gehören:</span><span class="sxs-lookup"><span data-stu-id="99f15-466">These include:</span></span>

*  <span data-ttu-id="99f15-467">Ein Typparameter kann nicht direkt verwendet werden, um eine Basisklasse ([Basisklasse](classes.md#base-class)) oder eine Schnittstelle ([Variant-Typparameter Listen](interfaces.md#variant-type-parameter-lists)) zu deklarieren.</span><span class="sxs-lookup"><span data-stu-id="99f15-467">A type parameter cannot be used directly to declare a base class ([Base class](classes.md#base-class)) or interface ([Variant type parameter lists](interfaces.md#variant-type-parameter-lists)).</span></span>
*  <span data-ttu-id="99f15-468">Die Regeln für die Element Suche für Typparameter hängen von den Einschränkungen ab, die ggf. auf den Typparameter angewendet werden.</span><span class="sxs-lookup"><span data-stu-id="99f15-468">The rules for member lookup on type parameters depend on the constraints, if any, applied to the type parameter.</span></span> <span data-ttu-id="99f15-469">Sie werden in der [Mitglieder Suche](expressions.md#member-lookup)ausführlich erläutert.</span><span class="sxs-lookup"><span data-stu-id="99f15-469">They are detailed in [Member lookup](expressions.md#member-lookup).</span></span>
*  <span data-ttu-id="99f15-470">Die verfügbaren Konvertierungen für einen Typparameter hängen von den Einschränkungen ab, die ggf. auf den Typparameter angewendet werden.</span><span class="sxs-lookup"><span data-stu-id="99f15-470">The available conversions for a type parameter depend on the constraints, if any, applied to the type parameter.</span></span> <span data-ttu-id="99f15-471">Sie werden in [impliziten Konvertierungen mit Typparametern](conversions.md#implicit-conversions-involving-type-parameters) und [expliziten dynamischen Konvertierungen](conversions.md#explicit-dynamic-conversions)ausführlich erläutert.</span><span class="sxs-lookup"><span data-stu-id="99f15-471">They are detailed in [Implicit conversions involving type parameters](conversions.md#implicit-conversions-involving-type-parameters) and [Explicit dynamic conversions](conversions.md#explicit-dynamic-conversions).</span></span>
*  <span data-ttu-id="99f15-472">Der Literal`null` kann nicht in einen Typ konvertiert werden, der durch einen Typparameter angegeben wird, mit dem Unterschied, dass der Typparameter ein Verweistyp ist ([implizite Konvertierungen mit Typparametern](conversions.md#implicit-conversions-involving-type-parameters)).</span><span class="sxs-lookup"><span data-stu-id="99f15-472">The literal `null` cannot be converted to a type given by a type parameter, except if the type parameter is known to be a reference type ([Implicit conversions involving type parameters](conversions.md#implicit-conversions-involving-type-parameters)).</span></span> <span data-ttu-id="99f15-473">Stattdessen kann jedoch ein `default` Ausdruck ([Standardwert Ausdrücke](expressions.md#default-value-expressions)) verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="99f15-473">However, a `default` expression ([Default value expressions](expressions.md#default-value-expressions)) can be used instead.</span></span> <span data-ttu-id="99f15-474">Außerdem kann ein Wert mit einem Typ, der durch einen Typparameter angegeben wird, mit `null` mithilfe von `==` und `!=` ([Verweistyp-Gleichheits Operatoren](expressions.md#reference-type-equality-operators)) verglichen werden, es sei denn, der Typparameter weist die Werttyp Einschränkung auf.</span><span class="sxs-lookup"><span data-stu-id="99f15-474">In addition, a value with a type given by a type parameter can be compared with `null` using `==` and `!=` ([Reference type equality operators](expressions.md#reference-type-equality-operators)) unless the type parameter has the value type constraint.</span></span>
*  <span data-ttu-id="99f15-475">Ein `new` Ausdruck ([Objekt Erstellungs Ausdrücke](expressions.md#object-creation-expressions)) kann nur mit einem Typparameter verwendet werden, wenn der Typparameter durch eine *constructor_constraint* oder die Werttyp Einschränkung ([Typparameter Einschränkungen](classes.md#type-parameter-constraints)) eingeschränkt wird.</span><span class="sxs-lookup"><span data-stu-id="99f15-475">A `new` expression ([Object creation expressions](expressions.md#object-creation-expressions)) can only be used with a type parameter if the type parameter is constrained by a *constructor_constraint* or the value type constraint ([Type parameter constraints](classes.md#type-parameter-constraints)).</span></span>
*  <span data-ttu-id="99f15-476">Ein Typparameter kann nicht an einer beliebigen Stelle innerhalb eines Attributs verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="99f15-476">A type parameter cannot be used anywhere within an attribute.</span></span>
*  <span data-ttu-id="99f15-477">Ein Typparameter kann nicht in einem Element Zugriff ([Member Access](expressions.md#member-access)) oder Typname ([Namespace-und Typnamen](basic-concepts.md#namespace-and-type-names)) verwendet werden, um einen statischen Member oder einen schsted Typ zu identifizieren.</span><span class="sxs-lookup"><span data-stu-id="99f15-477">A type parameter cannot be used in a member access ([Member access](expressions.md#member-access)) or type name ([Namespace and type names](basic-concepts.md#namespace-and-type-names)) to identify a static member or a nested type.</span></span>
*  <span data-ttu-id="99f15-478">In unsicherem Code kann ein Typparameter nicht als *unmanaged_type* ([Zeiger Typen](unsafe-code.md#pointer-types)) verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="99f15-478">In unsafe code, a type parameter cannot be used as an *unmanaged_type* ([Pointer types](unsafe-code.md#pointer-types)).</span></span>

<span data-ttu-id="99f15-479">Typparameter sind ein reines Kompilierzeit Konstrukt.</span><span class="sxs-lookup"><span data-stu-id="99f15-479">As a type, type parameters are purely a compile-time construct.</span></span> <span data-ttu-id="99f15-480">Zur Laufzeit wird jeder Typparameter an einen Lauf Zeittyp gebunden, der durch Bereitstellen eines Typarguments an die generische Typdeklaration angegeben wurde.</span><span class="sxs-lookup"><span data-stu-id="99f15-480">At run-time, each type parameter is bound to a run-time type that was specified by supplying a type argument to the generic type declaration.</span></span> <span data-ttu-id="99f15-481">Daher ist der Typ einer Variablen, die mit einem Typparameter deklariert wird, zur Laufzeit ein geschlossener konstruierter Typ ([Open-und Closed-Typen](types.md#open-and-closed-types)).</span><span class="sxs-lookup"><span data-stu-id="99f15-481">Thus, the type of a variable declared with a type parameter will, at run-time, be a closed constructed type ([Open and closed types](types.md#open-and-closed-types)).</span></span> <span data-ttu-id="99f15-482">Die Lauf Zeit Ausführung aller Anweisungen und Ausdrücke, die Typparameter betreffen, verwendet den eigentlichen Typ, der als Typargument für diesen Parameter angegeben wurde.</span><span class="sxs-lookup"><span data-stu-id="99f15-482">The run-time execution of all statements and expressions involving type parameters uses the actual type that was supplied as the type argument for that parameter.</span></span>

## <a name="expression-tree-types"></a><span data-ttu-id="99f15-483">Ausdrucks Baumstruktur Typen</span><span class="sxs-lookup"><span data-stu-id="99f15-483">Expression tree types</span></span>

<span data-ttu-id="99f15-484">***Ausdrucks Baum*** Strukturen erlauben, dass Lambda-Ausdrücke als Datenstrukturen anstelle von ausführbarem Code dargestellt werden.</span><span class="sxs-lookup"><span data-stu-id="99f15-484">***Expression trees*** permit lambda expressions to be represented as data structures instead of executable code.</span></span> <span data-ttu-id="99f15-485">Ausdrucks Baumstrukturen sind Werte von ***Ausdrucks Baumstruktur Typen*** der Form `System.Linq.Expressions.Expression<D>`, wobei `D` ein beliebiger Delegattyp ist.</span><span class="sxs-lookup"><span data-stu-id="99f15-485">Expression trees are values of ***expression tree types*** of the form `System.Linq.Expressions.Expression<D>`, where `D` is any delegate type.</span></span> <span data-ttu-id="99f15-486">Für den Rest dieser Spezifikation verweisen wir auf diese Typen mit der kurzzeile `Expression<D>`.</span><span class="sxs-lookup"><span data-stu-id="99f15-486">For the remainder of this specification we will refer to these types using the shorthand `Expression<D>`.</span></span>

<span data-ttu-id="99f15-487">Wenn eine Konvertierung von einem Lambda-Ausdruck in einen Delegattyp `D`vorhanden ist, ist auch eine Konvertierung für den Ausdrucks bauentyp `Expression<D>`vorhanden.</span><span class="sxs-lookup"><span data-stu-id="99f15-487">If a conversion exists from a lambda expression to a delegate type `D`, a conversion also exists to the expression tree type `Expression<D>`.</span></span> <span data-ttu-id="99f15-488">Während die Konvertierung eines Lambda-Ausdrucks in einen Delegattyp einen Delegaten generiert, der auf den ausführbaren Code für den Lambda-Ausdruck verweist, erstellt die Konvertierung in einen Ausdrucks Strukturtyp eine Ausdrucks Baumstruktur-Darstellung des Lambda Ausdrucks.</span><span class="sxs-lookup"><span data-stu-id="99f15-488">Whereas the conversion of a lambda expression to a delegate type generates a delegate that references executable code for the lambda expression, conversion to an expression tree type creates an expression tree representation of the lambda expression.</span></span>

<span data-ttu-id="99f15-489">Ausdrucks Baumstrukturen sind effiziente in-Memory-Daten Darstellungen von Lambda-Ausdrücken und machen die Struktur des Lambda Ausdrucks transparent und explizit.</span><span class="sxs-lookup"><span data-stu-id="99f15-489">Expression trees are efficient in-memory data representations of lambda expressions and make the structure of the lambda expression transparent and explicit.</span></span>

<span data-ttu-id="99f15-490">Wie bei einem Delegattyp `D`werden `Expression<D>` über Parameter-und Rückgabe Typen verfügen, die mit denen von `D`identisch sind.</span><span class="sxs-lookup"><span data-stu-id="99f15-490">Just like a delegate type `D`, `Expression<D>` is said to have parameter and return types, which are the same as those of `D`.</span></span>

<span data-ttu-id="99f15-491">Im folgenden Beispiel wird ein Lambda-Ausdruck sowohl als ausführbarer Code als auch als Ausdrucks Baumstruktur dargestellt.</span><span class="sxs-lookup"><span data-stu-id="99f15-491">The following example represents a lambda expression both as executable code and as an expression tree.</span></span> <span data-ttu-id="99f15-492">Da eine Konvertierung in `Func<int,int>`vorhanden ist, ist auch eine Konvertierung zum `Expression<Func<int,int>>`vorhanden:</span><span class="sxs-lookup"><span data-stu-id="99f15-492">Because a conversion exists to `Func<int,int>`, a conversion also exists to `Expression<Func<int,int>>`:</span></span>

```csharp
Func<int,int> del = x => x + 1;                    // Code

Expression<Func<int,int>> exp = x => x + 1;        // Data
```

<span data-ttu-id="99f15-493">Nach diesen Zuweisungen verweist der Delegat `del` auf eine Methode, die `x + 1`zurückgibt, und der Ausdrucks Baum `exp` verweist auf eine Datenstruktur, die den Ausdrucks `x => x + 1`beschreibt.</span><span class="sxs-lookup"><span data-stu-id="99f15-493">Following these assignments, the delegate `del` references a method that returns `x + 1`, and the expression tree `exp` references a data structure that describes the expression `x => x + 1`.</span></span>

<span data-ttu-id="99f15-494">Die genaue Definition des generischen Typs `Expression<D>` sowie die präzisen Regeln zum Erstellen einer Ausdrucks Baumstruktur, wenn ein Lambda Ausdruck in einen Ausdrucks Strukturtyp konvertiert wird, liegen beide außerhalb des Gültigkeits Bereichs dieser Spezifikation.</span><span class="sxs-lookup"><span data-stu-id="99f15-494">The exact definition of the generic type `Expression<D>` as well as the precise rules for constructing an expression tree when a lambda expression is converted to an expression tree type, are both outside the scope of this specification.</span></span>

<span data-ttu-id="99f15-495">Zwei Dinge sind wichtig, um explizit zu machen:</span><span class="sxs-lookup"><span data-stu-id="99f15-495">Two things are important to make explicit:</span></span>

*  <span data-ttu-id="99f15-496">Nicht alle Lambda-Ausdrücke können in Ausdrucks Baumstrukturen konvertiert werden.</span><span class="sxs-lookup"><span data-stu-id="99f15-496">Not all lambda expressions can be converted to expression trees.</span></span> <span data-ttu-id="99f15-497">Beispielsweise können Lambda-Ausdrücke mit Anweisungs Text und Lambda-Ausdrücke, die Zuweisungs Ausdrücke enthalten, nicht dargestellt werden.</span><span class="sxs-lookup"><span data-stu-id="99f15-497">For instance, lambda expressions with statement bodies, and lambda expressions containing assignment expressions cannot be represented.</span></span> <span data-ttu-id="99f15-498">In diesen Fällen ist noch eine Konvertierung vorhanden, schlägt jedoch zur Kompilierzeit fehl.</span><span class="sxs-lookup"><span data-stu-id="99f15-498">In these cases, a conversion still exists, but will fail at compile-time.</span></span> <span data-ttu-id="99f15-499">Diese Ausnahmen werden in [anonymen Funktions Konvertierungen](conversions.md#anonymous-function-conversions)ausführlich erläutert.</span><span class="sxs-lookup"><span data-stu-id="99f15-499">These exceptions are detailed in [Anonymous function conversions](conversions.md#anonymous-function-conversions).</span></span>
*   <span data-ttu-id="99f15-500">`Expression<D>` bietet eine Instanzmethode `Compile` die einen Delegaten vom Typ `D`erzeugt:</span><span class="sxs-lookup"><span data-stu-id="99f15-500">`Expression<D>` offers an instance method `Compile` which produces a delegate of type `D`:</span></span>

    ```csharp
    Func<int,int> del2 = exp.Compile();
    ```

    <span data-ttu-id="99f15-501">Das Aufrufen dieses Delegaten bewirkt, dass der durch die Ausdrucks Baumstruktur dargestellte Code ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="99f15-501">Invoking this delegate causes the code represented by the expression tree to be executed.</span></span> <span data-ttu-id="99f15-502">Folglich sind die oben aufgeführten Definitionen gleichwertig, und die folgenden zwei Anweisungen haben die gleiche Wirkung:</span><span class="sxs-lookup"><span data-stu-id="99f15-502">Thus, given the definitions above, del and del2 are equivalent, and the following two statements will have the same effect:</span></span>

    ```csharp
    int i1 = del(1);
    
    int i2 = del2(1);
    ```

    <span data-ttu-id="99f15-503">Nach dem Ausführen dieses Codes haben `i1` und `i2` den Wert `2`.</span><span class="sxs-lookup"><span data-stu-id="99f15-503">After executing this code,  `i1` and `i2` will both have the value `2`.</span></span>

