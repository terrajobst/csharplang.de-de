---
ms.openlocfilehash: 61eeae6173eaa19f9cf6d6e985f3dc107d4c3ac9
ms.sourcegitcommit: 3fc033b6e98ed7ecdf46a85c79b00a3a3ddcf963
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 01/18/2019
ms.locfileid: "50245525"
---
# <a name="conversions"></a><span data-ttu-id="c4e75-101">Konvertierungen</span><span class="sxs-lookup"><span data-stu-id="c4e75-101">Conversions</span></span>

<span data-ttu-id="c4e75-102">Ein ***Konvertierung*** ermöglicht einem Ausdruck als einen bestimmten Typ behandelt werden soll.</span><span class="sxs-lookup"><span data-stu-id="c4e75-102">A ***conversion*** enables an expression to be treated as being of a particular type.</span></span> <span data-ttu-id="c4e75-103">Eine Konvertierung möglicherweise dazu führen, dass einen Ausdruck eines bestimmten Typs als einen anderen Typ behandelt werden soll, oder es kann dazu führen, dass einen Ausdruck ohne einen Typ um einen Typ zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="c4e75-103">A conversion may cause an expression of a given type to be treated as having a different type, or it may cause an expression without a type to get a type.</span></span> <span data-ttu-id="c4e75-104">Konvertierungen möglich ***implizite*** oder ***explizite***, dadurch wird bestimmt, ob eine explizite Umwandlung erforderlich ist.</span><span class="sxs-lookup"><span data-stu-id="c4e75-104">Conversions can be ***implicit*** or ***explicit***, and this determines whether an explicit cast is required.</span></span> <span data-ttu-id="c4e75-105">Z. B. die Konvertierung von Typ `int` eingeben `long` ist implizit, also Ausdrücke vom Typ `int` kann implizit als Typ behandelt werden `long`.</span><span class="sxs-lookup"><span data-stu-id="c4e75-105">For instance, the conversion from type `int` to type `long` is implicit, so expressions of type `int` can implicitly be treated as type `long`.</span></span> <span data-ttu-id="c4e75-106">Die umgekehrte Konvertierung von Typ `long` eingeben `int`, explizite und damit eine explizite Umwandlung erforderlich ist.</span><span class="sxs-lookup"><span data-stu-id="c4e75-106">The opposite conversion, from type `long` to type `int`, is explicit and so an explicit cast is required.</span></span>

```csharp
int a = 123;
long b = a;         // implicit conversion from int to long
int c = (int) b;    // explicit conversion from long to int
```

<span data-ttu-id="c4e75-107">Bei einigen Konvertierungen werden von der Sprache definiert.</span><span class="sxs-lookup"><span data-stu-id="c4e75-107">Some conversions are defined by the language.</span></span> <span data-ttu-id="c4e75-108">Programme können auch eigene Konvertierungen definieren ([benutzerdefinierte Konvertierungen](conversions.md#user-defined-conversions)).</span><span class="sxs-lookup"><span data-stu-id="c4e75-108">Programs may also define their own conversions ([User-defined conversions](conversions.md#user-defined-conversions)).</span></span>

## <a name="implicit-conversions"></a><span data-ttu-id="c4e75-109">Implizite Konvertierungen</span><span class="sxs-lookup"><span data-stu-id="c4e75-109">Implicit conversions</span></span>

<span data-ttu-id="c4e75-110">Die folgenden Konvertierungen werden als implizite Konvertierungen klassifiziert:</span><span class="sxs-lookup"><span data-stu-id="c4e75-110">The following conversions are classified as implicit conversions:</span></span>

*  <span data-ttu-id="c4e75-111">Identity-Konvertierungen</span><span class="sxs-lookup"><span data-stu-id="c4e75-111">Identity conversions</span></span>
*  <span data-ttu-id="c4e75-112">Implizite numerische Konvertierungen</span><span class="sxs-lookup"><span data-stu-id="c4e75-112">Implicit numeric conversions</span></span>
*  <span data-ttu-id="c4e75-113">Enumeration von impliziten Konvertierungen.</span><span class="sxs-lookup"><span data-stu-id="c4e75-113">Implicit enumeration conversions.</span></span>
*  <span data-ttu-id="c4e75-114">Implizite NULL-Werte zulassen Konvertierungen</span><span class="sxs-lookup"><span data-stu-id="c4e75-114">Implicit nullable conversions</span></span>
*  <span data-ttu-id="c4e75-115">NULL-literal-Konvertierungen</span><span class="sxs-lookup"><span data-stu-id="c4e75-115">Null literal conversions</span></span>
*  <span data-ttu-id="c4e75-116">Ein impliziter verweiskonvertierungen</span><span class="sxs-lookup"><span data-stu-id="c4e75-116">Implicit reference conversions</span></span>
*  <span data-ttu-id="c4e75-117">Boxing-Konvertierung</span><span class="sxs-lookup"><span data-stu-id="c4e75-117">Boxing conversions</span></span>
*  <span data-ttu-id="c4e75-118">Implizite dynamische Konvertierungen</span><span class="sxs-lookup"><span data-stu-id="c4e75-118">Implicit dynamic conversions</span></span>
*  <span data-ttu-id="c4e75-119">Implizite konstanter Ausdruck-Konvertierungen</span><span class="sxs-lookup"><span data-stu-id="c4e75-119">Implicit constant expression conversions</span></span>
*  <span data-ttu-id="c4e75-120">Benutzerdefinierte implizite Konvertierungen</span><span class="sxs-lookup"><span data-stu-id="c4e75-120">User-defined implicit conversions</span></span>
*  <span data-ttu-id="c4e75-121">Anonyme Funktion Konvertierungen</span><span class="sxs-lookup"><span data-stu-id="c4e75-121">Anonymous function conversions</span></span>
*  <span data-ttu-id="c4e75-122">Konvertierungen für Gruppe</span><span class="sxs-lookup"><span data-stu-id="c4e75-122">Method group conversions</span></span>

<span data-ttu-id="c4e75-123">Implizite Konvertierungen können auftreten, in einer Vielzahl von Situationen, einschließlich der Element-Funktionsaufrufe ([Überprüfungen zur Kompilierzeit der dynamischen überladungsauflösung](expressions.md#compile-time-checking-of-dynamic-overload-resolution)), Umwandlungsausdrücke ([Umwandlungsausdrücke](expressions.md#cast-expressions)), und Zuweisungen ([Zuweisungsoperatoren](expressions.md#assignment-operators)).</span><span class="sxs-lookup"><span data-stu-id="c4e75-123">Implicit conversions can occur in a variety of situations, including function member invocations ([Compile-time checking of dynamic overload resolution](expressions.md#compile-time-checking-of-dynamic-overload-resolution)), cast expressions ([Cast expressions](expressions.md#cast-expressions)), and assignments ([Assignment operators](expressions.md#assignment-operators)).</span></span>

<span data-ttu-id="c4e75-124">Die vordefinierten implizite Konvertierungen immer erfolgreich, und nie Ausnahmen verursachen.</span><span class="sxs-lookup"><span data-stu-id="c4e75-124">The pre-defined implicit conversions always succeed and never cause exceptions to be thrown.</span></span> <span data-ttu-id="c4e75-125">Richtig entworfene benutzerdefinierte implizite Konvertierungen sollte auch diese Merkmale aufweisen.</span><span class="sxs-lookup"><span data-stu-id="c4e75-125">Properly designed user-defined implicit conversions should exhibit these characteristics as well.</span></span>

<span data-ttu-id="c4e75-126">Im Rahmen der Konvertierung, die Typen `object` und `dynamic` als äquivalent betrachtet werden.</span><span class="sxs-lookup"><span data-stu-id="c4e75-126">For the purposes of conversion, the types `object` and `dynamic` are considered equivalent.</span></span>

<span data-ttu-id="c4e75-127">Jedoch dynamische Konvertierungen ([implizite dynamische Konvertierungen](conversions.md#implicit-dynamic-conversions) und [explizite dynamische Konvertierungen](conversions.md#explicit-dynamic-conversions)) gelten nur für Ausdrücke vom Typ `dynamic` ([der dynamische Typ](types.md#the-dynamic-type)).</span><span class="sxs-lookup"><span data-stu-id="c4e75-127">However, dynamic conversions ([Implicit dynamic conversions](conversions.md#implicit-dynamic-conversions) and [Explicit dynamic conversions](conversions.md#explicit-dynamic-conversions)) apply only to expressions of type `dynamic` ([The dynamic type](types.md#the-dynamic-type)).</span></span>

### <a name="identity-conversion"></a><span data-ttu-id="c4e75-128">Identitätskonvertierung</span><span class="sxs-lookup"><span data-stu-id="c4e75-128">Identity conversion</span></span>

<span data-ttu-id="c4e75-129">Eine identitätskonvertierung von einem Typ die in denselben Typ konvertiert werden.</span><span class="sxs-lookup"><span data-stu-id="c4e75-129">An identity conversion converts from any type to the same type.</span></span> <span data-ttu-id="c4e75-130">Diese Konvertierung vorhanden ist, dass eine Entität, die bereits den erforderlichen Typ besitzt bezeichnet werden kann, um auf diesen Typ konvertiert werden können.</span><span class="sxs-lookup"><span data-stu-id="c4e75-130">This conversion exists such that an entity that already has a required type can be said to be convertible to that type.</span></span>

*  <span data-ttu-id="c4e75-131">Da das Objekt und dynamischer als gleichwertig angesehen werden besteht eine für die identitätskonvertierung `object` und `dynamic`, und zwischen konstruierte Typen, die gleich sind, wenn Sie alle Vorkommen von ersetzen `dynamic` mit `object`.</span><span class="sxs-lookup"><span data-stu-id="c4e75-131">Because object and dynamic are considered equivalent there is an identity conversion between `object` and `dynamic`, and between constructed types that are the same when replacing all occurrences of `dynamic` with `object`.</span></span>

### <a name="implicit-numeric-conversions"></a><span data-ttu-id="c4e75-132">Implizite numerische Konvertierungen</span><span class="sxs-lookup"><span data-stu-id="c4e75-132">Implicit numeric conversions</span></span>

<span data-ttu-id="c4e75-133">Die impliziten numerischen Konvertierungen sind:</span><span class="sxs-lookup"><span data-stu-id="c4e75-133">The implicit numeric conversions are:</span></span>

*  <span data-ttu-id="c4e75-134">Von `sbyte` zu `short`, `int`, `long`, `float`, `double`, oder `decimal`.</span><span class="sxs-lookup"><span data-stu-id="c4e75-134">From `sbyte` to `short`, `int`, `long`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="c4e75-135">Von `byte` zu `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `float`, `double`, oder `decimal`.</span><span class="sxs-lookup"><span data-stu-id="c4e75-135">From `byte` to `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="c4e75-136">Von `short` zu `int`, `long`, `float`, `double`, oder `decimal`.</span><span class="sxs-lookup"><span data-stu-id="c4e75-136">From `short` to `int`, `long`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="c4e75-137">Von `ushort` zu `int`, `uint`, `long`, `ulong`, `float`, `double`, oder `decimal`.</span><span class="sxs-lookup"><span data-stu-id="c4e75-137">From `ushort` to `int`, `uint`, `long`, `ulong`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="c4e75-138">Von `int` zu `long`, `float`, `double`, oder `decimal`.</span><span class="sxs-lookup"><span data-stu-id="c4e75-138">From `int` to `long`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="c4e75-139">Von `uint` zu `long`, `ulong`, `float`, `double`, oder `decimal`.</span><span class="sxs-lookup"><span data-stu-id="c4e75-139">From `uint` to `long`, `ulong`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="c4e75-140">Von `long` zu `float`, `double`, oder `decimal`.</span><span class="sxs-lookup"><span data-stu-id="c4e75-140">From `long` to `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="c4e75-141">Von `ulong` zu `float`, `double`, oder `decimal`.</span><span class="sxs-lookup"><span data-stu-id="c4e75-141">From `ulong` to `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="c4e75-142">Von `char` zu `ushort`, `int`, `uint`, `long`, `ulong`, `float`, `double`, oder `decimal`.</span><span class="sxs-lookup"><span data-stu-id="c4e75-142">From `char` to `ushort`, `int`, `uint`, `long`, `ulong`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="c4e75-143">Von `float` zu `double`.</span><span class="sxs-lookup"><span data-stu-id="c4e75-143">From `float` to `double`.</span></span>

<span data-ttu-id="c4e75-144">Konvertierungen von `int`, `uint`, `long`, oder `ulong` zu `float` und `long` oder `ulong` zu `double` möglicherweise zu einem Genauigkeitsverlust führen, wird aber nie Ursache ein Verlust der Größe.</span><span class="sxs-lookup"><span data-stu-id="c4e75-144">Conversions from `int`, `uint`, `long`, or `ulong` to `float` and from `long` or `ulong` to `double` may cause a loss of precision, but will never cause a loss of magnitude.</span></span> <span data-ttu-id="c4e75-145">Die anderen impliziten numerischen Konvertierungen verlieren keine Informationen.</span><span class="sxs-lookup"><span data-stu-id="c4e75-145">The other implicit numeric conversions never lose any information.</span></span>

<span data-ttu-id="c4e75-146">Es gibt keine impliziten Konvertierungen für die `char` eingeben, damit die Werte der anderen ganzzahligen Typen nicht automatisch in konvertiert werden die `char` Typ.</span><span class="sxs-lookup"><span data-stu-id="c4e75-146">There are no implicit conversions to the `char` type, so values of the other integral types do not automatically convert to the `char` type.</span></span>

### <a name="implicit-enumeration-conversions"></a><span data-ttu-id="c4e75-147">Enumeration von impliziten Konvertierungen</span><span class="sxs-lookup"><span data-stu-id="c4e75-147">Implicit enumeration conversions</span></span>

<span data-ttu-id="c4e75-148">Eine Enumeration der impliziten Konvertierung lässt die *Decimal_integer_literal* `0` in eine konvertiert werden *Enum_type* sowie an ggf. *Nullable_type* , deren zugrunde liegende Typ ist ein *Enum_type*.</span><span class="sxs-lookup"><span data-stu-id="c4e75-148">An implicit enumeration conversion permits the *decimal_integer_literal* `0` to be converted to any *enum_type* and to any *nullable_type* whose underlying type is an *enum_type*.</span></span> <span data-ttu-id="c4e75-149">Im letzteren Fall wird die Konvertierung ausgewertet, durch die Konvertierung in den zugrunde liegenden *Enum_type* und das Ergebnis ([auf NULL festlegbare Typen](types.md#nullable-types)).</span><span class="sxs-lookup"><span data-stu-id="c4e75-149">In the latter case the conversion is evaluated by converting to the underlying *enum_type* and wrapping the result ([Nullable types](types.md#nullable-types)).</span></span>

### <a name="implicit-interpolated-string-conversions"></a><span data-ttu-id="c4e75-150">Implizite interpolierte zeichenfolgenkonvertierungen</span><span class="sxs-lookup"><span data-stu-id="c4e75-150">Implicit interpolated string conversions</span></span>

<span data-ttu-id="c4e75-151">Ein impliziter interpolierte Zeichenfolge Konvertierung lässt eine *Interpolated_string_expression* ([interpolierte Zeichenfolgen](expressions.md#interpolated-strings)) zu konvertierenden `System.IFormattable` oder `System.FormattableString` (implementiert `System.IFormattable`).</span><span class="sxs-lookup"><span data-stu-id="c4e75-151">An implicit interpolated string conversion permits an *interpolated_string_expression* ([Interpolated strings](expressions.md#interpolated-strings)) to be converted to `System.IFormattable` or `System.FormattableString` (which implements `System.IFormattable`).</span></span>

<span data-ttu-id="c4e75-152">Wenn diese Konvertierung angewendet wird besteht ein String-Wert aus der interpolierten Zeichenfolge nicht.</span><span class="sxs-lookup"><span data-stu-id="c4e75-152">When this conversion is applied a string value is not composed from the interpolated string.</span></span> <span data-ttu-id="c4e75-153">Stattdessen eine Instanz von `System.FormattableString` erstellt, in gemäß Erläuterung unten [interpolierte Zeichenfolgen](expressions.md#interpolated-strings).</span><span class="sxs-lookup"><span data-stu-id="c4e75-153">Instead an instance of `System.FormattableString` is created, as further described in [Interpolated strings](expressions.md#interpolated-strings).</span></span>

### <a name="implicit-nullable-conversions"></a><span data-ttu-id="c4e75-154">Implizite NULL-Werte zulassen Konvertierungen</span><span class="sxs-lookup"><span data-stu-id="c4e75-154">Implicit nullable conversions</span></span>

<span data-ttu-id="c4e75-155">Vordefinierte implizite Konvertierungen, die nicht auf NULL festlegbare Werttypen verarbeiten können auch mit NULL-Werte zulassen Forms dieser Typen verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="c4e75-155">Predefined implicit conversions that operate on non-nullable value types can also be used with nullable forms of those types.</span></span> <span data-ttu-id="c4e75-156">Für jede vordefinierte implizite Identitäts- und numerische Konvertierungen, die von einem Typ NULL-Werte konvertieren `S` auf einen NULL-Werttyp `T`, existieren die folgenden Konvertierungen für das implizite NULL-Werte zulassen:</span><span class="sxs-lookup"><span data-stu-id="c4e75-156">For each of the predefined implicit identity and numeric conversions that convert from a non-nullable value type `S` to a non-nullable value type `T`, the following implicit nullable conversions exist:</span></span>

*  <span data-ttu-id="c4e75-157">Eine implizite Konvertierung von `S?` zu `T?`.</span><span class="sxs-lookup"><span data-stu-id="c4e75-157">An implicit conversion from `S?` to `T?`.</span></span>
*  <span data-ttu-id="c4e75-158">Eine implizite Konvertierung von `S` zu `T?`.</span><span class="sxs-lookup"><span data-stu-id="c4e75-158">An implicit conversion from `S` to `T?`.</span></span>

<span data-ttu-id="c4e75-159">Auswertung der eine implizite Konvertierung für die NULL-Werte zulassen basierend auf eine zugrunde liegende Konvertierung von `S` zu `T` wird wie folgt:</span><span class="sxs-lookup"><span data-stu-id="c4e75-159">Evaluation of an implicit nullable conversion based on an underlying conversion from `S` to `T` proceeds as follows:</span></span>

*  <span data-ttu-id="c4e75-160">Wenn eine auf NULL festlegbare Konvertierung von `S?` zu `T?`:</span><span class="sxs-lookup"><span data-stu-id="c4e75-160">If the nullable conversion is from `S?` to `T?`:</span></span>
    * <span data-ttu-id="c4e75-161">Wenn der Quellwert null ist (`HasValue` Eigenschaft ist "false"), das Ergebnis ist der null-Wert des Typs `T?`.</span><span class="sxs-lookup"><span data-stu-id="c4e75-161">If the source value is null (`HasValue` property is false), the result is the null value of type `T?`.</span></span>
    * <span data-ttu-id="c4e75-162">Andernfalls wird die Konvertierung ausgewertet, als ein Entpacken von `S?` zu `S`, gefolgt von der zugrunde liegenden Konvertierung von `S` zu `T`, gefolgt von einem Wrapper ([auf NULL festlegbare Typen](types.md#nullable-types)) von `T` zu `T?`.</span><span class="sxs-lookup"><span data-stu-id="c4e75-162">Otherwise, the conversion is evaluated as an unwrapping from `S?` to `S`, followed by the underlying conversion from `S` to `T`, followed by a wrapping ([Nullable types](types.md#nullable-types)) from `T` to `T?`.</span></span>

*  <span data-ttu-id="c4e75-163">Wenn eine auf NULL festlegbare Konvertierung von `S` zu `T?`, die Konvertierung wird ausgewertet, als die zugrunde liegenden Konvertierung von `S` zu `T` gefolgt von einem Textumbruch aus `T` zu `T?`.</span><span class="sxs-lookup"><span data-stu-id="c4e75-163">If the nullable conversion is from `S` to `T?`, the conversion is evaluated as the underlying conversion from `S` to `T` followed by a wrapping from `T` to `T?`.</span></span>

### <a name="null-literal-conversions"></a><span data-ttu-id="c4e75-164">NULL-literal-Konvertierungen</span><span class="sxs-lookup"><span data-stu-id="c4e75-164">Null literal conversions</span></span>

<span data-ttu-id="c4e75-165">Eine implizite Konvertierung vorhanden ist, aus der `null` Zeichenfolgenliteral in einen beliebigen Typ NULL-Werte zulässt.</span><span class="sxs-lookup"><span data-stu-id="c4e75-165">An implicit conversion exists from the `null` literal to any nullable type.</span></span> <span data-ttu-id="c4e75-166">Diese Konvertierung erzeugt, den null-Wert ([auf NULL festlegbare Typen](types.md#nullable-types)) des angegebenen Typs NULL-Werte zulässt.</span><span class="sxs-lookup"><span data-stu-id="c4e75-166">This conversion produces the null value ([Nullable types](types.md#nullable-types)) of the given nullable type.</span></span>

### <a name="implicit-reference-conversions"></a><span data-ttu-id="c4e75-167">Ein impliziter verweiskonvertierungen</span><span class="sxs-lookup"><span data-stu-id="c4e75-167">Implicit reference conversions</span></span>

<span data-ttu-id="c4e75-168">Die implizite verweiskonvertierungen sind:</span><span class="sxs-lookup"><span data-stu-id="c4e75-168">The implicit reference conversions are:</span></span>

*  <span data-ttu-id="c4e75-169">Von jedem *Reference_type* zu `object` und `dynamic`.</span><span class="sxs-lookup"><span data-stu-id="c4e75-169">From any *reference_type* to `object` and `dynamic`.</span></span>
*  <span data-ttu-id="c4e75-170">Von jedem *Class_type* `S` auf *Class_type* `T`, bereitgestellt wird, `S` ergibt sich aus `T`.</span><span class="sxs-lookup"><span data-stu-id="c4e75-170">From any *class_type* `S` to any *class_type* `T`, provided `S` is derived from `T`.</span></span>
*  <span data-ttu-id="c4e75-171">Von jedem *Class_type* `S` auf *Interface_type* `T`aus `S` implementiert `T`.</span><span class="sxs-lookup"><span data-stu-id="c4e75-171">From any *class_type* `S` to any *interface_type* `T`, provided `S` implements `T`.</span></span>
*  <span data-ttu-id="c4e75-172">Von jedem *Interface_type* `S` auf *Interface_type* `T`, bereitgestellt wird, `S` ergibt sich aus `T`.</span><span class="sxs-lookup"><span data-stu-id="c4e75-172">From any *interface_type* `S` to any *interface_type* `T`, provided `S` is derived from `T`.</span></span>
*  <span data-ttu-id="c4e75-173">Aus einer *Array_type* `S` mit einem Elementtyp `SE` auf eine *Array_type* `T` mit einem Elementtyp `TE`, sofern alle der folgenden Bedingungen erfüllt sind:</span><span class="sxs-lookup"><span data-stu-id="c4e75-173">From an *array_type* `S` with an element type `SE` to an *array_type* `T` with an element type `TE`, provided all of the following are true:</span></span>
    * <span data-ttu-id="c4e75-174">`S` und `T` unterscheiden sich nur hinsichtlich der Elementtyp.</span><span class="sxs-lookup"><span data-stu-id="c4e75-174">`S` and `T` differ only in element type.</span></span> <span data-ttu-id="c4e75-175">Das heißt, `S` und `T` haben die gleiche Anzahl von Dimensionen.</span><span class="sxs-lookup"><span data-stu-id="c4e75-175">In other words, `S` and `T` have the same number of dimensions.</span></span>
    * <span data-ttu-id="c4e75-176">Beide `SE` und `TE` sind *Reference_type*s.</span><span class="sxs-lookup"><span data-stu-id="c4e75-176">Both `SE` and `TE` are *reference_type*s.</span></span>
    * <span data-ttu-id="c4e75-177">Implizite verweiskonvertierung vorhanden ist, von `SE` zu `TE`.</span><span class="sxs-lookup"><span data-stu-id="c4e75-177">An implicit reference conversion exists from `SE` to `TE`.</span></span>
*  <span data-ttu-id="c4e75-178">Von jedem *Array_type* zu `System.Array` und die Schnittstellen implementiert.</span><span class="sxs-lookup"><span data-stu-id="c4e75-178">From any *array_type* to `System.Array` and the interfaces it implements.</span></span>
*  <span data-ttu-id="c4e75-179">Aus einem eindimensionalen Array-Typ `S[]` zu `System.Collections.Generic.IList<T>` und die Basisschnittstellen, vorausgesetzt, es gibt eine implizite Identitäts- oder verweiskonvertierung aus `S` zu `T`.</span><span class="sxs-lookup"><span data-stu-id="c4e75-179">From a single-dimensional array type `S[]` to `System.Collections.Generic.IList<T>` and its base interfaces, provided that there is an implicit identity or reference conversion from `S` to `T`.</span></span>
*  <span data-ttu-id="c4e75-180">Von jedem *Delegate_type* zu `System.Delegate` und die Schnittstellen implementiert.</span><span class="sxs-lookup"><span data-stu-id="c4e75-180">From any *delegate_type* to `System.Delegate` and the interfaces it implements.</span></span>
*  <span data-ttu-id="c4e75-181">Von der null-Literal in einem *Reference_type*.</span><span class="sxs-lookup"><span data-stu-id="c4e75-181">From the null literal to any *reference_type*.</span></span>
*  <span data-ttu-id="c4e75-182">Aus allen *Reference_type* auf eine *Reference_type* `T` verfügt eine implizite Identitäts- oder verweiskonvertierung, einer *Reference_type* `T0` und `T0` verfügt über eine identitätskonvertierung in `T`.</span><span class="sxs-lookup"><span data-stu-id="c4e75-182">From any *reference_type* to a *reference_type* `T` if it has an implicit identity or reference conversion to a *reference_type* `T0` and `T0` has an identity conversion to `T`.</span></span>
*  <span data-ttu-id="c4e75-183">Von jedem *Reference_type* auf einen Typ von Schnittstellen oder Delegate `T` verfügt eine implizite Identitäts- oder verweiskonvertierung auf einen Typ von Schnittstellen oder Delegate `T0` und `T0` ist varianzkonvertierbar ([ Varianzkonvertierungen](interfaces.md#variance-conversion)) zu `T`.</span><span class="sxs-lookup"><span data-stu-id="c4e75-183">From any *reference_type* to an interface or delegate type `T` if it has an implicit identity or reference conversion to an interface or delegate type `T0` and `T0` is variance-convertible ([Variance conversion](interfaces.md#variance-conversion)) to `T`.</span></span>
*  <span data-ttu-id="c4e75-184">Implizite Konvertierungen, die im Zusammenhang mit Typparametern, die bekannt ist, dass Verweistypen sein.</span><span class="sxs-lookup"><span data-stu-id="c4e75-184">Implicit conversions involving type parameters that are known to be reference types.</span></span> <span data-ttu-id="c4e75-185">Finden Sie unter [implizite Konvertierungen, die im Zusammenhang mit Typparametern](conversions.md#implicit-conversions-involving-type-parameters) ausführliche Informationen zum impliziten Konvertierungen, die im Zusammenhang mit Typparametern.</span><span class="sxs-lookup"><span data-stu-id="c4e75-185">See [Implicit conversions involving type parameters](conversions.md#implicit-conversions-involving-type-parameters) for more details on implicit conversions involving type parameters.</span></span>

<span data-ttu-id="c4e75-186">Die implizite verweiskonvertierungen sind Konvertierungen zwischen *Reference_type*s, die belegt werden kann, dass Sie immer erfolgreich sein und erfordern daher keine Überprüfungen zur Laufzeit.</span><span class="sxs-lookup"><span data-stu-id="c4e75-186">The implicit reference conversions are those conversions between *reference_type*s that can be proven to always succeed, and therefore require no checks at run-time.</span></span>

<span data-ttu-id="c4e75-187">Verweiskonvertierungen, implizite oder explizite, ändern sich nie die referenzielle Identität des Objekts, der konvertiert wird.</span><span class="sxs-lookup"><span data-stu-id="c4e75-187">Reference conversions, implicit or explicit, never change the referential identity of the object being converted.</span></span> <span data-ttu-id="c4e75-188">Das heißt, während referenzkonvertierung den Typ des Verweises ändern kann, ändert es nie den Typ oder Wert des Objekts auf die verwiesen wird.</span><span class="sxs-lookup"><span data-stu-id="c4e75-188">In other words, while a reference conversion may change the type of the reference, it never changes the type or value of the object being referred to.</span></span>

### <a name="boxing-conversions"></a><span data-ttu-id="c4e75-189">Boxing-Konvertierung</span><span class="sxs-lookup"><span data-stu-id="c4e75-189">Boxing conversions</span></span>

<span data-ttu-id="c4e75-190">Eine Boxing-Konvertierung, ermöglicht eine *Value_type* implizit in einen Verweistyp konvertiert werden.</span><span class="sxs-lookup"><span data-stu-id="c4e75-190">A boxing conversion permits a *value_type* to be implicitly converted to a reference type.</span></span> <span data-ttu-id="c4e75-191">Eine Boxingkonvertierung vorhanden ist, von jedem *Non_nullable_value_type* zu `object` und `dynamic`zu `System.ValueType` sowie an ggf. *Interface_type* implementiert die *Non_ Nullable_value_type*.</span><span class="sxs-lookup"><span data-stu-id="c4e75-191">A boxing conversion exists from any *non_nullable_value_type* to `object` and `dynamic`, to `System.ValueType` and to any *interface_type* implemented by the *non_nullable_value_type*.</span></span> <span data-ttu-id="c4e75-192">Darüber hinaus eine *Enum_type* konvertiert werden kann, in den Typ `System.Enum`.</span><span class="sxs-lookup"><span data-stu-id="c4e75-192">Furthermore an *enum_type* can be converted to the type `System.Enum`.</span></span>

<span data-ttu-id="c4e75-193">Eine Boxingkonvertierung vorhanden ist, aus einer *Nullable_type* ein Verweistyp, wenn ein Boxing-Konvertierung vorhanden ist aus der zugrunde liegenden *Non_nullable_value_type* in den Referenztyp.</span><span class="sxs-lookup"><span data-stu-id="c4e75-193">A boxing conversion exists from a *nullable_type* to a reference type, if and only if a boxing conversion exists from the underlying *non_nullable_value_type* to the reference type.</span></span>

<span data-ttu-id="c4e75-194">Ein Werttyp ist, eine Boxing-Konvertierung in einen Schnittstellentyp `I` verfügt eine Boxing-Konvertierung in einen Schnittstellentyp `I0` und `I0` verfügt über eine identitätskonvertierung in `I`.</span><span class="sxs-lookup"><span data-stu-id="c4e75-194">A value type has a boxing conversion to an interface type `I` if it has a boxing conversion to an interface type `I0` and `I0` has an identity conversion to `I`.</span></span>

<span data-ttu-id="c4e75-195">Ein Werttyp ist, eine Boxing-Konvertierung in einen Schnittstellentyp `I` verfügt eine Boxing-Konvertierung in einen Typ von Schnittstellen oder Delegate `I0` und `I0` ist varianzkonvertierbar ([varianzkonvertierungen](interfaces.md#variance-conversion)) zu `I`.</span><span class="sxs-lookup"><span data-stu-id="c4e75-195">A value type has a boxing conversion to an interface type `I` if it has a boxing conversion to an interface or delegate type `I0` and `I0` is variance-convertible ([Variance conversion](interfaces.md#variance-conversion)) to `I`.</span></span>

<span data-ttu-id="c4e75-196">Boxing-Wert eine *Non_nullable_value_type* besteht aus eine Objektinstanz zuordnen und das Kopieren der *Value_type* Wert in dieser Instanz.</span><span class="sxs-lookup"><span data-stu-id="c4e75-196">Boxing a value of a *non_nullable_value_type* consists of allocating an object instance and copying the *value_type* value into that instance.</span></span> <span data-ttu-id="c4e75-197">Eine Struktur kann geschachtelt werden, in den Typ `System.ValueType`, da dies eine Basisklasse für alle Strukturen ist ([Vererbung](structs.md#inheritance)).</span><span class="sxs-lookup"><span data-stu-id="c4e75-197">A struct can be boxed to the type `System.ValueType`, since that is a base class for all structs ([Inheritance](structs.md#inheritance)).</span></span>

<span data-ttu-id="c4e75-198">Boxing-Wert eine *Nullable_type* wird wie folgt:</span><span class="sxs-lookup"><span data-stu-id="c4e75-198">Boxing a value of a *nullable_type* proceeds as follows:</span></span>

*  <span data-ttu-id="c4e75-199">Wenn der Quellwert null ist (`HasValue` Eigenschaft ist "false"), das Ergebnis ist ein null-Verweis des Zieltyps.</span><span class="sxs-lookup"><span data-stu-id="c4e75-199">If the source value is null (`HasValue` property is false), the result is a null reference of the target type.</span></span>
*  <span data-ttu-id="c4e75-200">Das Ergebnis ist, andernfalls ein Verweis auf eine geschachtelte `T` von entpacken und den Wert des boxing erzeugt werden.</span><span class="sxs-lookup"><span data-stu-id="c4e75-200">Otherwise, the result is a reference to a boxed `T` produced by unwrapping and boxing the source value.</span></span>

<span data-ttu-id="c4e75-201">Boxing-Konvertierung werden ausführlich in [Boxingkonvertierungen](types.md#boxing-conversions).</span><span class="sxs-lookup"><span data-stu-id="c4e75-201">Boxing conversions are described further in [Boxing conversions](types.md#boxing-conversions).</span></span>

### <a name="implicit-dynamic-conversions"></a><span data-ttu-id="c4e75-202">Implizite dynamische Konvertierungen</span><span class="sxs-lookup"><span data-stu-id="c4e75-202">Implicit dynamic conversions</span></span>

<span data-ttu-id="c4e75-203">Eine implizite Konvertierung für die dynamische vorhanden ist, von einem Ausdruck vom Typ `dynamic` auf einen beliebigen Typ `T`.</span><span class="sxs-lookup"><span data-stu-id="c4e75-203">An implicit dynamic conversion exists from an expression of type `dynamic` to any type `T`.</span></span> <span data-ttu-id="c4e75-204">Die Konvertierung dynamisch gebunden ist ([dynamische Bindung](expressions.md#dynamic-binding)), was bedeutet, dass eine implizite Konvertierung zur Laufzeit von der Runtime-Typ des Ausdrucks, der gesucht werden soll, wird `T`.</span><span class="sxs-lookup"><span data-stu-id="c4e75-204">The conversion is dynamically bound ([Dynamic binding](expressions.md#dynamic-binding)), which means that an implicit conversion will be sought at run-time from the run-time type of the expression to `T`.</span></span> <span data-ttu-id="c4e75-205">Wenn keine Konvertierung gefunden wird, wird eine Laufzeitausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="c4e75-205">If no conversion is found, a run-time exception is thrown.</span></span>

<span data-ttu-id="c4e75-206">Beachten Sie, dass diese implizite Konvertierung den Rat am Anfang des scheinbar verstößt gegen [implizite Konvertierungen](conversions.md#implicit-conversions) , dass eine implizite Konvertierung niemals eine Ausnahme auslösen soll.</span><span class="sxs-lookup"><span data-stu-id="c4e75-206">Note that this implicit conversion seemingly violates the advice in the beginning of [Implicit conversions](conversions.md#implicit-conversions) that an implicit conversion should never cause an exception.</span></span> <span data-ttu-id="c4e75-207">Ist es jedoch nicht die Konvertierung selbst, aber die *suchen* der Konvertierung, die die Ausnahme ausgelöst hat.</span><span class="sxs-lookup"><span data-stu-id="c4e75-207">However it is not the conversion itself, but the *finding* of the conversion that causes the exception.</span></span> <span data-ttu-id="c4e75-208">Bei der Verwendung der dynamischen Bindung ist das Risiko von Laufzeitausnahmen.</span><span class="sxs-lookup"><span data-stu-id="c4e75-208">The risk of run-time exceptions is inherent in the use of dynamic binding.</span></span> <span data-ttu-id="c4e75-209">Wenn die dynamische Bindung für die Konvertierung nicht gewünscht ist, der Ausdruck konvertiert werden kann zunächst `object`, und klicken Sie dann den gewünschten Typ.</span><span class="sxs-lookup"><span data-stu-id="c4e75-209">If dynamic binding of the conversion is not desired, the expression can be first converted to `object`, and then to the desired type.</span></span>

<span data-ttu-id="c4e75-210">Das folgende Beispiel veranschaulicht die implizite dynamische Konvertierungen:</span><span class="sxs-lookup"><span data-stu-id="c4e75-210">The following example illustrates implicit dynamic conversions:</span></span>

```csharp
object o  = "object"
dynamic d = "dynamic";

string s1 = o; // Fails at compile-time -- no conversion exists
string s2 = d; // Compiles and succeeds at run-time
int i     = d; // Compiles but fails at run-time -- no conversion exists
```

<span data-ttu-id="c4e75-211">Die Zuweisungen zu `s2` und `i` sowohl der implizite dynamische Konvertierungen, die Bindung der Vorgänge, bis zur Laufzeit angehalten wird verwenden.</span><span class="sxs-lookup"><span data-stu-id="c4e75-211">The assignments to `s2` and `i` both employ implicit dynamic conversions, where the binding of the operations is suspended until run-time.</span></span> <span data-ttu-id="c4e75-212">Zur Laufzeit, implizite Konvertierungen aus der Run-Time-Typ, der gesucht werden `d`  --  `string` – in den Zieltyp.</span><span class="sxs-lookup"><span data-stu-id="c4e75-212">At run-time, implicit conversions are sought from the run-time type of `d` -- `string` -- to the target type.</span></span> <span data-ttu-id="c4e75-213">Eine Konvertierung wird festgestellt, dass `string` aber nicht für `int`.</span><span class="sxs-lookup"><span data-stu-id="c4e75-213">A conversion is found to `string` but not to `int`.</span></span>

### <a name="implicit-constant-expression-conversions"></a><span data-ttu-id="c4e75-214">Implizite konstanter Ausdruck-Konvertierungen</span><span class="sxs-lookup"><span data-stu-id="c4e75-214">Implicit constant expression conversions</span></span>

<span data-ttu-id="c4e75-215">Eine Konvertierung implizit Konstantenausdruck ermöglicht die folgenden Konvertierungen:</span><span class="sxs-lookup"><span data-stu-id="c4e75-215">An implicit constant expression conversion permits the following conversions:</span></span>

*  <span data-ttu-id="c4e75-216">Ein *Constant_expression* ([Konstante Ausdrücke](expressions.md#constant-expressions)) vom Typ `int` Typ konvertiert werden kann `sbyte`, `byte`, `short`, `ushort`, `uint`, oder `ulong`, vorausgesetzt, der Wert, der die *Constant_expression* liegt innerhalb des Bereichs des Zieltyps.</span><span class="sxs-lookup"><span data-stu-id="c4e75-216">A *constant_expression* ([Constant expressions](expressions.md#constant-expressions)) of type `int` can be converted to type `sbyte`, `byte`, `short`, `ushort`, `uint`, or `ulong`, provided the value of the *constant_expression* is within the range of the destination type.</span></span>
*  <span data-ttu-id="c4e75-217">Ein *Constant_expression* des Typs `long` Typ konvertiert werden kann `ulong`, vorausgesetzt, der Wert, der die *Constant_expression* nicht negativ ist.</span><span class="sxs-lookup"><span data-stu-id="c4e75-217">A *constant_expression* of type `long` can be converted to type `ulong`, provided the value of the *constant_expression* is not negative.</span></span>

### <a name="implicit-conversions-involving-type-parameters"></a><span data-ttu-id="c4e75-218">Implizite Konvertierungen, die im Zusammenhang mit Typparametern</span><span class="sxs-lookup"><span data-stu-id="c4e75-218">Implicit conversions involving type parameters</span></span>

<span data-ttu-id="c4e75-219">Die folgenden implizite Konvertierungen für einen Parameter angegebenen Typ vorhanden `T`:</span><span class="sxs-lookup"><span data-stu-id="c4e75-219">The following implicit conversions exist for a given type parameter `T`:</span></span>

*  <span data-ttu-id="c4e75-220">Von `T` zu deren effektiven Basisklasse `C`, von `T` auf einer Basisklasse von `C`, und von `T` für jede Schnittstelle implementiert, indem `C`.</span><span class="sxs-lookup"><span data-stu-id="c4e75-220">From `T` to its effective base class `C`, from `T` to any base class of `C`, and from `T` to any interface implemented by `C`.</span></span> <span data-ttu-id="c4e75-221">AT-Laufzeit-If `T` ist ein Werttyp, einer Boxing-Konvertierung die Konvertierung ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="c4e75-221">At run-time, if `T` is a value type, the conversion is executed as a boxing conversion.</span></span> <span data-ttu-id="c4e75-222">Andernfalls wird die Konvertierung als implizite verweiskonvertierung oder identitätskonvertierung ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="c4e75-222">Otherwise, the conversion is executed as an implicit reference conversion or identity conversion.</span></span>
*  <span data-ttu-id="c4e75-223">Aus `T` in einen Schnittstellentyp `I` in `T`effektive Schnittstelle des festgelegt werden und von `T` auf alle Basisschnittstelle `I`.</span><span class="sxs-lookup"><span data-stu-id="c4e75-223">From `T` to an interface type `I` in `T`'s effective interface set and from `T` to any base interface of `I`.</span></span> <span data-ttu-id="c4e75-224">AT-Laufzeit-If `T` ist ein Werttyp, einer Boxing-Konvertierung die Konvertierung ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="c4e75-224">At run-time, if `T` is a value type, the conversion is executed as a boxing conversion.</span></span> <span data-ttu-id="c4e75-225">Andernfalls wird die Konvertierung als implizite verweiskonvertierung oder identitätskonvertierung ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="c4e75-225">Otherwise, the conversion is executed as an implicit reference conversion or identity conversion.</span></span>
*  <span data-ttu-id="c4e75-226">Von `T` auf einen Typparameter `U`aus `T` hängt `U` ([Geben Sie die Einschränkungen für Typparameter](classes.md#type-parameter-constraints)).</span><span class="sxs-lookup"><span data-stu-id="c4e75-226">From `T` to a type parameter `U`, provided `T` depends on `U` ([Type parameter constraints](classes.md#type-parameter-constraints)).</span></span> <span data-ttu-id="c4e75-227">AT-Laufzeit-If `U` ein Werttyp ist, klicken Sie dann `T` und `U` unbedingt den gleichen Typ aufweisen und wird keine Konvertierung durchgeführt.</span><span class="sxs-lookup"><span data-stu-id="c4e75-227">At run-time, if `U` is a value type, then `T` and `U` are necessarily the same type and no conversion is performed.</span></span> <span data-ttu-id="c4e75-228">Andernfalls gilt: Wenn `T` ist ein Werttyp, einer Boxing-Konvertierung die Konvertierung ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="c4e75-228">Otherwise, if `T` is a value type, the conversion is executed as a boxing conversion.</span></span> <span data-ttu-id="c4e75-229">Andernfalls wird die Konvertierung als implizite verweiskonvertierung oder identitätskonvertierung ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="c4e75-229">Otherwise, the conversion is executed as an implicit reference conversion or identity conversion.</span></span>
*  <span data-ttu-id="c4e75-230">Von der null-Literal in `T`aus `T` ist ein Verweistyp ist bekannt.</span><span class="sxs-lookup"><span data-stu-id="c4e75-230">From the null literal to `T`, provided `T` is known to be a reference type.</span></span>
*  <span data-ttu-id="c4e75-231">Von `T` in einen Verweistyp `I` , wenn es sich um eine implizite Konvertierung in einen Verweistyp hat `S0` und `S0` verfügt über eine identitätskonvertierung in `S`.</span><span class="sxs-lookup"><span data-stu-id="c4e75-231">From `T` to a reference type `I` if it has an implicit conversion to a reference type `S0` and `S0` has an identity conversion to `S`.</span></span> <span data-ttu-id="c4e75-232">Zur Laufzeit wird die Konvertierung ausgeführt, die gleiche Weise wie die Konvertierung in `S0`.</span><span class="sxs-lookup"><span data-stu-id="c4e75-232">At run-time the conversion is executed the same way as the conversion to `S0`.</span></span>
*  <span data-ttu-id="c4e75-233">Von `T` in einen Schnittstellentyp `I` verfügt eine implizite Konvertierung in einen Typ von Schnittstellen oder Delegate `I0` und `I0` ist varianzkonvertierbar zu `I` ([varianzkonvertierungen](interfaces.md#variance-conversion) ).</span><span class="sxs-lookup"><span data-stu-id="c4e75-233">From `T` to an interface type `I` if it has an implicit conversion to an interface or delegate type `I0` and `I0` is variance-convertible to `I` ([Variance conversion](interfaces.md#variance-conversion)).</span></span> <span data-ttu-id="c4e75-234">AT-Laufzeit-If `T` ist ein Werttyp, einer Boxing-Konvertierung die Konvertierung ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="c4e75-234">At run-time, if `T` is a value type, the conversion is executed as a boxing conversion.</span></span> <span data-ttu-id="c4e75-235">Andernfalls wird die Konvertierung als implizite verweiskonvertierung oder identitätskonvertierung ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="c4e75-235">Otherwise, the conversion is executed as an implicit reference conversion or identity conversion.</span></span>

<span data-ttu-id="c4e75-236">Wenn `T` bekannt ist ein Verweistyp sein ([Geben Sie die Einschränkungen für Typparameter](classes.md#type-parameter-constraints)), die oben genannten Konvertierungen werden als implizite Verweis-klassifiziert ([implizite Verweis-](conversions.md#implicit-reference-conversions)).</span><span class="sxs-lookup"><span data-stu-id="c4e75-236">If `T` is known to be a reference type ([Type parameter constraints](classes.md#type-parameter-constraints)), the conversions above are all classified as implicit reference conversions ([Implicit reference conversions](conversions.md#implicit-reference-conversions)).</span></span> <span data-ttu-id="c4e75-237">Wenn `T` ist nicht bekannt ist, ein Verweistyp sein muss, sind die Konvertierungen, die höher als Boxingkonvertierungen klassifiziert ([Boxingkonvertierungen](conversions.md#boxing-conversions)).</span><span class="sxs-lookup"><span data-stu-id="c4e75-237">If `T` is not known to be a reference type, the conversions above are classified as boxing conversions ([Boxing conversions](conversions.md#boxing-conversions)).</span></span>

### <a name="user-defined-implicit-conversions"></a><span data-ttu-id="c4e75-238">Benutzerdefinierte implizite Konvertierungen</span><span class="sxs-lookup"><span data-stu-id="c4e75-238">User-defined implicit conversions</span></span>

<span data-ttu-id="c4e75-239">Eine implizite Konvertierung von benutzerdefinierten umfasst eine optionale standard implizite Konvertierung, gefolgt von der Ausführung einer benutzerdefinierten implizite Konvertierungsoperator, gefolgt von einem anderen optionalen standard implizite Konvertierung.</span><span class="sxs-lookup"><span data-stu-id="c4e75-239">A user-defined implicit conversion consists of an optional standard implicit conversion, followed by execution of a user-defined implicit conversion operator, followed by another optional standard implicit conversion.</span></span> <span data-ttu-id="c4e75-240">Die genauen Regeln für Ihre Evaluierung von benutzerdefinierten implizite Konvertierungen werden in beschrieben [von impliziten Konvertierungen eine benutzerdefinierte Verarbeitung](conversions.md#processing-of-user-defined-implicit-conversions).</span><span class="sxs-lookup"><span data-stu-id="c4e75-240">The exact rules for evaluating user-defined implicit conversions are described in [Processing of user-defined implicit conversions](conversions.md#processing-of-user-defined-implicit-conversions).</span></span>

### <a name="anonymous-function-conversions-and-method-group-conversions"></a><span data-ttu-id="c4e75-241">Anonyme Funktion Konvertierungen und Konvertierungen für Gruppe</span><span class="sxs-lookup"><span data-stu-id="c4e75-241">Anonymous function conversions and method group conversions</span></span>

<span data-ttu-id="c4e75-242">Anonyme Funktionen und Methodengruppen keine Typen an und für sich allerdings um Typen oder ausdrucksbaumstrukturtypen delegieren implizit konvertiert werden können.</span><span class="sxs-lookup"><span data-stu-id="c4e75-242">Anonymous functions and method groups do not have types in and of themselves, but may be implicitly converted to delegate types or expression tree types.</span></span> <span data-ttu-id="c4e75-243">Anonyme Funktion Konvertierungen werden ausführlicher beschrieben [anonyme Funktion Konvertierungen](conversions.md#anonymous-function-conversions) und Gruppe Konvertierungen in [Gruppe Konvertierungen](conversions.md#method-group-conversions).</span><span class="sxs-lookup"><span data-stu-id="c4e75-243">Anonymous function conversions are described in more detail in [Anonymous function conversions](conversions.md#anonymous-function-conversions) and method group conversions in [Method group conversions](conversions.md#method-group-conversions).</span></span>

## <a name="explicit-conversions"></a><span data-ttu-id="c4e75-244">Explizite Konvertierungen</span><span class="sxs-lookup"><span data-stu-id="c4e75-244">Explicit conversions</span></span>

<span data-ttu-id="c4e75-245">Die folgenden Konvertierungen werden explizite Konvertierungen klassifiziert:</span><span class="sxs-lookup"><span data-stu-id="c4e75-245">The following conversions are classified as explicit conversions:</span></span>

*  <span data-ttu-id="c4e75-246">Alle impliziten Konvertierungen.</span><span class="sxs-lookup"><span data-stu-id="c4e75-246">All implicit conversions.</span></span>
*  <span data-ttu-id="c4e75-247">Explizite numerische Konvertierungen.</span><span class="sxs-lookup"><span data-stu-id="c4e75-247">Explicit numeric conversions.</span></span>
*  <span data-ttu-id="c4e75-248">Konvertierungen von expliziten-Enumeration.</span><span class="sxs-lookup"><span data-stu-id="c4e75-248">Explicit enumeration conversions.</span></span>
*  <span data-ttu-id="c4e75-249">Explizite Konvertierungen für NULL-Werte zulässt.</span><span class="sxs-lookup"><span data-stu-id="c4e75-249">Explicit nullable conversions.</span></span>
*  <span data-ttu-id="c4e75-250">Explizite Konvertierungen.</span><span class="sxs-lookup"><span data-stu-id="c4e75-250">Explicit reference conversions.</span></span>
*  <span data-ttu-id="c4e75-251">Explizite Konvertierungen.</span><span class="sxs-lookup"><span data-stu-id="c4e75-251">Explicit interface conversions.</span></span>
*  <span data-ttu-id="c4e75-252">Unboxing-Konvertierungen.</span><span class="sxs-lookup"><span data-stu-id="c4e75-252">Unboxing conversions.</span></span>
*  <span data-ttu-id="c4e75-253">Explizite dynamische Konvertierungen</span><span class="sxs-lookup"><span data-stu-id="c4e75-253">Explicit dynamic conversions</span></span>
*  <span data-ttu-id="c4e75-254">Benutzerdefinierte explizite Konvertierungen.</span><span class="sxs-lookup"><span data-stu-id="c4e75-254">User-defined explicit conversions.</span></span>

<span data-ttu-id="c4e75-255">Explizite Konvertierungen können in der Cast-Ausdrücke auftreten ([Umwandlungsausdrücke](expressions.md#cast-expressions)).</span><span class="sxs-lookup"><span data-stu-id="c4e75-255">Explicit conversions can occur in cast expressions ([Cast expressions](expressions.md#cast-expressions)).</span></span>

<span data-ttu-id="c4e75-256">Der explizite Konvertierungen enthält alle impliziter Konvertierungen.</span><span class="sxs-lookup"><span data-stu-id="c4e75-256">The set of explicit conversions includes all implicit conversions.</span></span> <span data-ttu-id="c4e75-257">Dies bedeutet, dass redundante Cast-Ausdrücke zulässig sind.</span><span class="sxs-lookup"><span data-stu-id="c4e75-257">This means that redundant cast expressions are allowed.</span></span>

<span data-ttu-id="c4e75-258">Die explizite Konvertierungen, die keine impliziten Konvertierungen sind sind Konvertierungen, die belegt werden können, dass immer erfolgreich, Konvertierungen, die bekannt ist, dass Sie möglicherweise Informationen verloren gehen und Konvertierungen zwischen Domänen unterscheiden, auch explizite Typen Notation.</span><span class="sxs-lookup"><span data-stu-id="c4e75-258">The explicit conversions that are not implicit conversions are conversions that cannot be proven to always succeed, conversions that are known to possibly lose information, and conversions across domains of types sufficiently different to merit explicit notation.</span></span>

### <a name="explicit-numeric-conversions"></a><span data-ttu-id="c4e75-259">Explizite numerische Konvertierungen</span><span class="sxs-lookup"><span data-stu-id="c4e75-259">Explicit numeric conversions</span></span>

<span data-ttu-id="c4e75-260">Die expliziten numerischen Konvertierungen sind Konvertierungen aus einer *Numeric_type* in ein anderes *Numeric_type* für die eine implizite numerische Konvertierung ([implizite numerische Konvertierungen](conversions.md#implicit-numeric-conversions)) ist noch nicht vorhanden:</span><span class="sxs-lookup"><span data-stu-id="c4e75-260">The explicit numeric conversions are the conversions from a *numeric_type* to another *numeric_type* for which an implicit numeric conversion ([Implicit numeric conversions](conversions.md#implicit-numeric-conversions)) does not already exist:</span></span>

*  <span data-ttu-id="c4e75-261">Von `sbyte` zu `byte`, `ushort`, `uint`, `ulong`, oder `char`.</span><span class="sxs-lookup"><span data-stu-id="c4e75-261">From `sbyte` to `byte`, `ushort`, `uint`, `ulong`, or `char`.</span></span>
*  <span data-ttu-id="c4e75-262">Von `byte` zu `sbyte` und `char`.</span><span class="sxs-lookup"><span data-stu-id="c4e75-262">From `byte` to `sbyte` and `char`.</span></span>
*  <span data-ttu-id="c4e75-263">Von `short` zu `sbyte`, `byte`, `ushort`, `uint`, `ulong`, oder `char`.</span><span class="sxs-lookup"><span data-stu-id="c4e75-263">From `short` to `sbyte`, `byte`, `ushort`, `uint`, `ulong`, or `char`.</span></span>
*  <span data-ttu-id="c4e75-264">Von `ushort` zu `sbyte`, `byte`, `short`, oder `char`.</span><span class="sxs-lookup"><span data-stu-id="c4e75-264">From `ushort` to `sbyte`, `byte`, `short`, or `char`.</span></span>
*  <span data-ttu-id="c4e75-265">Von `int` zu `sbyte`, `byte`, `short`, `ushort`, `uint`, `ulong`, oder `char`.</span><span class="sxs-lookup"><span data-stu-id="c4e75-265">From `int` to `sbyte`, `byte`, `short`, `ushort`, `uint`, `ulong`, or `char`.</span></span>
*  <span data-ttu-id="c4e75-266">Von `uint` zu `sbyte`, `byte`, `short`, `ushort`, `int`, oder `char`.</span><span class="sxs-lookup"><span data-stu-id="c4e75-266">From `uint` to `sbyte`, `byte`, `short`, `ushort`, `int`, or `char`.</span></span>
*  <span data-ttu-id="c4e75-267">Von `long` zu `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `ulong`, oder `char`.</span><span class="sxs-lookup"><span data-stu-id="c4e75-267">From `long` to `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `ulong`, or `char`.</span></span>
*  <span data-ttu-id="c4e75-268">Von `ulong` zu `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, oder `char`.</span><span class="sxs-lookup"><span data-stu-id="c4e75-268">From `ulong` to `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, or `char`.</span></span>
*  <span data-ttu-id="c4e75-269">Von `char` zu `sbyte`, `byte`, oder `short`.</span><span class="sxs-lookup"><span data-stu-id="c4e75-269">From `char` to `sbyte`, `byte`, or `short`.</span></span>
*  <span data-ttu-id="c4e75-270">Von `float` zu `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, oder `decimal`.</span><span class="sxs-lookup"><span data-stu-id="c4e75-270">From `float` to `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, or `decimal`.</span></span>
*  <span data-ttu-id="c4e75-271">Von `double` zu `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, oder `decimal`.</span><span class="sxs-lookup"><span data-stu-id="c4e75-271">From `double` to `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, or `decimal`.</span></span>
*  <span data-ttu-id="c4e75-272">Von `decimal` zu `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, oder `double`.</span><span class="sxs-lookup"><span data-stu-id="c4e75-272">From `decimal` to `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, or `double`.</span></span>

<span data-ttu-id="c4e75-273">Da die explizite Konvertierungen alle implizite und explizite numerische Konvertierungen enthalten, ist es immer möglich, die aus einem konvertieren *Numeric_type* auch einer beliebigen anderen *Numeric_type* mithilfe eines Cast-Ausdruck ( [Umwandlungsausdrücke](expressions.md#cast-expressions)).</span><span class="sxs-lookup"><span data-stu-id="c4e75-273">Because the explicit conversions include all implicit and explicit numeric conversions, it is always possible to convert from any *numeric_type* to any other *numeric_type* using a cast expression ([Cast expressions](expressions.md#cast-expressions)).</span></span>

<span data-ttu-id="c4e75-274">Die expliziten numerischen Konvertierungen Informationen möglicherweise verloren gehen oder möglicherweise dazu führen, dass Ausnahmen ausgelöst werden.</span><span class="sxs-lookup"><span data-stu-id="c4e75-274">The explicit numeric conversions possibly lose information or possibly cause exceptions to be thrown.</span></span> <span data-ttu-id="c4e75-275">Eine explizite numerische Konvertierung wird wie folgt verarbeitet:</span><span class="sxs-lookup"><span data-stu-id="c4e75-275">An explicit numeric conversion is processed as follows:</span></span>

*  <span data-ttu-id="c4e75-276">Für eine Konvertierung in einen ganzzahligen Typ in einen anderen ganzzahligen Typ hängt von die Verarbeitung Kontext der überlaufprüfung ([checked und unchecked Operatoren](expressions.md#the-checked-and-unchecked-operators)) in der die Konvertierung akzeptiert platzieren:</span><span class="sxs-lookup"><span data-stu-id="c4e75-276">For a conversion from an integral type to another integral type, the processing depends on the overflow checking context ([The checked and unchecked operators](expressions.md#the-checked-and-unchecked-operators)) in which the conversion takes place:</span></span>
    * <span data-ttu-id="c4e75-277">In einer `checked` Kontext ist die Konvertierung erfolgreich ist, wenn der Wert des Quelloperanden innerhalb des Bereichs des Zieltyps liegt, aber löst einen `System.OverflowException` , wenn der Wert des Quelloperanden liegt außerhalb des Bereichs des Zieltyps ist.</span><span class="sxs-lookup"><span data-stu-id="c4e75-277">In a `checked` context, the conversion succeeds if the value of the source operand is within the range of the destination type, but throws a `System.OverflowException` if the value of the source operand is outside the range of the destination type.</span></span>
    * <span data-ttu-id="c4e75-278">In einer `unchecked` Kontext ist die Konvertierung immer erfolgreich ist, und wird wie folgt.</span><span class="sxs-lookup"><span data-stu-id="c4e75-278">In an `unchecked` context, the conversion always succeeds, and proceeds as follows.</span></span>
        * <span data-ttu-id="c4e75-279">Wenn der Quelltyp größer als der Zieltyp ist, wird der Quellwert abgeschnitten, indem die wichtigsten „zusätzlichen“ Teile verworfen werden.</span><span class="sxs-lookup"><span data-stu-id="c4e75-279">If the source type is larger than the destination type, then the source value is truncated by discarding its "extra" most significant bits.</span></span> <span data-ttu-id="c4e75-280">Das Ergebnis wird dann als Wert des Zieltyps behandelt.</span><span class="sxs-lookup"><span data-stu-id="c4e75-280">The result is then treated as a value of the destination type.</span></span>
        * <span data-ttu-id="c4e75-281">Wenn der Quelltyp kleiner als der Zieltyp ist, wird der Quellwert entweder mit Vorzeichen oder Nullen (0) erweitert, sodass er die gleiche Größe wie der Zieltyp aufweist.</span><span class="sxs-lookup"><span data-stu-id="c4e75-281">If the source type is smaller than the destination type, then the source value is either sign-extended or zero-extended so that it is the same size as the destination type.</span></span> <span data-ttu-id="c4e75-282">Die Vorzeichenerweiterung wird verwendet, wenn der Quelltyp mit einem Vorzeichen versehen ist. Die Erweiterung mit Nullen (0) wird verwendet, wenn der Quelltyp mit keinem Vorzeichen versehen ist.</span><span class="sxs-lookup"><span data-stu-id="c4e75-282">Sign-extension is used if the source type is signed; zero-extension is used if the source type is unsigned.</span></span> <span data-ttu-id="c4e75-283">Das Ergebnis wird dann als Wert des Zieltyps behandelt.</span><span class="sxs-lookup"><span data-stu-id="c4e75-283">The result is then treated as a value of the destination type.</span></span>
        * <span data-ttu-id="c4e75-284">Wenn der Quelltyp die gleiche Größe wie der Zieltyp aufweist, wird der Quellwert als Wert vom Zieltyp behandelt.</span><span class="sxs-lookup"><span data-stu-id="c4e75-284">If the source type is the same size as the destination type, then the source value is treated as a value of the destination type.</span></span>
*  <span data-ttu-id="c4e75-285">Für eine Konvertierung von `decimal` in einen ganzzahligen Typ, wird der Quellwert in Richtung 0 (null), um den nächsten ganzzahligen Wert gerundet, und dieser ganzzahlige Wert wird das Ergebnis der Konvertierung.</span><span class="sxs-lookup"><span data-stu-id="c4e75-285">For a conversion from `decimal` to an integral type, the source value is rounded towards zero to the nearest integral value, and this integral value becomes the result of the conversion.</span></span> <span data-ttu-id="c4e75-286">Wenn der erzeugte Integralwert sich außerhalb des Bereichs des Zieltyps, ist eine `System.OverflowException` ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="c4e75-286">If the resulting integral value is outside the range of the destination type, a `System.OverflowException` is thrown.</span></span>
*  <span data-ttu-id="c4e75-287">Für eine Konvertierung von `float` oder `double` in einen ganzzahligen Typ, hängt die Verarbeitung von Kontext der überlaufprüfung ([checked und unchecked Operatoren](expressions.md#the-checked-and-unchecked-operators)) in der die Konvertierung akzeptiert platzieren:</span><span class="sxs-lookup"><span data-stu-id="c4e75-287">For a conversion from `float` or `double` to an integral type, the processing depends on the overflow checking context ([The checked and unchecked operators](expressions.md#the-checked-and-unchecked-operators)) in which the conversion takes place:</span></span>
    * <span data-ttu-id="c4e75-288">In einem `checked` Kontext ist die Konvertierung wird wie folgt:</span><span class="sxs-lookup"><span data-stu-id="c4e75-288">In a `checked` context, the conversion proceeds as follows:</span></span>
        * <span data-ttu-id="c4e75-289">Wenn der Wert des Operanden NaN oder unendlich sein, eine `System.OverflowException` ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="c4e75-289">If the value of the operand is NaN or infinite, a `System.OverflowException` is thrown.</span></span>
        * <span data-ttu-id="c4e75-290">Andernfalls wird Quelloperanden gegen 0 (null), um den nächsten ganzzahligen Wert gerundet.</span><span class="sxs-lookup"><span data-stu-id="c4e75-290">Otherwise, the source operand is rounded towards zero to the nearest integral value.</span></span> <span data-ttu-id="c4e75-291">Wenn dieser ganzzahlige Wert innerhalb des Bereichs des Zieltyps ist, ist dieser Wert das Ergebnis der Konvertierung.</span><span class="sxs-lookup"><span data-stu-id="c4e75-291">If this integral value is within the range of the destination type then this value is the result of the conversion.</span></span>
        * <span data-ttu-id="c4e75-292">Andernfalls wird eine `System.OverflowException` ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="c4e75-292">Otherwise, a `System.OverflowException` is thrown.</span></span>
    * <span data-ttu-id="c4e75-293">In einer `unchecked` Kontext ist die Konvertierung immer erfolgreich ist, und wird wie folgt.</span><span class="sxs-lookup"><span data-stu-id="c4e75-293">In an `unchecked` context, the conversion always succeeds, and proceeds as follows.</span></span>
        * <span data-ttu-id="c4e75-294">Wenn der Wert des Operanden NaN oder unendlich ist, ist das Ergebnis der Konvertierung einen nicht angegebenen Wert des Zieltyps.</span><span class="sxs-lookup"><span data-stu-id="c4e75-294">If the value of the operand is NaN or infinite, the result of the conversion is an unspecified value of the destination type.</span></span>
        * <span data-ttu-id="c4e75-295">Andernfalls wird Quelloperanden gegen 0 (null), um den nächsten ganzzahligen Wert gerundet.</span><span class="sxs-lookup"><span data-stu-id="c4e75-295">Otherwise, the source operand is rounded towards zero to the nearest integral value.</span></span> <span data-ttu-id="c4e75-296">Wenn dieser ganzzahlige Wert innerhalb des Bereichs des Zieltyps ist, ist dieser Wert das Ergebnis der Konvertierung.</span><span class="sxs-lookup"><span data-stu-id="c4e75-296">If this integral value is within the range of the destination type then this value is the result of the conversion.</span></span>
        * <span data-ttu-id="c4e75-297">Andernfalls ist das Ergebnis der Konvertierung einen nicht angegebenen Wert des Zieltyps.</span><span class="sxs-lookup"><span data-stu-id="c4e75-297">Otherwise, the result of the conversion is an unspecified value of the destination type.</span></span>
*  <span data-ttu-id="c4e75-298">Für eine Konvertierung von `double` zu `float`, `double` Wert wird gerundet, um die nächste `float` Wert.</span><span class="sxs-lookup"><span data-stu-id="c4e75-298">For a conversion from `double` to `float`, the `double` value is rounded to the nearest `float` value.</span></span> <span data-ttu-id="c4e75-299">Wenn die `double` Wert ist zu klein, um die Darstellung als eine `float`, das Ergebnis positiv oder negativ 0 (null).</span><span class="sxs-lookup"><span data-stu-id="c4e75-299">If the `double` value is too small to represent as a `float`, the result becomes positive zero or negative zero.</span></span> <span data-ttu-id="c4e75-300">Wenn die `double` Wert ist zu groß, um die Darstellung als eine `float`, wird das Ergebnis, positive oder negative Unendlichkeit.</span><span class="sxs-lookup"><span data-stu-id="c4e75-300">If the `double` value is too large to represent as a `float`, the result becomes positive infinity or negative infinity.</span></span> <span data-ttu-id="c4e75-301">Wenn die `double` Wert ist NaN, es ist auch das Ergebnis NaN.</span><span class="sxs-lookup"><span data-stu-id="c4e75-301">If the `double` value is NaN, the result is also NaN.</span></span>
*  <span data-ttu-id="c4e75-302">Für eine Konvertierung von `float` oder `double` zu `decimal`, wird der Quellwert in konvertiert `decimal` Darstellung und bei Bedarf auf die nächste Zahl nach der 28. Dezimalstelle gerundet ([Dezimaltyps](types.md#the-decimal-type)).</span><span class="sxs-lookup"><span data-stu-id="c4e75-302">For a conversion from `float` or `double` to `decimal`, the source value is converted to `decimal` representation and rounded to the nearest number after the 28th decimal place if required ([The decimal type](types.md#the-decimal-type)).</span></span> <span data-ttu-id="c4e75-303">Wenn der Quellwert zu klein, um die Darstellung als ist eine `decimal`, wird das Ergebnis 0 (null).</span><span class="sxs-lookup"><span data-stu-id="c4e75-303">If the source value is too small to represent as a `decimal`, the result becomes zero.</span></span> <span data-ttu-id="c4e75-304">Wenn der Quellwert NaN ist, ist unendlich oder zu groß, um die Darstellung als eine `decimal`, eine `System.OverflowException` ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="c4e75-304">If the source value is NaN, infinity, or too large to represent as a `decimal`, a `System.OverflowException` is thrown.</span></span>
*  <span data-ttu-id="c4e75-305">Für eine Konvertierung von `decimal` zu `float` oder `double`, `decimal` Wert wird gerundet, um die nächste `double` oder `float` Wert.</span><span class="sxs-lookup"><span data-stu-id="c4e75-305">For a conversion from `decimal` to `float` or `double`, the `decimal` value is rounded to the nearest `double` or `float` value.</span></span> <span data-ttu-id="c4e75-306">Während dieser Konvertierung an Genauigkeit verlieren kann, wird nie eine Ausnahme ausgelöst werden.</span><span class="sxs-lookup"><span data-stu-id="c4e75-306">While this conversion may lose precision, it never causes an exception to be thrown.</span></span>

### <a name="explicit-enumeration-conversions"></a><span data-ttu-id="c4e75-307">Enumeration der explizite Konvertierungen</span><span class="sxs-lookup"><span data-stu-id="c4e75-307">Explicit enumeration conversions</span></span>

<span data-ttu-id="c4e75-308">Die Enumeration der explizite Konvertierungen sind:</span><span class="sxs-lookup"><span data-stu-id="c4e75-308">The explicit enumeration conversions are:</span></span>

*  <span data-ttu-id="c4e75-309">Von `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, `double`, oder `decimal` auf alle *Enum_type*.</span><span class="sxs-lookup"><span data-stu-id="c4e75-309">From `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, `double`, or `decimal` to any *enum_type*.</span></span>
*  <span data-ttu-id="c4e75-310">Von jedem *Enum_type* zu `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, `double`, oder `decimal`.</span><span class="sxs-lookup"><span data-stu-id="c4e75-310">From any *enum_type* to `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="c4e75-311">Von jedem *Enum_type* auch einer beliebigen anderen *Enum_type*.</span><span class="sxs-lookup"><span data-stu-id="c4e75-311">From any *enum_type* to any other *enum_type*.</span></span>

<span data-ttu-id="c4e75-312">Eine Enumeration der expliziten Konvertierung zwischen zwei Typen von behandeln alle Teil verarbeitet wird *Enum_type* als den zugrunde liegenden Typ, der *Enum_type*, und klicken Sie dann ausführen, die eine implizite oder explizite numerische Konvertierung zwischen den resultierenden Typen.</span><span class="sxs-lookup"><span data-stu-id="c4e75-312">An explicit enumeration conversion between two types is processed by treating any participating *enum_type* as the underlying type of that *enum_type*, and then performing an implicit or explicit numeric conversion between the resulting types.</span></span> <span data-ttu-id="c4e75-313">Angenommen, ein *Enum_type* `E` mit und die zugrunde liegende Standardtyp von `int`, eine Konvertierung von `E` zu `byte` als eine explizite numerische Konvertierung verarbeitet ([Explicit numerische Konvertierungen](conversions.md#explicit-numeric-conversions)) von `int` zu `byte`, und eine Konvertierung von `byte` zu `E` wird als implizite numerische Konvertierung verarbeitet ([implizite numerische Konvertierungen](conversions.md#implicit-numeric-conversions)) von `byte` zu `int`.</span><span class="sxs-lookup"><span data-stu-id="c4e75-313">For example, given an *enum_type* `E` with and underlying type of `int`, a conversion from `E` to `byte` is processed as an explicit numeric conversion ([Explicit numeric conversions](conversions.md#explicit-numeric-conversions)) from `int` to `byte`, and a conversion from `byte` to `E` is processed as an implicit numeric conversion ([Implicit numeric conversions](conversions.md#implicit-numeric-conversions)) from `byte` to `int`.</span></span>

### <a name="explicit-nullable-conversions"></a><span data-ttu-id="c4e75-314">Explizite NULL-Werte zulassen Konvertierungen</span><span class="sxs-lookup"><span data-stu-id="c4e75-314">Explicit nullable conversions</span></span>

<span data-ttu-id="c4e75-315">***Explizite NULL-Werte zulassen Konvertierungen*** zulassen vordefinierte explizite Konvertierungen, die Vorgänge an nicht auf NULL festlegbare Werttypen auch mit NULL-Werte zulassen Forms dieser Typen verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="c4e75-315">***Explicit nullable conversions*** permit predefined explicit conversions that operate on non-nullable value types to also be used with nullable forms of those types.</span></span> <span data-ttu-id="c4e75-316">Für jedes der vordefinierten explizite Konvertierungen, die von einem Typ NULL-Werte konvertieren `S` auf einen NULL-Werttyp `T` ([identitätskonvertierung](conversions.md#identity-conversion), [implizite numerische Konvertierungen](conversions.md#implicit-numeric-conversions), [Enumeration von impliziten Konvertierungen](conversions.md#implicit-enumeration-conversions), [explizite numerische Konvertierungen](conversions.md#explicit-numeric-conversions), und [explizite Enumeration Konvertierungen](conversions.md#explicit-enumeration-conversions)), die folgenden auf NULL festlegbare Konvertierungen sind vorhanden:</span><span class="sxs-lookup"><span data-stu-id="c4e75-316">For each of the predefined explicit conversions that convert from a non-nullable value type `S` to a non-nullable value type `T` ([Identity conversion](conversions.md#identity-conversion), [Implicit numeric conversions](conversions.md#implicit-numeric-conversions), [Implicit enumeration conversions](conversions.md#implicit-enumeration-conversions), [Explicit numeric conversions](conversions.md#explicit-numeric-conversions), and [Explicit enumeration conversions](conversions.md#explicit-enumeration-conversions)), the following nullable conversions exist:</span></span>

*  <span data-ttu-id="c4e75-317">Eine explizite Konvertierung vom `S?` zu `T?`.</span><span class="sxs-lookup"><span data-stu-id="c4e75-317">An explicit conversion from `S?` to `T?`.</span></span>
*  <span data-ttu-id="c4e75-318">Eine explizite Konvertierung vom `S` zu `T?`.</span><span class="sxs-lookup"><span data-stu-id="c4e75-318">An explicit conversion from `S` to `T?`.</span></span>
*  <span data-ttu-id="c4e75-319">Eine explizite Konvertierung vom `S?` zu `T`.</span><span class="sxs-lookup"><span data-stu-id="c4e75-319">An explicit conversion from `S?` to `T`.</span></span>

<span data-ttu-id="c4e75-320">Auswertung von eine auf NULL festlegbare Konvertierung basierend auf eine zugrunde liegende Konvertierung von `S` zu `T` wird wie folgt:</span><span class="sxs-lookup"><span data-stu-id="c4e75-320">Evaluation of a nullable conversion based on an underlying conversion from `S` to `T` proceeds as follows:</span></span>

*  <span data-ttu-id="c4e75-321">Wenn eine auf NULL festlegbare Konvertierung von `S?` zu `T?`:</span><span class="sxs-lookup"><span data-stu-id="c4e75-321">If the nullable conversion is from `S?` to `T?`:</span></span>
    * <span data-ttu-id="c4e75-322">Wenn der Quellwert null ist (`HasValue` Eigenschaft ist "false"), das Ergebnis ist der null-Wert des Typs `T?`.</span><span class="sxs-lookup"><span data-stu-id="c4e75-322">If the source value is null (`HasValue` property is false), the result is the null value of type `T?`.</span></span>
    * <span data-ttu-id="c4e75-323">Andernfalls wird die Konvertierung ausgewertet, als ein Entpacken von `S?` zu `S`, gefolgt von der zugrunde liegenden Konvertierung von `S` zu `T`, gefolgt von einer Wrapping von `T` zu `T?`.</span><span class="sxs-lookup"><span data-stu-id="c4e75-323">Otherwise, the conversion is evaluated as an unwrapping from `S?` to `S`, followed by the underlying conversion from `S` to `T`, followed by a wrapping from `T` to `T?`.</span></span>
*  <span data-ttu-id="c4e75-324">Wenn eine auf NULL festlegbare Konvertierung von `S` zu `T?`, die Konvertierung wird ausgewertet, als die zugrunde liegenden Konvertierung von `S` zu `T` gefolgt von einem Textumbruch aus `T` zu `T?`.</span><span class="sxs-lookup"><span data-stu-id="c4e75-324">If the nullable conversion is from `S` to `T?`, the conversion is evaluated as the underlying conversion from `S` to `T` followed by a wrapping from `T` to `T?`.</span></span>
*  <span data-ttu-id="c4e75-325">Wenn eine auf NULL festlegbare Konvertierung von `S?` zu `T`, die Konvertierung wird als ein Entpacken von ausgewertet `S?` zu `S` gefolgt von der zugrunde liegenden Konvertierung von `S` zu `T`.</span><span class="sxs-lookup"><span data-stu-id="c4e75-325">If the nullable conversion is from `S?` to `T`, the conversion is evaluated as an unwrapping from `S?` to `S` followed by the underlying conversion from `S` to `T`.</span></span>

<span data-ttu-id="c4e75-326">Beachten Sie, dass der Versuch, einen NULL-Wert zu entpacken eine Ausnahme auslöst, wenn der Wert ist `null`.</span><span class="sxs-lookup"><span data-stu-id="c4e75-326">Note that an attempt to unwrap a nullable value will throw an exception if the value is `null`.</span></span>

### <a name="explicit-reference-conversions"></a><span data-ttu-id="c4e75-327">Explizite Konvertierungen</span><span class="sxs-lookup"><span data-stu-id="c4e75-327">Explicit reference conversions</span></span>

<span data-ttu-id="c4e75-328">Die explizite Konvertierungen sind:</span><span class="sxs-lookup"><span data-stu-id="c4e75-328">The explicit reference conversions are:</span></span>

*  <span data-ttu-id="c4e75-329">Von `object` und `dynamic` auch einer beliebigen anderen *Reference_type*.</span><span class="sxs-lookup"><span data-stu-id="c4e75-329">From `object` and `dynamic` to any other *reference_type*.</span></span>
*  <span data-ttu-id="c4e75-330">Von jedem *Class_type* `S` auf *Class_type* `T`, bereitgestellt wird, `S` ist eine Basisklasse von `T`.</span><span class="sxs-lookup"><span data-stu-id="c4e75-330">From any *class_type* `S` to any *class_type* `T`, provided `S` is a base class of `T`.</span></span>
*  <span data-ttu-id="c4e75-331">Von jedem *Class_type* `S` auf *Interface_type* `T`, bereitgestellt wird, `S` ist nicht versiegelt ist und `S` implementiert nicht `T`.</span><span class="sxs-lookup"><span data-stu-id="c4e75-331">From any *class_type* `S` to any *interface_type* `T`, provided `S` is not sealed and provided `S` does not implement `T`.</span></span>
*  <span data-ttu-id="c4e75-332">Von jedem *Interface_type* `S` auf *Class_type* `T`aus `T` ist nicht versiegelt oder bereitgestellt `T` implementiert `S`.</span><span class="sxs-lookup"><span data-stu-id="c4e75-332">From any *interface_type* `S` to any *class_type* `T`, provided `T` is not sealed or provided `T` implements `S`.</span></span>
*  <span data-ttu-id="c4e75-333">Von jedem *Interface_type* `S` auf *Interface_type* `T`aus `S` stammt nicht aus `T`.</span><span class="sxs-lookup"><span data-stu-id="c4e75-333">From any *interface_type* `S` to any *interface_type* `T`, provided `S` is not derived from `T`.</span></span>
*  <span data-ttu-id="c4e75-334">Aus einer *Array_type* `S` mit einem Elementtyp `SE` auf eine *Array_type* `T` mit einem Elementtyp `TE`, sofern alle der folgenden Bedingungen erfüllt sind:</span><span class="sxs-lookup"><span data-stu-id="c4e75-334">From an *array_type* `S` with an element type `SE` to an *array_type* `T` with an element type `TE`, provided all of the following are true:</span></span>
    * <span data-ttu-id="c4e75-335">`S` und `T` unterscheiden sich nur hinsichtlich der Elementtyp.</span><span class="sxs-lookup"><span data-stu-id="c4e75-335">`S` and `T` differ only in element type.</span></span> <span data-ttu-id="c4e75-336">Das heißt, `S` und `T` haben die gleiche Anzahl von Dimensionen.</span><span class="sxs-lookup"><span data-stu-id="c4e75-336">In other words, `S` and `T` have the same number of dimensions.</span></span>
    * <span data-ttu-id="c4e75-337">Beide `SE` und `TE` sind *Reference_type*s.</span><span class="sxs-lookup"><span data-stu-id="c4e75-337">Both `SE` and `TE` are *reference_type*s.</span></span>
    * <span data-ttu-id="c4e75-338">Eine explizite Konvertierung vorhanden ist, von `SE` zu `TE`.</span><span class="sxs-lookup"><span data-stu-id="c4e75-338">An explicit reference conversion exists from `SE` to `TE`.</span></span>
*  <span data-ttu-id="c4e75-339">Von `System.Array` und die Schnittstellen implementiert, alle *Array_type*.</span><span class="sxs-lookup"><span data-stu-id="c4e75-339">From `System.Array` and the interfaces it implements to any *array_type*.</span></span>
*  <span data-ttu-id="c4e75-340">Aus einem eindimensionalen Array-Typ `S[]` zu `System.Collections.Generic.IList<T>` und die Basisschnittstellen, vorausgesetzt, es gibt eine explizite Konvertierung von `S` zu `T`.</span><span class="sxs-lookup"><span data-stu-id="c4e75-340">From a single-dimensional array type `S[]` to `System.Collections.Generic.IList<T>` and its base interfaces, provided that there is an explicit reference conversion from `S` to `T`.</span></span>
*  <span data-ttu-id="c4e75-341">Von `System.Collections.Generic.IList<S>` und Basis Schnittstellen verwenden, um einen eindimensionalen Arraytyp `T[]`, vorausgesetzt, es gibt eine explizite Identitäts- oder verweiskonvertierung aus `S` zu `T`.</span><span class="sxs-lookup"><span data-stu-id="c4e75-341">From `System.Collections.Generic.IList<S>` and its base interfaces to a single-dimensional array type `T[]`, provided that there is an explicit identity or reference conversion from `S` to `T`.</span></span>
*  <span data-ttu-id="c4e75-342">Von `System.Delegate` und die Schnittstellen implementiert, alle *Delegate_type*.</span><span class="sxs-lookup"><span data-stu-id="c4e75-342">From `System.Delegate` and the interfaces it implements to any *delegate_type*.</span></span>
*  <span data-ttu-id="c4e75-343">Von einem Referenztyp in einen Verweistyp `T` , wenn sie eine explizite Konvertierung in einen Verweistyp hat `T0` und `T0` verfügt über eine identitätskonvertierung `T`.</span><span class="sxs-lookup"><span data-stu-id="c4e75-343">From a reference type to a reference type `T` if it has an explicit reference conversion to a reference type `T0` and `T0` has an identity conversion `T`.</span></span>
*  <span data-ttu-id="c4e75-344">Von einem Referenztyp zu einem Typ von Schnittstellen oder Delegate `T` verfügt eine explizite Konvertierung in einen Typ von Schnittstellen oder Delegate `T0` und entweder `T0` ist varianzkonvertierbar zu `T` oder `T` ist Um varianzkonvertierbar `T0` ([varianzkonvertierungen](interfaces.md#variance-conversion)).</span><span class="sxs-lookup"><span data-stu-id="c4e75-344">From a reference type to an interface or delegate type `T` if it has an explicit reference conversion to an interface or delegate type `T0` and either `T0` is variance-convertible to `T` or `T` is variance-convertible to `T0` ([Variance conversion](interfaces.md#variance-conversion)).</span></span>
*  <span data-ttu-id="c4e75-345">Aus `D<S1...Sn>` zu `D<T1...Tn>` , in denen `D<X1...Xn>` ist ein generischer Delegattyp `D<S1...Sn>` ist nicht kompatibel mit oder identisch mit `D<T1...Tn>`, und für jeden Typparameter `Xi` von `D` in der folgenden enthalten:</span><span class="sxs-lookup"><span data-stu-id="c4e75-345">From `D<S1...Sn>` to `D<T1...Tn>` where `D<X1...Xn>` is a generic delegate type, `D<S1...Sn>` is not compatible with or identical to `D<T1...Tn>`, and for each type parameter `Xi` of `D` the following holds:</span></span>
    * <span data-ttu-id="c4e75-346">Wenn `Xi` nicht Variant, klicken Sie dann `Si` ist identisch mit `Ti`.</span><span class="sxs-lookup"><span data-stu-id="c4e75-346">If `Xi` is invariant, then `Si` is identical to `Ti`.</span></span>
    * <span data-ttu-id="c4e75-347">Wenn `Xi` kovariant ist, dann gibt es eine implizite oder explizite Identitäts- oder -Konvertierung von `Si` zu `Ti`.</span><span class="sxs-lookup"><span data-stu-id="c4e75-347">If `Xi` is covariant, then there is an implicit or explicit identity or reference conversion from `Si` to `Ti`.</span></span>
    * <span data-ttu-id="c4e75-348">Wenn `Xi` ist kontravariant `Si` und `Ti` sind identisch oder beide Verweistypen.</span><span class="sxs-lookup"><span data-stu-id="c4e75-348">If `Xi` is contravariant, then `Si` and `Ti` are either identical or both reference types.</span></span>
*  <span data-ttu-id="c4e75-349">Explizite Konvertierungen, die im Zusammenhang mit Typparametern, die bekannt ist, dass Verweistypen sein.</span><span class="sxs-lookup"><span data-stu-id="c4e75-349">Explicit conversions involving type parameters that are known to be reference types.</span></span> <span data-ttu-id="c4e75-350">Weitere Informationen zu expliziten Konvertierungen, die im Zusammenhang mit Typparametern finden Sie unter [explizite Konvertierungen, die im Zusammenhang mit Typparametern](conversions.md#explicit-conversions-involving-type-parameters).</span><span class="sxs-lookup"><span data-stu-id="c4e75-350">For more details on explicit conversions involving type parameters, see [Explicit conversions involving type parameters](conversions.md#explicit-conversions-involving-type-parameters).</span></span>

<span data-ttu-id="c4e75-351">Die explizite Konvertierungen sind Konvertierungen zwischen Verweistypen, die erfordern, stellen Sie sicher, dass sie korrekt sind Überprüfungen zur Laufzeit.</span><span class="sxs-lookup"><span data-stu-id="c4e75-351">The explicit reference conversions are those conversions between reference-types that require run-time checks to ensure they are correct.</span></span>

<span data-ttu-id="c4e75-352">Für eine explizite Konvertierung zur Laufzeit erfolgreich ist, muss der Wert des Quelloperanden `null`, oder der tatsächliche Typ des Objekts, auf die Quelloperanden verweist, muss ein Typ, der durch einen impliziten Verweis in den Zieltyp konvertiert werden kann Konvertierung ([implizite Verweis-](conversions.md#implicit-reference-conversions)) oder Boxing-Konvertierung ([Boxingkonvertierungen](conversions.md#boxing-conversions)).</span><span class="sxs-lookup"><span data-stu-id="c4e75-352">For an explicit reference conversion to succeed at run-time, the value of the source operand must be `null`, or the actual type of the object referenced by the source operand must be a type that can be converted to the destination type by an implicit reference conversion ([Implicit reference conversions](conversions.md#implicit-reference-conversions)) or boxing conversion ([Boxing conversions](conversions.md#boxing-conversions)).</span></span> <span data-ttu-id="c4e75-353">Wenn eine explizite Konvertierung ein Fehler auftritt, eine `System.InvalidCastException` ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="c4e75-353">If an explicit reference conversion fails, a `System.InvalidCastException` is thrown.</span></span>

<span data-ttu-id="c4e75-354">Verweiskonvertierungen, implizite oder explizite, ändern sich nie die referenzielle Identität des Objekts, der konvertiert wird.</span><span class="sxs-lookup"><span data-stu-id="c4e75-354">Reference conversions, implicit or explicit, never change the referential identity of the object being converted.</span></span> <span data-ttu-id="c4e75-355">Das heißt, während referenzkonvertierung den Typ des Verweises ändern kann, ändert es nie den Typ oder Wert des Objekts auf die verwiesen wird.</span><span class="sxs-lookup"><span data-stu-id="c4e75-355">In other words, while a reference conversion may change the type of the reference, it never changes the type or value of the object being referred to.</span></span>

### <a name="unboxing-conversions"></a><span data-ttu-id="c4e75-356">Unboxing-Konvertierungen</span><span class="sxs-lookup"><span data-stu-id="c4e75-356">Unboxing conversions</span></span>

<span data-ttu-id="c4e75-357">Eine unboxing-Konvertierung ermöglicht einen Verweistyp explizit zu konvertierenden eine *Value_type*.</span><span class="sxs-lookup"><span data-stu-id="c4e75-357">An unboxing conversion permits a reference type to be explicitly converted to a *value_type*.</span></span> <span data-ttu-id="c4e75-358">Eine unboxing-Konvertierung vorhanden ist, von den Typen `object`, `dynamic` und `System.ValueType` auf *Non_nullable_value_type*, und von jedem *Interface_type* auf *Non_ Nullable_value_type* , implementiert die *Interface_type*.</span><span class="sxs-lookup"><span data-stu-id="c4e75-358">An unboxing conversion exists from the types `object`, `dynamic` and `System.ValueType` to any *non_nullable_value_type*, and from any *interface_type* to any *non_nullable_value_type* that implements the *interface_type*.</span></span> <span data-ttu-id="c4e75-359">Geben Sie außerdem `System.Enum` kann nicht auf eine geschachtelte sein *Enum_type*.</span><span class="sxs-lookup"><span data-stu-id="c4e75-359">Furthermore type `System.Enum` can be unboxed to any *enum_type*.</span></span>

<span data-ttu-id="c4e75-360">Eine unboxing-Konvertierung vorhanden ist, von einem Referenztyp zu einem *Nullable_type* Falls von den Verweistyp eine unboxing-Konvertierung vorhanden, auf die zugrunde liegende ist *Non_nullable_value_type* von der  *Nullable_type*.</span><span class="sxs-lookup"><span data-stu-id="c4e75-360">An unboxing conversion exists from a reference type to a *nullable_type* if an unboxing conversion exists from the reference type to the underlying *non_nullable_value_type* of the *nullable_type*.</span></span>

<span data-ttu-id="c4e75-361">Ein Werttyp `S` eine unboxing-Konvertierung eines Schnittstellentyps hat `I` , wenn sie eine unboxing-Konvertierung eines Schnittstellentyps hat `I0` und `I0` verfügt über eine identitätskonvertierung in `I`.</span><span class="sxs-lookup"><span data-stu-id="c4e75-361">A value type `S` has an unboxing conversion from an interface type `I` if it has an unboxing conversion from an interface type `I0` and `I0` has an identity conversion to `I`.</span></span>

<span data-ttu-id="c4e75-362">Ein Werttyp `S` eine unboxing-Konvertierung eines Schnittstellentyps hat `I` verfügt eine unboxing-Konvertierung von einem Typ von Schnittstellen oder Delegate `I0` und entweder `I0` ist varianzkonvertierbar zu `I` oder `I`ist varianzkonvertierbar zu `I0` ([varianzkonvertierungen](interfaces.md#variance-conversion)).</span><span class="sxs-lookup"><span data-stu-id="c4e75-362">A value type `S` has an unboxing conversion from an interface type `I` if it has an unboxing conversion from an interface or delegate type `I0` and either `I0` is variance-convertible to `I` or `I` is variance-convertible to `I0` ([Variance conversion](interfaces.md#variance-conversion)).</span></span>

<span data-ttu-id="c4e75-363">Zunächst geprüft wird, die einen geschachtelten Wert eines der Objekttyp ist ein unboxing-Vorgang besteht aus den angegebenen *Value_type*, und klicken Sie dann kopieren den Wert aus der Instanz.</span><span class="sxs-lookup"><span data-stu-id="c4e75-363">An unboxing operation consists of first checking that the object instance is a boxed value of the given *value_type*, and then copying the value out of the instance.</span></span> <span data-ttu-id="c4e75-364">Unboxing einen null-Verweis auf eine *Nullable_type* erzeugt den null-Wert von der *Nullable_type*.</span><span class="sxs-lookup"><span data-stu-id="c4e75-364">Unboxing a null reference to a *nullable_type* produces the null value of the *nullable_type*.</span></span> <span data-ttu-id="c4e75-365">Eine Struktur kann nicht vom Typ geschachtelte sein `System.ValueType`, da dies eine Basisklasse für alle Strukturen ist ([Vererbung](structs.md#inheritance)).</span><span class="sxs-lookup"><span data-stu-id="c4e75-365">A struct can be unboxed from the type `System.ValueType`, since that is a base class for all structs ([Inheritance](structs.md#inheritance)).</span></span>

<span data-ttu-id="c4e75-366">Unboxing-Konvertierungen werden ausführlich in [Unboxing-Konvertierungen](types.md#unboxing-conversions).</span><span class="sxs-lookup"><span data-stu-id="c4e75-366">Unboxing conversions are described further in [Unboxing conversions](types.md#unboxing-conversions).</span></span>

### <a name="explicit-dynamic-conversions"></a><span data-ttu-id="c4e75-367">Explizite dynamische Konvertierungen</span><span class="sxs-lookup"><span data-stu-id="c4e75-367">Explicit dynamic conversions</span></span>

<span data-ttu-id="c4e75-368">Eine explizite Konvertierung für die dynamische vorhanden ist, von einem Ausdruck vom Typ `dynamic` auf einen beliebigen Typ `T`.</span><span class="sxs-lookup"><span data-stu-id="c4e75-368">An explicit dynamic conversion exists from an expression of type `dynamic` to any type `T`.</span></span> <span data-ttu-id="c4e75-369">Die Konvertierung dynamisch gebunden ist ([dynamische Bindung](expressions.md#dynamic-binding)), was bedeutet, dass eine explizite Konvertierung zur Laufzeit von der Runtime-Typ des Ausdrucks, der gesucht werden soll, wird `T`.</span><span class="sxs-lookup"><span data-stu-id="c4e75-369">The conversion is dynamically bound ([Dynamic binding](expressions.md#dynamic-binding)), which means that an explicit conversion will be sought at run-time from the run-time type of the expression to `T`.</span></span> <span data-ttu-id="c4e75-370">Wenn keine Konvertierung gefunden wird, wird eine Laufzeitausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="c4e75-370">If no conversion is found, a run-time exception is thrown.</span></span>

<span data-ttu-id="c4e75-371">Wenn die dynamische Bindung für die Konvertierung nicht gewünscht ist, der Ausdruck konvertiert werden kann zunächst `object`, und klicken Sie dann den gewünschten Typ.</span><span class="sxs-lookup"><span data-stu-id="c4e75-371">If dynamic binding of the conversion is not desired, the expression can be first converted to `object`, and then to the desired type.</span></span>

<span data-ttu-id="c4e75-372">Angenommen Sie, die folgende Klasse definiert ist:</span><span class="sxs-lookup"><span data-stu-id="c4e75-372">Assume the following class is defined:</span></span>
```csharp
class C
{
    int i;

    public C(int i) { this.i = i; }

    public static explicit operator C(string s) 
    {
        return new C(int.Parse(s));
    }
}
```

<span data-ttu-id="c4e75-373">Das folgende Beispiel veranschaulicht die explizite dynamische Konvertierungen:</span><span class="sxs-lookup"><span data-stu-id="c4e75-373">The following example illustrates explicit dynamic conversions:</span></span>
```csharp
object o  = "1";
dynamic d = "2";

var c1 = (C)o; // Compiles, but explicit reference conversion fails
var c2 = (C)d; // Compiles and user defined conversion succeeds
```

<span data-ttu-id="c4e75-374">Die beste Konvertierung `o` zu `C` befindet sich zum Zeitpunkt der Kompilierung einer expliziten verweiskonvertierung sein.</span><span class="sxs-lookup"><span data-stu-id="c4e75-374">The best conversion of `o` to `C` is found at compile-time to be an explicit reference conversion.</span></span> <span data-ttu-id="c4e75-375">Zur Laufzeit, nicht, da `"1"` ist nicht in der Tat ein `C`.</span><span class="sxs-lookup"><span data-stu-id="c4e75-375">This fails at run-time, because `"1"` is not in fact a `C`.</span></span> <span data-ttu-id="c4e75-376">Die Konvertierung von `d` zu `C` jedoch als eine explizite Konvertierung dynamische wird angehalten, Laufzeit, in denen ein Konvertierung von der Laufzeit-Typinformationen von benutzerdefinierter `d`  --  `string` – zu `C` gefunden wird, und was nicht.</span><span class="sxs-lookup"><span data-stu-id="c4e75-376">The conversion of `d` to `C` however, as an explicit dynamic conversion, is suspended to run-time, where a user defined conversion from the run-time type of `d` -- `string` -- to `C` is found, and succeeds.</span></span>

### <a name="explicit-conversions-involving-type-parameters"></a><span data-ttu-id="c4e75-377">Explizite Konvertierungen, die im Zusammenhang mit Typparametern</span><span class="sxs-lookup"><span data-stu-id="c4e75-377">Explicit conversions involving type parameters</span></span>

<span data-ttu-id="c4e75-378">Die folgenden expliziten Konvertierungen für einen Parameter angegebenen Typ vorhanden `T`:</span><span class="sxs-lookup"><span data-stu-id="c4e75-378">The following explicit conversions exist for a given type parameter `T`:</span></span>

*  <span data-ttu-id="c4e75-379">Der effektive Basisklasse `C` von `T` zu `T` und von einer Basisklasse von `C` zu `T`.</span><span class="sxs-lookup"><span data-stu-id="c4e75-379">From the effective base class `C` of `T` to `T` and from any base class of `C` to `T`.</span></span> <span data-ttu-id="c4e75-380">AT-Laufzeit-If `T` ein Werttyp ist, als einer unboxing-Konvertierung die Konvertierung ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="c4e75-380">At run-time, if `T` is a value type, the conversion is executed as an unboxing conversion.</span></span> <span data-ttu-id="c4e75-381">Andernfalls wird die Konvertierung als explizite Konvertierung oder identitätskonvertierung ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="c4e75-381">Otherwise, the conversion is executed as an explicit reference conversion or identity conversion.</span></span>
*  <span data-ttu-id="c4e75-382">Über einen beliebigen anderen Schnittstellentyp, `T`.</span><span class="sxs-lookup"><span data-stu-id="c4e75-382">From any interface type to `T`.</span></span> <span data-ttu-id="c4e75-383">AT-Laufzeit-If `T` ein Werttyp ist, als einer unboxing-Konvertierung die Konvertierung ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="c4e75-383">At run-time, if `T` is a value type, the conversion is executed as an unboxing conversion.</span></span> <span data-ttu-id="c4e75-384">Andernfalls wird die Konvertierung als explizite Konvertierung oder identitätskonvertierung ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="c4e75-384">Otherwise, the conversion is executed as an explicit reference conversion or identity conversion.</span></span>
*  <span data-ttu-id="c4e75-385">Von `T` auf *Interface_type* `I` vorausgesetzt, es ist nicht bereits eine implizite Konvertierung von `T` zu `I`.</span><span class="sxs-lookup"><span data-stu-id="c4e75-385">From `T` to any *interface_type* `I` provided there is not already an implicit conversion from `T` to `I`.</span></span> <span data-ttu-id="c4e75-386">AT-Laufzeit-If `T` ein Werttyp handelt, wird die Konvertierung wird als ein Boxing-Konvertierung, gefolgt von einer expliziten verweiskonvertierung ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="c4e75-386">At run-time, if `T` is a value type, the conversion is executed as a boxing conversion followed by an explicit reference conversion.</span></span> <span data-ttu-id="c4e75-387">Andernfalls wird die Konvertierung als explizite Konvertierung oder identitätskonvertierung ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="c4e75-387">Otherwise, the conversion is executed as an explicit reference conversion or identity conversion.</span></span>
*  <span data-ttu-id="c4e75-388">Von einem Typparameter `U` zu `T`aus `T` hängt `U` ([Geben Sie die Einschränkungen für Typparameter](classes.md#type-parameter-constraints)).</span><span class="sxs-lookup"><span data-stu-id="c4e75-388">From a type parameter `U` to `T`, provided `T` depends on `U` ([Type parameter constraints](classes.md#type-parameter-constraints)).</span></span> <span data-ttu-id="c4e75-389">AT-Laufzeit-If `U` ein Werttyp ist, klicken Sie dann `T` und `U` unbedingt den gleichen Typ aufweisen und wird keine Konvertierung durchgeführt.</span><span class="sxs-lookup"><span data-stu-id="c4e75-389">At run-time, if `U` is a value type, then `T` and `U` are necessarily the same type and no conversion is performed.</span></span> <span data-ttu-id="c4e75-390">Andernfalls gilt: Wenn `T` ein Werttyp ist, als einer unboxing-Konvertierung die Konvertierung ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="c4e75-390">Otherwise, if `T` is a value type, the conversion is executed as an unboxing conversion.</span></span> <span data-ttu-id="c4e75-391">Andernfalls wird die Konvertierung als explizite Konvertierung oder identitätskonvertierung ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="c4e75-391">Otherwise, the conversion is executed as an explicit reference conversion or identity conversion.</span></span>

<span data-ttu-id="c4e75-392">Wenn `T` ist bekannt, die ein Verweistyp sein muss, die oben genannten Konvertierungen sind alle klassifiziert als explizite Konvertierungen ([explizite Konvertierungen](conversions.md#explicit-reference-conversions)).</span><span class="sxs-lookup"><span data-stu-id="c4e75-392">If `T` is known to be a reference type, the conversions above are all classified as explicit reference conversions ([Explicit reference conversions](conversions.md#explicit-reference-conversions)).</span></span> <span data-ttu-id="c4e75-393">Wenn `T` ist nicht bekannt ist, ein Verweistyp sein muss, sind die Konvertierungen, die höher als unboxing-Konvertierungen klassifiziert ([Unboxing-Konvertierungen](conversions.md#unboxing-conversions)).</span><span class="sxs-lookup"><span data-stu-id="c4e75-393">If `T` is not known to be a reference type, the conversions above are classified as unboxing conversions ([Unboxing conversions](conversions.md#unboxing-conversions)).</span></span>

<span data-ttu-id="c4e75-394">Die oben genannten Regeln lassen keine direkte explizite Konvertierung von einer nicht eingeschränkten Typparameter auf einen Typ Nichtschnittstellen-überraschend sein kann.</span><span class="sxs-lookup"><span data-stu-id="c4e75-394">The above rules do not permit a direct explicit conversion from an unconstrained type parameter to a non-interface type, which might be surprising.</span></span> <span data-ttu-id="c4e75-395">Der Grund für diese Regel ist Verwechslungen und die Semantik der solche Konvertierungen deaktivieren.</span><span class="sxs-lookup"><span data-stu-id="c4e75-395">The reason for this rule is to prevent confusion and make the semantics of such conversions clear.</span></span> <span data-ttu-id="c4e75-396">Betrachten Sie beispielsweise die folgende Deklaration:</span><span class="sxs-lookup"><span data-stu-id="c4e75-396">For example, consider the following declaration:</span></span>
```csharp
class X<T>
{
    public static long F(T t) {
        return (long)t;                // Error 
    }
}
```

<span data-ttu-id="c4e75-397">Wenn die direkte explizite Konvertierung `t` zu `int` erteilt wurden, wird einfach erwartet, `X<int>.F(7)` zurück `7L`.</span><span class="sxs-lookup"><span data-stu-id="c4e75-397">If the direct explicit conversion of `t` to `int` were permitted, one might easily expect that `X<int>.F(7)` would return `7L`.</span></span> <span data-ttu-id="c4e75-398">Es wäre jedoch nicht der Fall, da die standardmäßigen numerischen Konvertierungen nur gelten, wenn die Typen bekannt ist, dass zum Zeitpunkt der Bindung numerisch sein.</span><span class="sxs-lookup"><span data-stu-id="c4e75-398">However, it would not, because the standard numeric conversions are only considered when the types are known to be numeric at binding-time.</span></span> <span data-ttu-id="c4e75-399">Um die Semantik machen muss klare und im obige Beispiel stattdessen geschrieben werden:</span><span class="sxs-lookup"><span data-stu-id="c4e75-399">In order to make the semantics clear, the above example must instead be written:</span></span>
```csharp
class X<T>
{
    public static long F(T t) {
        return (long)(object)t;        // Ok, but will only work when T is long
    }
}
```

<span data-ttu-id="c4e75-400">Dieser Code kompiliert aber ausgeführten `X<int>.F(7)` würde dann eine Ausnahme zur Laufzeit, da eine geschachtelte `int` kann nicht direkt konvertiert werden eine `long`.</span><span class="sxs-lookup"><span data-stu-id="c4e75-400">This code will now compile but executing `X<int>.F(7)` would then throw an exception at run-time, since a boxed `int` cannot be converted directly to a `long`.</span></span>

### <a name="user-defined-explicit-conversions"></a><span data-ttu-id="c4e75-401">Benutzerdefinierte explizite Konvertierungen</span><span class="sxs-lookup"><span data-stu-id="c4e75-401">User-defined explicit conversions</span></span>

<span data-ttu-id="c4e75-402">Eine explizite Konvertierung von benutzerdefinierten umfasst eine optionale standard explizite Konvertierung, gefolgt von der Ausführung eines benutzerdefinierten impliziten oder expliziten Konvertierungsoperators, gefolgt von einem anderen optionalen standard explizite Konvertierung.</span><span class="sxs-lookup"><span data-stu-id="c4e75-402">A user-defined explicit conversion consists of an optional standard explicit conversion, followed by execution of a user-defined implicit or explicit conversion operator, followed by another optional standard explicit conversion.</span></span> <span data-ttu-id="c4e75-403">Die genauen Regeln für Ihre Evaluierung von benutzerdefinierten explizite Konvertierungen werden in beschrieben [expliziter Konvertierungen eine benutzerdefinierte Verarbeitung](conversions.md#processing-of-user-defined-explicit-conversions).</span><span class="sxs-lookup"><span data-stu-id="c4e75-403">The exact rules for evaluating user-defined explicit conversions are described in [Processing of user-defined explicit conversions](conversions.md#processing-of-user-defined-explicit-conversions).</span></span>

## <a name="standard-conversions"></a><span data-ttu-id="c4e75-404">Standardkonvertierungen</span><span class="sxs-lookup"><span data-stu-id="c4e75-404">Standard conversions</span></span>

<span data-ttu-id="c4e75-405">Die standard-Konvertierungen sind Konvertierungen vorab definierten, die als Teil einer benutzerdefinierten Konvertierung auftreten können.</span><span class="sxs-lookup"><span data-stu-id="c4e75-405">The standard conversions are those pre-defined conversions that can occur as part of a user-defined conversion.</span></span>

### <a name="standard-implicit-conversions"></a><span data-ttu-id="c4e75-406">Standard implizite Konvertierungen</span><span class="sxs-lookup"><span data-stu-id="c4e75-406">Standard implicit conversions</span></span>

<span data-ttu-id="c4e75-407">Die folgenden implizite Konvertierungen werden als implizite standardkonvertierungen klassifiziert:</span><span class="sxs-lookup"><span data-stu-id="c4e75-407">The following implicit conversions are classified as standard implicit conversions:</span></span>

*  <span data-ttu-id="c4e75-408">Identity-Konvertierungen ([identitätskonvertierung](conversions.md#identity-conversion))</span><span class="sxs-lookup"><span data-stu-id="c4e75-408">Identity conversions ([Identity conversion](conversions.md#identity-conversion))</span></span>
*  <span data-ttu-id="c4e75-409">Implizite numerische Konvertierungen ([implizite numerische Konvertierungen](conversions.md#implicit-numeric-conversions))</span><span class="sxs-lookup"><span data-stu-id="c4e75-409">Implicit numeric conversions ([Implicit numeric conversions](conversions.md#implicit-numeric-conversions))</span></span>
*  <span data-ttu-id="c4e75-410">Konvertierungen für implizite NULL-Werte zulässt ([implizite NULL-Werte zulassen Konvertierungen](conversions.md#implicit-nullable-conversions))</span><span class="sxs-lookup"><span data-stu-id="c4e75-410">Implicit nullable conversions ([Implicit nullable conversions](conversions.md#implicit-nullable-conversions))</span></span>
*  <span data-ttu-id="c4e75-411">Implizite verweiskonvertierungen ([implizite Verweis-](conversions.md#implicit-reference-conversions))</span><span class="sxs-lookup"><span data-stu-id="c4e75-411">Implicit reference conversions ([Implicit reference conversions](conversions.md#implicit-reference-conversions))</span></span>
*  <span data-ttu-id="c4e75-412">Boxing-Konvertierung ([Boxingkonvertierungen](conversions.md#boxing-conversions))</span><span class="sxs-lookup"><span data-stu-id="c4e75-412">Boxing conversions ([Boxing conversions](conversions.md#boxing-conversions))</span></span>
*  <span data-ttu-id="c4e75-413">Implizite konstanter Ausdruck-Konvertierungen ([implizite dynamische Konvertierungen](conversions.md#implicit-dynamic-conversions))</span><span class="sxs-lookup"><span data-stu-id="c4e75-413">Implicit constant expression conversions ([Implicit dynamic conversions](conversions.md#implicit-dynamic-conversions))</span></span>
*  <span data-ttu-id="c4e75-414">Implizite Konvertierungen, die im Zusammenhang mit Typparametern ([implizite Konvertierungen, die im Zusammenhang mit Typparametern](conversions.md#implicit-conversions-involving-type-parameters))</span><span class="sxs-lookup"><span data-stu-id="c4e75-414">Implicit conversions involving type parameters ([Implicit conversions involving type parameters](conversions.md#implicit-conversions-involving-type-parameters))</span></span>

<span data-ttu-id="c4e75-415">Die implizite standardkonvertierungen schließen insbesondere benutzerdefinierte implizite Konvertierungen aus.</span><span class="sxs-lookup"><span data-stu-id="c4e75-415">The standard implicit conversions specifically exclude user-defined implicit conversions.</span></span>

### <a name="standard-explicit-conversions"></a><span data-ttu-id="c4e75-416">Standard explizite Konvertierungen</span><span class="sxs-lookup"><span data-stu-id="c4e75-416">Standard explicit conversions</span></span>

<span data-ttu-id="c4e75-417">Die standardmäßige explizite Konvertierungen sind alle standardmäßigen implizite Konvertierungen sowie die Teilmenge der explizite Konvertierungen für die eine umgekehrte standard implizite Konvertierung vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="c4e75-417">The standard explicit conversions are all standard implicit conversions plus the subset of the explicit conversions for which an opposite standard implicit conversion exists.</span></span> <span data-ttu-id="c4e75-418">Das heißt, wenn ein Standard, die implizite Konvertierung vorhanden ist aus einem Typ `A` auf einen Typ `B`, und klicken Sie dann eine standard explizite Konvertierung von Typ vorhanden ist `A` eingeben `B` und vom Typ `B` eingeben `A`.</span><span class="sxs-lookup"><span data-stu-id="c4e75-418">In other words, if a standard implicit conversion exists from a type `A` to a type `B`, then a standard explicit conversion exists from type `A` to type `B` and from type `B` to type `A`.</span></span>

## <a name="user-defined-conversions"></a><span data-ttu-id="c4e75-419">Benutzerdefinierte Konvertierungen</span><span class="sxs-lookup"><span data-stu-id="c4e75-419">User-defined conversions</span></span>

<span data-ttu-id="c4e75-420">In C# können Sie die vordefinierten impliziten und expliziten Konvertierungen von ergänzt werden ***benutzerdefinierte Konvertierungen***.</span><span class="sxs-lookup"><span data-stu-id="c4e75-420">C# allows the pre-defined implicit and explicit conversions to be augmented by ***user-defined conversions***.</span></span> <span data-ttu-id="c4e75-421">Benutzerdefinierte Konvertierungen werden eingeführt, durch das Deklarieren von Konvertierungsoperatoren ([Konvertierungsoperatoren](classes.md#conversion-operators)) in der Klasse und Strukturtypen.</span><span class="sxs-lookup"><span data-stu-id="c4e75-421">User-defined conversions are introduced by declaring conversion operators ([Conversion operators](classes.md#conversion-operators)) in class and struct types.</span></span>

### <a name="permitted-user-defined-conversions"></a><span data-ttu-id="c4e75-422">Benutzerdefinierte Konvertierungen zulässig</span><span class="sxs-lookup"><span data-stu-id="c4e75-422">Permitted user-defined conversions</span></span>

<span data-ttu-id="c4e75-423">C# lässt nur bestimmte benutzerdefinierte Konvertierungen deklariert werden.</span><span class="sxs-lookup"><span data-stu-id="c4e75-423">C# permits only certain user-defined conversions to be declared.</span></span> <span data-ttu-id="c4e75-424">Insbesondere ist es nicht möglich, eine bereits vorhandene implizite oder explizite Konvertierung neu definieren.</span><span class="sxs-lookup"><span data-stu-id="c4e75-424">In particular, it is not possible to redefine an already existing implicit or explicit conversion.</span></span>

<span data-ttu-id="c4e75-425">Für einen bestimmten Quell- `S` und einen Zieltyp `T`, wenn `S` oder `T` werden auf NULL festlegbare Typen können `S0` und `T0` finden Sie in die zugrunde liegende Typen, andernfalls `S0` und `T0` sind gleich `S` und `T` bzw.</span><span class="sxs-lookup"><span data-stu-id="c4e75-425">For a given source type `S` and target type `T`, if `S` or `T` are nullable types, let `S0` and `T0` refer to their underlying types, otherwise `S0` and `T0` are equal to `S` and `T` respectively.</span></span> <span data-ttu-id="c4e75-426">Eine Klasse oder Struktur ist zulässig, deklarieren Sie eine Konvertierung aus einer Datenquelle `S` in einen Zieltyp `T` nur dann, wenn alle der folgenden Bedingungen erfüllt sind:</span><span class="sxs-lookup"><span data-stu-id="c4e75-426">A class or struct is permitted to declare a conversion from a source type `S` to a target type `T` only if all of the following are true:</span></span>

*  <span data-ttu-id="c4e75-427">`S0` und `T0` gibt verschiedene Typen.</span><span class="sxs-lookup"><span data-stu-id="c4e75-427">`S0` and `T0` are different types.</span></span>
*  <span data-ttu-id="c4e75-428">Entweder `S0` oder `T0` ist der Typ Klasse oder Struktur, die in der die Operatordeklaration erfolgt.</span><span class="sxs-lookup"><span data-stu-id="c4e75-428">Either `S0` or `T0` is the class or struct type in which the operator declaration takes place.</span></span>
*  <span data-ttu-id="c4e75-429">Weder `S0` noch `T0` ist ein *Interface_type*.</span><span class="sxs-lookup"><span data-stu-id="c4e75-429">Neither `S0` nor `T0` is an *interface_type*.</span></span>
*  <span data-ttu-id="c4e75-430">Mit Ausnahme von benutzerdefinierten Konvertierungen, eine Konvertierung ist nicht vom `S` zu `T` oder `T` zu `S`.</span><span class="sxs-lookup"><span data-stu-id="c4e75-430">Excluding user-defined conversions, a conversion does not exist from `S` to `T` or from `T` to `S`.</span></span>

<span data-ttu-id="c4e75-431">Die Einschränkungen für benutzerdefinierte Konvertierungen werden erläutert. im weiteren [Konvertierungsoperatoren](classes.md#conversion-operators).</span><span class="sxs-lookup"><span data-stu-id="c4e75-431">The restrictions that apply to user-defined conversions are discussed further in [Conversion operators](classes.md#conversion-operators).</span></span>

### <a name="lifted-conversion-operators"></a><span data-ttu-id="c4e75-432">Transformierten Konvertierungsoperatoren</span><span class="sxs-lookup"><span data-stu-id="c4e75-432">Lifted conversion operators</span></span>

<span data-ttu-id="c4e75-433">Erhalten einen benutzerdefinierten Konvertierungsoperator, der von einem Typ NULL-Werte konvertiert `S` auf einen NULL-Werttyp `T`, ***angehoben Konvertierungsoperator*** vorhanden ist, konvertiert in `S?` zu `T?`.</span><span class="sxs-lookup"><span data-stu-id="c4e75-433">Given a user-defined conversion operator that converts from a non-nullable value type `S` to a non-nullable value type `T`, a ***lifted conversion operator*** exists that converts from `S?` to `T?`.</span></span> <span data-ttu-id="c4e75-434">Dieser transformierten Konvertierungsoperator führt eine Entpacken von `S?` zu `S` gefolgt von der eine benutzerdefinierte Konvertierung von `S` zu `T` gefolgt von einer Wrapping von `T` zu `T?`, außer dass ein NULL-Wert Valued `S?` wandelt den Wert Null direkt `T?`.</span><span class="sxs-lookup"><span data-stu-id="c4e75-434">This lifted conversion operator performs an unwrapping from `S?` to `S` followed by the user-defined conversion from `S` to `T` followed by a wrapping from `T` to `T?`, except that a null valued `S?` converts directly to a null valued `T?`.</span></span>

<span data-ttu-id="c4e75-435">Ein Konvertierungsoperator für die transformierten hat die gleiche implizite oder explizite-Klassifizierung als die zugrunde liegenden benutzerdefinierten Konvertierungsoperator.</span><span class="sxs-lookup"><span data-stu-id="c4e75-435">A lifted conversion operator has the same implicit or explicit classification as its underlying user-defined conversion operator.</span></span> <span data-ttu-id="c4e75-436">Der Begriff, die die Verwendung von "benutzerdefinierte Konvertierung" gilt eine benutzerdefinierte und Konvertierungsoperatoren aufgehoben.</span><span class="sxs-lookup"><span data-stu-id="c4e75-436">The term "user-defined conversion" applies to the use of both user-defined and lifted conversion operators.</span></span>

### <a name="evaluation-of-user-defined-conversions"></a><span data-ttu-id="c4e75-437">Auswertung von benutzerdefinierten Konvertierungen</span><span class="sxs-lookup"><span data-stu-id="c4e75-437">Evaluation of user-defined conversions</span></span>

<span data-ttu-id="c4e75-438">Eine benutzerdefinierte Konvertierung konvertiert einen Wert als der Typ, dem Namen der ***Quelltyp***, einen anderen Typ, mit dem Namen der ***Zieltyp***.</span><span class="sxs-lookup"><span data-stu-id="c4e75-438">A user-defined conversion converts a value from its type, called the ***source type***, to another type, called the ***target type***.</span></span> <span data-ttu-id="c4e75-439">Auswertung von einer benutzerdefinierten Konvertierung konzentriert sich auf Suchen der ***spezifischste*** benutzerdefinierten Konvertierungsoperator für die bestimmten Typen von Quelle und Ziel.</span><span class="sxs-lookup"><span data-stu-id="c4e75-439">Evaluation of a user-defined conversion centers on finding the ***most specific*** user-defined conversion operator for the particular source and target types.</span></span> <span data-ttu-id="c4e75-440">Diese Ermittlung ist in mehrere Schritte unterteilt:</span><span class="sxs-lookup"><span data-stu-id="c4e75-440">This determination is broken into several steps:</span></span>

*  <span data-ttu-id="c4e75-441">Suchen den Satz von Klassen und Strukturen, die von denen benutzerdefinierten Konvertierungsoperatoren betrachtet werden.</span><span class="sxs-lookup"><span data-stu-id="c4e75-441">Finding the set of classes and structs from which user-defined conversion operators will be considered.</span></span> <span data-ttu-id="c4e75-442">Dieser Satz besteht aus den Quelltyp und ihre Basisklassen und den Zieltyp und ihre Basisklassen (mit implizit vorausgesetzt, dass benutzerdefinierte Operatoren nur Klassen und Strukturen deklarieren und nichtklassentypen keine Basisklassen aufweisen).</span><span class="sxs-lookup"><span data-stu-id="c4e75-442">This set consists of the source type and its base classes and the target type and its base classes (with the implicit assumptions that only classes and structs can declare user-defined operators, and that non-class types have no base classes).</span></span> <span data-ttu-id="c4e75-443">Im Rahmen dieser Schritt, wenn entweder die Quell-oder Zieltyp ist eine *Nullable_type*, deren zugrunde liegender Typ wird stattdessen verwendet.</span><span class="sxs-lookup"><span data-stu-id="c4e75-443">For the purposes of this step, if either the source or target type is a *nullable_type*, their underlying type is used instead.</span></span>
*  <span data-ttu-id="c4e75-444">Aus diesem Satz von Typen bestimmen die benutzerdefinierten und Konvertierungsoperatoren aufgehoben gelten.</span><span class="sxs-lookup"><span data-stu-id="c4e75-444">From that set of types, determining which user-defined and lifted conversion operators are applicable.</span></span> <span data-ttu-id="c4e75-445">Für einen Konvertierungsoperator, angewendet werden, es muss möglich sein, eine standardkonvertierung ausführen ([standardkonvertierungen](conversions.md#standard-conversions)) aus einer Datenquelle mit dem Operanden Typ des Operators an, und es muss möglich sein, eine standardkonvertierung ausführen von der Ergebnistyp des Operators, der den Zieltyp.</span><span class="sxs-lookup"><span data-stu-id="c4e75-445">For a conversion operator to be applicable, it must be possible to perform a standard conversion ([Standard conversions](conversions.md#standard-conversions)) from the source type to the operand type of the operator, and it must be possible to perform a standard conversion from the result type of the operator to the target type.</span></span>
*  <span data-ttu-id="c4e75-446">Aus der Gruppe der entsprechenden benutzerdefinierten Operatoren bestimmt der Operator eindeutig am spezifischsten ist.</span><span class="sxs-lookup"><span data-stu-id="c4e75-446">From the set of applicable user-defined operators, determining which operator is unambiguously the most specific.</span></span> <span data-ttu-id="c4e75-447">Allgemein gesagt ist der am genauesten Operator den Operator aus, deren Operandentyp "nächstgelegene" in den Quelltyp und, dessen Ergebnistyp "nächstgelegene" in den Zieltyp ist.</span><span class="sxs-lookup"><span data-stu-id="c4e75-447">In general terms, the most specific operator is the operator whose operand type is "closest" to the source type and whose result type is "closest" to the target type.</span></span> <span data-ttu-id="c4e75-448">Eine benutzerdefinierte Konvertierungsoperatoren werden gegenüber transformierten Konvertierungsoperatoren bevorzugt.</span><span class="sxs-lookup"><span data-stu-id="c4e75-448">User-defined conversion operators are preferred over lifted conversion operators.</span></span> <span data-ttu-id="c4e75-449">Die genauen Regeln für die Einrichtung des spezifischsten benutzerdefinierten Konvertierungsoperator werden in den folgenden Abschnitten definiert.</span><span class="sxs-lookup"><span data-stu-id="c4e75-449">The exact rules for establishing the most specific user-defined conversion operator are defined in the following sections.</span></span>

<span data-ttu-id="c4e75-450">Nachdem ein spezifischste benutzerdefinierten Konvertierungsoperator identifiziert wurde, umfasst die eigentliche Ausführung der benutzerdefinierten Konvertierung bis zu drei Schritte aus:</span><span class="sxs-lookup"><span data-stu-id="c4e75-450">Once a most specific user-defined conversion operator has been identified, the actual execution of the user-defined conversion involves up to three steps:</span></span>

*  <span data-ttu-id="c4e75-451">Zuerst bei Bedarf ausführen eine standardkonvertierung von den Quelltyp in der Operandentyp der benutzerdefinierten oder transformierten Konvertierungsoperator.</span><span class="sxs-lookup"><span data-stu-id="c4e75-451">First, if required, performing a standard conversion from the source type to the operand type of the user-defined or lifted conversion operator.</span></span>
*  <span data-ttu-id="c4e75-452">Als Nächstes das Aufrufen des benutzerdefinierten oder transformierten Konvertierungsoperators, um die Konvertierung auszuführen.</span><span class="sxs-lookup"><span data-stu-id="c4e75-452">Next, invoking the user-defined or lifted conversion operator to perform the conversion.</span></span>
*  <span data-ttu-id="c4e75-453">Bei Bedarf ausführen schließlich eine standardkonvertierung von der Ergebnistyp des Operators oder transformierten, eine benutzerdefinierte Konvertierung in den Zieltyp auf.</span><span class="sxs-lookup"><span data-stu-id="c4e75-453">Finally, if required, performing a standard conversion from the result type of the user-defined or lifted conversion operator to the target type.</span></span>

<span data-ttu-id="c4e75-454">Auswertung von nie eine benutzerdefinierte Konvertierung umfasst mehr als eine benutzerdefinierte oder transformierten Konvertierungsoperator.</span><span class="sxs-lookup"><span data-stu-id="c4e75-454">Evaluation of a user-defined conversion never involves more than one user-defined or lifted conversion operator.</span></span> <span data-ttu-id="c4e75-455">Das heißt, eine Konvertierung von Typ `S` eingeben `T` führt niemals zuerst eine benutzerdefinierte Konvertierung von `S` zu `X` und führen Sie dann eine benutzerdefinierte Konvertierung von `X` zu `T`.</span><span class="sxs-lookup"><span data-stu-id="c4e75-455">In other words, a conversion from type `S` to type `T` will never first execute a user-defined conversion from `S` to `X` and then execute a user-defined conversion from `X` to `T`.</span></span>

<span data-ttu-id="c4e75-456">Genaue Definitionen der Auswertung des benutzerdefinierten impliziten oder expliziten Konvertierungen sind in den folgenden Abschnitten enthalten.</span><span class="sxs-lookup"><span data-stu-id="c4e75-456">Exact definitions of evaluation of user-defined implicit or explicit conversions are given in the following sections.</span></span> <span data-ttu-id="c4e75-457">Die Definitionen stellen die folgenden Begriffe verwendet:</span><span class="sxs-lookup"><span data-stu-id="c4e75-457">The definitions make use of the following terms:</span></span>

*  <span data-ttu-id="c4e75-458">Wenn eine implizite standardkonvertierung ([Standard implizite Konvertierungen](conversions.md#standard-implicit-conversions)) vorhanden ist, von einem Typ `A` auf einen Typ `B`, und wenn weder `A` noch `B` sind *Interface_type*s, klicken Sie dann `A` gilt als ***von darin enthaltenen*** `B`, und `B` gilt als ***umfassen*** `A`.</span><span class="sxs-lookup"><span data-stu-id="c4e75-458">If a standard implicit conversion ([Standard implicit conversions](conversions.md#standard-implicit-conversions)) exists from a type `A` to a type `B`, and if neither `A` nor `B` are *interface_type*s, then `A` is said to be ***encompassed by*** `B`, and `B` is said to ***encompass*** `A`.</span></span>
*  <span data-ttu-id="c4e75-459">Die ***umfassendste Typ*** in einen Satz von Typen wird der eine Typ, der alle anderen Typen in der Menge umfasst.</span><span class="sxs-lookup"><span data-stu-id="c4e75-459">The ***most encompassing type*** in a set of types is the one type that encompasses all other types in the set.</span></span> <span data-ttu-id="c4e75-460">Wenn kein Typ auf alle anderen Typen umfasst, hat dann die Gruppe keine umfassendste.</span><span class="sxs-lookup"><span data-stu-id="c4e75-460">If no single type encompasses all other types, then the set has no most encompassing type.</span></span> <span data-ttu-id="c4e75-461">Intuitiver ausgedrückt, ist der umfassendste Typ "größten"-Typs in der Gruppe, der eine Typ, der alle anderen Typen implizit konvertiert werden kann.</span><span class="sxs-lookup"><span data-stu-id="c4e75-461">In more intuitive terms, the most encompassing type is the "largest" type in the set—the one type to which each of the other types can be implicitly converted.</span></span>
*  <span data-ttu-id="c4e75-462">Die ***die darin enthaltenen Typ*** in einen Satz von Typen wird der eine Typ, der von allen anderen Typen in der Gruppe Datenbankprotokolls enthalten ist.</span><span class="sxs-lookup"><span data-stu-id="c4e75-462">The ***most encompassed type*** in a set of types is the one type that is encompassed by all other types in the set.</span></span> <span data-ttu-id="c4e75-463">Wenn kein Typ von allen anderen Typen Datenbankprotokolls enthalten ist, hat die Gruppe nicht am häufigsten Typ einschließt.</span><span class="sxs-lookup"><span data-stu-id="c4e75-463">If no single type is encompassed by all other types, then the set has no most encompassed type.</span></span> <span data-ttu-id="c4e75-464">Intuitiver ausgedrückt, ist die am stärksten umfasste Typ den "kleinsten" Datentyp in der Gruppe, der eine Typ, der implizit in jeder der anderen Typen konvertiert werden kann.</span><span class="sxs-lookup"><span data-stu-id="c4e75-464">In more intuitive terms, the most encompassed type is the "smallest" type in the set—the one type that can be implicitly converted to each of the other types.</span></span>

### <a name="processing-of-user-defined-implicit-conversions"></a><span data-ttu-id="c4e75-465">Verarbeitung von benutzerdefinierten implizite Konvertierungen</span><span class="sxs-lookup"><span data-stu-id="c4e75-465">Processing of user-defined implicit conversions</span></span>

<span data-ttu-id="c4e75-466">Eine implizite Konvertierung von Typ `S` eingeben `T` wird wie folgt verarbeitet:</span><span class="sxs-lookup"><span data-stu-id="c4e75-466">A user-defined implicit conversion from type `S` to type `T` is processed as follows:</span></span>

*  <span data-ttu-id="c4e75-467">Geben Sie die Typen `S0` und `T0`.</span><span class="sxs-lookup"><span data-stu-id="c4e75-467">Determine the types `S0` and `T0`.</span></span> <span data-ttu-id="c4e75-468">Wenn `S` oder `T` nullable-Typen sind `S0` und `T0` ihre zugrunde liegende Typen sind, andernfalls `S0` und `T0` gleich `S` und `T` bzw.</span><span class="sxs-lookup"><span data-stu-id="c4e75-468">If `S` or `T` are nullable types, `S0` and `T0` are their underlying types, otherwise `S0` and `T0` are equal to `S` and `T` respectively.</span></span>
*  <span data-ttu-id="c4e75-469">Suchen Sie den Satz von Typen, `D`, über die benutzerdefinierte Konvertierung Operatoren betrachtet werden.</span><span class="sxs-lookup"><span data-stu-id="c4e75-469">Find the set of types, `D`, from which user-defined conversion operators will be considered.</span></span> <span data-ttu-id="c4e75-470">Dieser Satz besteht aus `S0` (Wenn `S0` ist eine Klasse oder Struktur), die Basisklassen `S0` (Wenn `S0` ist eine Klasse), und `T0` (Wenn `T0` ist eine Klasse oder Struktur).</span><span class="sxs-lookup"><span data-stu-id="c4e75-470">This set consists of `S0` (if `S0` is a class or struct), the base classes of `S0` (if `S0` is a class), and `T0` (if `T0` is a class or struct).</span></span>
*  <span data-ttu-id="c4e75-471">Suchen Sie den Satz von entsprechenden benutzerdefinierten und transformierten Konvertierungsoperatoren, `U`.</span><span class="sxs-lookup"><span data-stu-id="c4e75-471">Find the set of applicable user-defined and lifted conversion operators, `U`.</span></span> <span data-ttu-id="c4e75-472">Dieser Satz besteht aus den benutzerdefinierten und transformierten Implizite Konvertierungsoperatoren deklariert, indem Sie die Klassen oder Strukturen in `D` , konvertiert in einen Typ umfasst `S` auf einen Typ von darin enthaltenen `T`.</span><span class="sxs-lookup"><span data-stu-id="c4e75-472">This set consists of the user-defined and lifted implicit conversion operators declared by the classes or structs in `D` that convert from a type encompassing `S` to a type encompassed by `T`.</span></span> <span data-ttu-id="c4e75-473">Wenn `U` leer ist, die Konvertierung ist nicht definiert ist, und ein Fehler während der Kompilierung auftritt.</span><span class="sxs-lookup"><span data-stu-id="c4e75-473">If `U` is empty, the conversion is undefined and a compile-time error occurs.</span></span>
*  <span data-ttu-id="c4e75-474">Suchen Sie einen möglichst spezifischen Quelltyp, `SX`, der Operatoren in `U`:</span><span class="sxs-lookup"><span data-stu-id="c4e75-474">Find the most specific source type, `SX`, of the operators in `U`:</span></span>
    * <span data-ttu-id="c4e75-475">Wenn einer der Operatoren in `U` Konvertieren von `S`, klicken Sie dann `SX` ist `S`.</span><span class="sxs-lookup"><span data-stu-id="c4e75-475">If any of the operators in `U` convert from `S`, then `SX` is `S`.</span></span>
    * <span data-ttu-id="c4e75-476">Andernfalls `SX` ist der am stärksten umfasste Typ in der kombinierten Gruppe von Typen von Operatoren in `U`.</span><span class="sxs-lookup"><span data-stu-id="c4e75-476">Otherwise, `SX` is the most encompassed type in the combined set of source types of the operators in `U`.</span></span> <span data-ttu-id="c4e75-477">Wenn genau ein die darin enthaltenen Typ nicht gefunden werden, und klicken Sie dann die Konvertierung mehrdeutig ist, und ein Fehler während der Kompilierung auftritt.</span><span class="sxs-lookup"><span data-stu-id="c4e75-477">If exactly one most encompassed type cannot be found, then the conversion is ambiguous and a compile-time error occurs.</span></span>
*  <span data-ttu-id="c4e75-478">Suchen Sie einen möglichst spezifischen Zieltyp, `TX`, der Operatoren in `U`:</span><span class="sxs-lookup"><span data-stu-id="c4e75-478">Find the most specific target type, `TX`, of the operators in `U`:</span></span>
    * <span data-ttu-id="c4e75-479">Wenn einer der Operatoren in `U` konvertieren in `T`, klicken Sie dann `TX` ist `T`.</span><span class="sxs-lookup"><span data-stu-id="c4e75-479">If any of the operators in `U` convert to `T`, then `TX` is `T`.</span></span>
    * <span data-ttu-id="c4e75-480">Andernfalls `TX` ist der umfassendste Typ in der kombinierten Gruppe von Zieltypen von Operatoren in `U`.</span><span class="sxs-lookup"><span data-stu-id="c4e75-480">Otherwise, `TX` is the most encompassing type in the combined set of target types of the operators in `U`.</span></span> <span data-ttu-id="c4e75-481">Wenn genau ein umfassendste-Typ nicht gefunden wird, klicken Sie dann die Konvertierung mehrdeutig ist, und ein Fehler während der Kompilierung auftritt.</span><span class="sxs-lookup"><span data-stu-id="c4e75-481">If exactly one most encompassing type cannot be found, then the conversion is ambiguous and a compile-time error occurs.</span></span>
*  <span data-ttu-id="c4e75-482">Suchen Sie den spezifischsten Konvertierungsoperator:</span><span class="sxs-lookup"><span data-stu-id="c4e75-482">Find the most specific conversion operator:</span></span>
    * <span data-ttu-id="c4e75-483">Wenn `U` enthält genau eine benutzerdefinierte Konvertierung-Operator, der von konvertiert `SX` zu `TX`, ist dies die spezifischste Konvertierungsoperator.</span><span class="sxs-lookup"><span data-stu-id="c4e75-483">If `U` contains exactly one user-defined conversion operator that converts from `SX` to `TX`, then this is the most specific conversion operator.</span></span>
    * <span data-ttu-id="c4e75-484">Andernfalls gilt: Wenn `U` enthält genau eine angehobene Konvertierungsoperator, der von konvertiert `SX` zu `TX`, ist dies die spezifischste Konvertierungsoperator.</span><span class="sxs-lookup"><span data-stu-id="c4e75-484">Otherwise, if `U` contains exactly one lifted conversion operator that converts from `SX` to `TX`, then this is the most specific conversion operator.</span></span>
    * <span data-ttu-id="c4e75-485">Andernfalls die Konvertierung mehrdeutig ist, und ein Fehler während der Kompilierung auftritt.</span><span class="sxs-lookup"><span data-stu-id="c4e75-485">Otherwise, the conversion is ambiguous and a compile-time error occurs.</span></span>
*  <span data-ttu-id="c4e75-486">Wenden Sie schließlich die Konvertierung:</span><span class="sxs-lookup"><span data-stu-id="c4e75-486">Finally, apply the conversion:</span></span>
    * <span data-ttu-id="c4e75-487">Wenn `S` nicht `SX`, klicken Sie dann eine standard implizite Konvertierung von `S` zu `SX` erfolgt.</span><span class="sxs-lookup"><span data-stu-id="c4e75-487">If `S` is not `SX`, then a standard implicit conversion from `S` to `SX` is performed.</span></span>
    * <span data-ttu-id="c4e75-488">Die spezifischste Konvertierungsoperator wird aufgerufen, für die Konvertierung von `SX` zu `TX`.</span><span class="sxs-lookup"><span data-stu-id="c4e75-488">The most specific conversion operator is invoked to convert from `SX` to `TX`.</span></span>
    * <span data-ttu-id="c4e75-489">Wenn `TX` nicht `T`, klicken Sie dann eine standard implizite Konvertierung von `TX` zu `T` erfolgt.</span><span class="sxs-lookup"><span data-stu-id="c4e75-489">If `TX` is not `T`, then a standard implicit conversion from `TX` to `T` is performed.</span></span>

### <a name="processing-of-user-defined-explicit-conversions"></a><span data-ttu-id="c4e75-490">Verarbeitung von benutzerdefinierten explizite Konvertierungen</span><span class="sxs-lookup"><span data-stu-id="c4e75-490">Processing of user-defined explicit conversions</span></span>

<span data-ttu-id="c4e75-491">Eine benutzerdefinierte, explizite Konvertierung von Typ `S` eingeben `T` wird wie folgt verarbeitet:</span><span class="sxs-lookup"><span data-stu-id="c4e75-491">A user-defined explicit conversion from type `S` to type `T` is processed as follows:</span></span>

*  <span data-ttu-id="c4e75-492">Geben Sie die Typen `S0` und `T0`.</span><span class="sxs-lookup"><span data-stu-id="c4e75-492">Determine the types `S0` and `T0`.</span></span> <span data-ttu-id="c4e75-493">Wenn `S` oder `T` nullable-Typen sind `S0` und `T0` ihre zugrunde liegende Typen sind, andernfalls `S0` und `T0` gleich `S` und `T` bzw.</span><span class="sxs-lookup"><span data-stu-id="c4e75-493">If `S` or `T` are nullable types, `S0` and `T0` are their underlying types, otherwise `S0` and `T0` are equal to `S` and `T` respectively.</span></span>
*  <span data-ttu-id="c4e75-494">Suchen Sie den Satz von Typen, `D`, über die benutzerdefinierte Konvertierung Operatoren betrachtet werden.</span><span class="sxs-lookup"><span data-stu-id="c4e75-494">Find the set of types, `D`, from which user-defined conversion operators will be considered.</span></span> <span data-ttu-id="c4e75-495">Dieser Satz besteht aus `S0` (Wenn `S0` ist eine Klasse oder Struktur), die Basisklassen `S0` (Wenn `S0` ist eine Klasse), `T0` (Wenn `T0` ist eine Klasse oder Struktur), und die Basisklassen `T0` (Wenn `T0`ist eine Klasse).</span><span class="sxs-lookup"><span data-stu-id="c4e75-495">This set consists of `S0` (if `S0` is a class or struct), the base classes of `S0` (if `S0` is a class), `T0` (if `T0` is a class or struct), and the base classes of `T0` (if `T0` is a class).</span></span>
*  <span data-ttu-id="c4e75-496">Suchen Sie den Satz von entsprechenden benutzerdefinierten und transformierten Konvertierungsoperatoren, `U`.</span><span class="sxs-lookup"><span data-stu-id="c4e75-496">Find the set of applicable user-defined and lifted conversion operators, `U`.</span></span> <span data-ttu-id="c4e75-497">Dieser Satz besteht aus den benutzerdefinierten und transformierten implizite oder explizite Konvertierungsoperatoren deklariert, von den Klassen oder Strukturen in `D` , Konvertierung von einem Typ umfasst oder von darin enthaltenen `S` auf einen Typ umfasst oder durch einschließt`T`.</span><span class="sxs-lookup"><span data-stu-id="c4e75-497">This set consists of the user-defined and lifted implicit or explicit conversion operators declared by the classes or structs in `D` that convert from a type encompassing or encompassed by `S` to a type encompassing or encompassed by `T`.</span></span> <span data-ttu-id="c4e75-498">Wenn `U` leer ist, die Konvertierung ist nicht definiert ist, und ein Fehler während der Kompilierung auftritt.</span><span class="sxs-lookup"><span data-stu-id="c4e75-498">If `U` is empty, the conversion is undefined and a compile-time error occurs.</span></span>
*  <span data-ttu-id="c4e75-499">Suchen Sie einen möglichst spezifischen Quelltyp, `SX`, der Operatoren in `U`:</span><span class="sxs-lookup"><span data-stu-id="c4e75-499">Find the most specific source type, `SX`, of the operators in `U`:</span></span>
    * <span data-ttu-id="c4e75-500">Wenn einer der Operatoren in `U` Konvertieren von `S`, klicken Sie dann `SX` ist `S`.</span><span class="sxs-lookup"><span data-stu-id="c4e75-500">If any of the operators in `U` convert from `S`, then `SX` is `S`.</span></span>
    * <span data-ttu-id="c4e75-501">Andernfalls, wenn einer der Operatoren in `U` Konvertieren von Typen, die umfassen `S`, klicken Sie dann `SX` ist der am stärksten umfasste Typ in der kombinierten Gruppe von Quelltypen diese Operatoren.</span><span class="sxs-lookup"><span data-stu-id="c4e75-501">Otherwise, if any of the operators in `U` convert from types that encompass `S`, then `SX` is the most encompassed type in the combined set of source types of those operators.</span></span> <span data-ttu-id="c4e75-502">Wenn kein am darin enthaltenen Typ gefunden werden kann, und klicken Sie dann die Konvertierung mehrdeutig ist, und ein Kompilierungsfehler tritt auf.</span><span class="sxs-lookup"><span data-stu-id="c4e75-502">If no most encompassed type can be found, then the conversion is ambiguous and a compile-time error occurs.</span></span>
    * <span data-ttu-id="c4e75-503">Andernfalls `SX` ist der umfassendste Typ in der kombinierten Gruppe von Typen von Operatoren in `U`.</span><span class="sxs-lookup"><span data-stu-id="c4e75-503">Otherwise, `SX` is the most encompassing type in the combined set of source types of the operators in `U`.</span></span> <span data-ttu-id="c4e75-504">Wenn genau ein umfassendste-Typ nicht gefunden wird, klicken Sie dann die Konvertierung mehrdeutig ist, und ein Fehler während der Kompilierung auftritt.</span><span class="sxs-lookup"><span data-stu-id="c4e75-504">If exactly one most encompassing type cannot be found, then the conversion is ambiguous and a compile-time error occurs.</span></span>
*  <span data-ttu-id="c4e75-505">Suchen Sie einen möglichst spezifischen Zieltyp, `TX`, der Operatoren in `U`:</span><span class="sxs-lookup"><span data-stu-id="c4e75-505">Find the most specific target type, `TX`, of the operators in `U`:</span></span>
    * <span data-ttu-id="c4e75-506">Wenn einer der Operatoren in `U` konvertieren in `T`, klicken Sie dann `TX` ist `T`.</span><span class="sxs-lookup"><span data-stu-id="c4e75-506">If any of the operators in `U` convert to `T`, then `TX` is `T`.</span></span>
    * <span data-ttu-id="c4e75-507">Andernfalls, wenn einer der Operatoren in `U` konvertieren in Typen, die vom enthalten sind `T`, klicken Sie dann `TX` ist der umfassendste Typ in der kombinierten Gruppe von Zieltypen diese Operatoren.</span><span class="sxs-lookup"><span data-stu-id="c4e75-507">Otherwise, if any of the operators in `U` convert to types that are encompassed by `T`, then `TX` is the most encompassing type in the combined set of target types of those operators.</span></span> <span data-ttu-id="c4e75-508">Wenn genau ein umfassendste-Typ nicht gefunden wird, klicken Sie dann die Konvertierung mehrdeutig ist, und ein Fehler während der Kompilierung auftritt.</span><span class="sxs-lookup"><span data-stu-id="c4e75-508">If exactly one most encompassing type cannot be found, then the conversion is ambiguous and a compile-time error occurs.</span></span>
    * <span data-ttu-id="c4e75-509">Andernfalls `TX` ist der am stärksten umfasste Typ in der kombinierten Gruppe von Zieltypen von Operatoren in `U`.</span><span class="sxs-lookup"><span data-stu-id="c4e75-509">Otherwise, `TX` is the most encompassed type in the combined set of target types of the operators in `U`.</span></span> <span data-ttu-id="c4e75-510">Wenn kein am darin enthaltenen Typ gefunden werden kann, und klicken Sie dann die Konvertierung mehrdeutig ist, und ein Kompilierungsfehler tritt auf.</span><span class="sxs-lookup"><span data-stu-id="c4e75-510">If no most encompassed type can be found, then the conversion is ambiguous and a compile-time error occurs.</span></span>
*  <span data-ttu-id="c4e75-511">Suchen Sie den spezifischsten Konvertierungsoperator:</span><span class="sxs-lookup"><span data-stu-id="c4e75-511">Find the most specific conversion operator:</span></span>
    * <span data-ttu-id="c4e75-512">Wenn `U` enthält genau eine benutzerdefinierte Konvertierung-Operator, der von konvertiert `SX` zu `TX`, ist dies die spezifischste Konvertierungsoperator.</span><span class="sxs-lookup"><span data-stu-id="c4e75-512">If `U` contains exactly one user-defined conversion operator that converts from `SX` to `TX`, then this is the most specific conversion operator.</span></span>
    * <span data-ttu-id="c4e75-513">Andernfalls gilt: Wenn `U` enthält genau eine angehobene Konvertierungsoperator, der von konvertiert `SX` zu `TX`, ist dies die spezifischste Konvertierungsoperator.</span><span class="sxs-lookup"><span data-stu-id="c4e75-513">Otherwise, if `U` contains exactly one lifted conversion operator that converts from `SX` to `TX`, then this is the most specific conversion operator.</span></span>
    * <span data-ttu-id="c4e75-514">Andernfalls die Konvertierung mehrdeutig ist, und ein Fehler während der Kompilierung auftritt.</span><span class="sxs-lookup"><span data-stu-id="c4e75-514">Otherwise, the conversion is ambiguous and a compile-time error occurs.</span></span>
*  <span data-ttu-id="c4e75-515">Wenden Sie schließlich die Konvertierung:</span><span class="sxs-lookup"><span data-stu-id="c4e75-515">Finally, apply the conversion:</span></span>
    * <span data-ttu-id="c4e75-516">Wenn `S` nicht `SX`, klicken Sie dann eine explizite standardkonvertierung von `S` zu `SX` erfolgt.</span><span class="sxs-lookup"><span data-stu-id="c4e75-516">If `S` is not `SX`, then a standard explicit conversion from `S` to `SX` is performed.</span></span>
    * <span data-ttu-id="c4e75-517">Die spezifischste benutzerdefinierten Konvertierungsoperator wird aufgerufen, für die Konvertierung von `SX` zu `TX`.</span><span class="sxs-lookup"><span data-stu-id="c4e75-517">The most specific user-defined conversion operator is invoked to convert from `SX` to `TX`.</span></span>
    * <span data-ttu-id="c4e75-518">Wenn `TX` nicht `T`, klicken Sie dann eine explizite standardkonvertierung von `TX` zu `T` erfolgt.</span><span class="sxs-lookup"><span data-stu-id="c4e75-518">If `TX` is not `T`, then a standard explicit conversion from `TX` to `T` is performed.</span></span>

## <a name="anonymous-function-conversions"></a><span data-ttu-id="c4e75-519">Anonyme Funktion Konvertierungen</span><span class="sxs-lookup"><span data-stu-id="c4e75-519">Anonymous function conversions</span></span>

<span data-ttu-id="c4e75-520">Ein *Anonymous_method_expression* oder *Lambda_expression* wird eine anonyme Funktion klassifiziert ([anonyme Funktionsausdrücke](expressions.md#anonymous-function-expressions)).</span><span class="sxs-lookup"><span data-stu-id="c4e75-520">An *anonymous_method_expression* or *lambda_expression* is classified as an anonymous function ([Anonymous function expressions](expressions.md#anonymous-function-expressions)).</span></span> <span data-ttu-id="c4e75-521">Der Ausdruck nicht über einen Datentyp verfügt jedoch implizit in einen kompatiblen Delegattyp bzw. den Typ für die Ausdrucksbaumstruktur konvertiert werden kann.</span><span class="sxs-lookup"><span data-stu-id="c4e75-521">The expression does not have a type but can be implicitly converted to a compatible delegate type or expression tree type.</span></span> <span data-ttu-id="c4e75-522">Insbesondere eine anonyme Funktion `F` ist kompatibel mit einem Delegattypen `D` bereitgestellt:</span><span class="sxs-lookup"><span data-stu-id="c4e75-522">Specifically, an anonymous function `F` is compatible with a delegate type `D` provided:</span></span>

*  <span data-ttu-id="c4e75-523">Wenn `F` enthält ein *Anonymous_function_signature*, klicken Sie dann `D` und `F` die gleiche Anzahl von Parametern aufweisen.</span><span class="sxs-lookup"><span data-stu-id="c4e75-523">If `F` contains an *anonymous_function_signature*, then `D` and `F` have the same number of parameters.</span></span>
*  <span data-ttu-id="c4e75-524">Wenn `F` enthält kein *Anonymous_function_signature*, klicken Sie dann `D` möglicherweise NULL oder mehr Parameter eines beliebigen Typs, solange kein Parameter der `D` hat die `out` Modifizierer für Parameter.</span><span class="sxs-lookup"><span data-stu-id="c4e75-524">If `F` does not contain an *anonymous_function_signature*, then `D` may have zero or more parameters of any type, as long as no parameter of `D` has the `out` parameter modifier.</span></span>
*  <span data-ttu-id="c4e75-525">Wenn `F` verfügt über eine explizit typisierte Parameterliste, jeden Parameter in `D` hat den gleichen Typ und -Modifizierern als der entsprechende Parameter im `F`.</span><span class="sxs-lookup"><span data-stu-id="c4e75-525">If `F` has an explicitly typed parameter list, each parameter in `D` has the same type and modifiers as the corresponding parameter in `F`.</span></span>
*  <span data-ttu-id="c4e75-526">Wenn `F` verfügt über eine implizit typisierte Parameterliste `D` hat keine `ref` oder `out` Parameter.</span><span class="sxs-lookup"><span data-stu-id="c4e75-526">If `F` has an implicitly typed parameter list, `D` has no `ref` or `out` parameters.</span></span>
*  <span data-ttu-id="c4e75-527">Wenn der Text der `F` ist ein Ausdruck, und entweder `D` verfügt über eine `void` Rückgabetyp oder `F` Async ist und `D` weist den Rückgabetyp `Task`, daraufhin beim jeder Parameter des `F` erhält den Typ des der entsprechende Parameter im `D`, den Text der `F` ein gültiger Ausdruck (wrt- [Ausdrücke](expressions.md)), würde als berechtigt sein, eine *Statement_expression* ([Ausdrucksanweisungen](statements.md#expression-statements)).</span><span class="sxs-lookup"><span data-stu-id="c4e75-527">If the body of `F` is an expression, and either `D` has a `void` return type or `F` is async and `D` has the return type `Task`, then when each parameter of `F` is given the type of the corresponding parameter in `D`, the body of `F` is a valid expression (wrt [Expressions](expressions.md)) that would be permitted as a *statement_expression* ([Expression statements](statements.md#expression-statements)).</span></span>
*  <span data-ttu-id="c4e75-528">Wenn der Text der `F` einen Anweisungsblock ein, und entweder `D` verfügt über eine `void` Rückgabetyp oder `F` Async ist und `D` weist den Rückgabetyp `Task`, daraufhin beim jeder Parameter des `F` erhält den Typ des der entsprechende Parameter im `D`, den Text der `F` ist ein gültiger Anweisungsblock (wrt- [Blöcke](statements.md#blocks)) das keine `return` Anweisung gibt einen Ausdruck an.</span><span class="sxs-lookup"><span data-stu-id="c4e75-528">If the body of `F` is a statement block, and either `D` has a `void` return type or `F` is async and `D` has the return type `Task`, then when each parameter of `F` is given the type of the corresponding parameter in `D`, the body of `F` is a valid statement block (wrt [Blocks](statements.md#blocks)) in which no `return` statement specifies an expression.</span></span>
*  <span data-ttu-id="c4e75-529">Wenn der Text der `F` ist ein Ausdruck, und *entweder* `F` ist nicht asynchronen und `D` hat einen nicht-Void-Rückgabetyp `T`, *oder* `F` ist asynchron und `D` hat einen Rückgabetyp `Task<T>`, und wenn jeder Parameter des `F` erhält den Typ des entsprechenden Parameters in `D`, den Text der `F` ein gültiger Ausdruck (wrt- [ Ausdrücke](expressions.md)), die implizit konvertierbar ist `T`.</span><span class="sxs-lookup"><span data-stu-id="c4e75-529">If the body of `F` is an expression, and *either* `F` is non-async and `D` has a non-void return type `T`, *or* `F` is async and `D` has a return type `Task<T>`, then when each parameter of `F` is given the type of the corresponding parameter in `D`, the body of `F` is a valid expression (wrt [Expressions](expressions.md)) that is implicitly convertible to `T`.</span></span>
*  <span data-ttu-id="c4e75-530">Wenn der Text der `F` ist ein Anweisungsblock und *entweder* `F` ist nicht asynchronen und `D` hat einen nicht-Void-Rückgabetyp `T`, *oder* `F` ist asynchron und `D` hat einen Rückgabetyp `Task<T>`, und wenn jeder Parameter des `F` erhält den Typ des entsprechenden Parameters in `D`, den Text der `F` ist ein gültiger Anweisungsblock (wrt- [Blöcke ](statements.md#blocks)) mit einem nicht erreichbaren Endpunkt in der jedes `return` -Anweisung gibt einen Ausdruck, der implizit in `T`.</span><span class="sxs-lookup"><span data-stu-id="c4e75-530">If the body of `F` is a statement block, and *either* `F` is non-async and `D` has a non-void return type `T`, *or* `F` is async and `D` has a return type `Task<T>`, then when each parameter of `F` is given the type of the corresponding parameter in `D`, the body of `F` is a valid statement block (wrt [Blocks](statements.md#blocks)) with a non-reachable end point in which each `return` statement specifies an expression that is implicitly convertible to `T`.</span></span>

<span data-ttu-id="c4e75-531">Im Rahmen der Kürze halber wird in diesem Abschnitt die Kurzform für die Tasktypen `Task` und `Task<T>` ([asynchrone Funktionen](classes.md#async-functions)).</span><span class="sxs-lookup"><span data-stu-id="c4e75-531">For the purpose of brevity, this section uses the short form for the task types `Task` and `Task<T>` ([Async functions](classes.md#async-functions)).</span></span>

<span data-ttu-id="c4e75-532">Ein Lambda-Ausdruck `F` ist kompatibel mit einem Typ für die Ausdrucksbaumstruktur `Expression<D>` Wenn `F` ist kompatibel mit dem Delegattyp `D`.</span><span class="sxs-lookup"><span data-stu-id="c4e75-532">A lambda expression `F` is compatible with an expression tree type `Expression<D>` if `F` is compatible with the delegate type `D`.</span></span> <span data-ttu-id="c4e75-533">Beachten Sie, dass dies nicht für anonyme Methoden, Lambda-Ausdrücke gelten.</span><span class="sxs-lookup"><span data-stu-id="c4e75-533">Note that this does not apply to anonymous methods, only lambda expressions.</span></span>

<span data-ttu-id="c4e75-534">Bestimmte Lambda-Ausdrücke können nicht in ausdrucksbaumstrukturtypen konvertiert werden: Auch wenn die Konvertierung *vorhanden*, zum Zeitpunkt der Kompilierung ein Fehler auftritt.</span><span class="sxs-lookup"><span data-stu-id="c4e75-534">Certain lambda expressions cannot be converted to expression tree types: Even though the conversion *exists*, it fails at compile-time.</span></span> <span data-ttu-id="c4e75-535">Dies ist der Fall, wenn der Lambda-Ausdruck:</span><span class="sxs-lookup"><span data-stu-id="c4e75-535">This is the case if the lambda expression:</span></span>

*  <span data-ttu-id="c4e75-536">Verfügt über eine *Block* Text</span><span class="sxs-lookup"><span data-stu-id="c4e75-536">Has a *block* body</span></span>
*  <span data-ttu-id="c4e75-537">Enthält einfache oder zusammengesetzte Zuweisungsoperatoren</span><span class="sxs-lookup"><span data-stu-id="c4e75-537">Contains simple or compound assignment operators</span></span>
*  <span data-ttu-id="c4e75-538">Enthält einen dynamisch gebundenen Ausdruck</span><span class="sxs-lookup"><span data-stu-id="c4e75-538">Contains a dynamically bound expression</span></span>
*  <span data-ttu-id="c4e75-539">Async ist</span><span class="sxs-lookup"><span data-stu-id="c4e75-539">Is async</span></span>

<span data-ttu-id="c4e75-540">Verwenden Sie die folgenden Beispielen einen generischer Delegattyp `Func<A,R>` steht für eine Funktion, die ein des Typs Argument `A` und gibt einen Wert vom Typ `R`:</span><span class="sxs-lookup"><span data-stu-id="c4e75-540">The examples that follow use a generic delegate type `Func<A,R>` which represents a function that takes an argument of type `A` and returns a value of type `R`:</span></span>
```csharp
delegate R Func<A,R>(A arg);
```

<span data-ttu-id="c4e75-541">In der Zuweisungen</span><span class="sxs-lookup"><span data-stu-id="c4e75-541">In the assignments</span></span>
```csharp
Func<int,int> f1 = x => x + 1;                 // Ok

Func<int,double> f2 = x => x + 1;              // Ok

Func<double,int> f3 = x => x + 1;              // Error

Func<int, Task<int>> f4 = async x => x + 1;    // Ok
```
<span data-ttu-id="c4e75-542">die Typen für Parameter und Rückgabetypen für jede anonyme Funktion werden aus dem Typ der Variablen bestimmt, die die anonyme Funktion zugewiesen wird.</span><span class="sxs-lookup"><span data-stu-id="c4e75-542">the parameter and return types of each anonymous function are determined from the type of the variable to which the anonymous function is assigned.</span></span>

<span data-ttu-id="c4e75-543">Die erste Zuweisung konvertiert die anonyme Funktion wurde erfolgreich in den Delegattyp `Func<int,int>` da Wenn `x` erhält den Typ `int`, `x+1` ist ein gültiger Ausdruck, der implizit in den Typ `int`.</span><span class="sxs-lookup"><span data-stu-id="c4e75-543">The first assignment successfully converts the anonymous function to the delegate type `Func<int,int>` because, when `x` is given type `int`, `x+1` is a valid expression that is implicitly convertible to type `int`.</span></span>

<span data-ttu-id="c4e75-544">Entsprechend die zweite Zuweisung erfolgreich konvertiert die anonyme Funktion in den Delegattyp `Func<int,double>` da das Ergebnis des `x+1` (des Typs `int`) wird implizit in den Typ `double`.</span><span class="sxs-lookup"><span data-stu-id="c4e75-544">Likewise, the second assignment successfully converts the anonymous function to the delegate type `Func<int,double>` because the result of `x+1` (of type `int`) is implicitly convertible to type `double`.</span></span>

<span data-ttu-id="c4e75-545">Die dritte Zuweisung ist jedoch ein Fehler während der Kompilierung, da bei `x` erhält den Typ `double`, das Ergebnis des `x+1` (des Typs `double`) kann nicht implizit in den Typ in `int`.</span><span class="sxs-lookup"><span data-stu-id="c4e75-545">However, the third assignment is a compile-time error because, when `x` is given type `double`, the result of `x+1` (of type `double`) is not implicitly convertible to type `int`.</span></span>

<span data-ttu-id="c4e75-546">Die vierte Zuweisung erfolgreich konvertiert die anonymen Async-Funktion in den Delegattyp `Func<int, Task<int>>` da das Ergebnis des `x+1` (des Typs `int`) wird implizit in den Ergebnistyp `int` der Vorgangsart `Task<int>`.</span><span class="sxs-lookup"><span data-stu-id="c4e75-546">The fourth assignment successfully converts the anonymous async function to the delegate type `Func<int, Task<int>>` because the result of `x+1` (of type `int`) is implicitly convertible to the result type `int` of the task type `Task<int>`.</span></span>

<span data-ttu-id="c4e75-547">Anonyme Funktionen möglicherweise Auflösung von funktionsüberladungen beeinflussen und Typrückschluss teilnehmen.</span><span class="sxs-lookup"><span data-stu-id="c4e75-547">Anonymous functions may influence overload resolution, and participate in type inference.</span></span> <span data-ttu-id="c4e75-548">Finden Sie unter [Funktionsmember](expressions.md#function-members) Weitere Details.</span><span class="sxs-lookup"><span data-stu-id="c4e75-548">See [Function members](expressions.md#function-members) for further details.</span></span>

### <a name="evaluation-of-anonymous-function-conversions-to-delegate-types"></a><span data-ttu-id="c4e75-549">Auswertung der anonymen Funktion-Konvertierungen in Delegattypen</span><span class="sxs-lookup"><span data-stu-id="c4e75-549">Evaluation of anonymous function conversions to delegate types</span></span>

<span data-ttu-id="c4e75-550">Konvertierung von einer anonymen Funktion in einen Delegattyp erstellt eine Delegatinstanz, die ein Verweis auf die anonyme Funktion und der (möglicherweise leeren) Satz von erfassten äußeren Variablen, die zum Zeitpunkt der Auswertung aktiv sind.</span><span class="sxs-lookup"><span data-stu-id="c4e75-550">Conversion of an anonymous function to a delegate type produces a delegate instance which references the anonymous function and the (possibly empty) set of captured outer variables that are active at the time of the evaluation.</span></span> <span data-ttu-id="c4e75-551">Wenn der Delegat aufgerufen wird, wird der Text der anonymen Funktion ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="c4e75-551">When the delegate is invoked, the body of the anonymous function is executed.</span></span> <span data-ttu-id="c4e75-552">Der Code im Funktionstext wird ausgeführt, mithilfe der erfassten äußere Variablen, die der Delegat verweist.</span><span class="sxs-lookup"><span data-stu-id="c4e75-552">The code in the body is executed using the set of captured outer variables referenced by the delegate.</span></span>

<span data-ttu-id="c4e75-553">Die Aufrufliste eines Delegaten, die aus einer anonymen Funktion enthält einen einzelnen Eintrag.</span><span class="sxs-lookup"><span data-stu-id="c4e75-553">The invocation list of a delegate produced from an anonymous function contains a single entry.</span></span> <span data-ttu-id="c4e75-554">Die genaue Zielobjekt und die Zielmethode des Delegaten sind nicht angegeben.</span><span class="sxs-lookup"><span data-stu-id="c4e75-554">The exact target object and target method of the delegate are unspecified.</span></span> <span data-ttu-id="c4e75-555">Insbesondere ist nicht angegeben, ob das Zielobjekt des Delegaten ist `null`, `this` Wert der einschließenden Funktionsmember oder ein anderes Objekt.</span><span class="sxs-lookup"><span data-stu-id="c4e75-555">In particular, it is unspecified whether the target object of the delegate is `null`, the `this` value of the enclosing function member, or some other object.</span></span>

<span data-ttu-id="c4e75-556">Konvertierungen von semantisch identisch anonyme Funktionen mit denselben (möglicherweise leere) erfassten äußere Variable-Instanzen, den gleichen Delegattypen sind zulässig (jedoch nicht erforderlich) auf die gleiche Delegatinstanz zurückgeben.</span><span class="sxs-lookup"><span data-stu-id="c4e75-556">Conversions of semantically identical anonymous functions with the same (possibly empty) set of captured outer variable instances to the same delegate types are permitted (but not required) to return the same delegate instance.</span></span> <span data-ttu-id="c4e75-557">Der Begriff, die semantisch identisch wird hier verwendet, bedeutet, dass die gleichen Auswirkungen, die die gleichen Argumenten angegeben wird, Ausführung von anonymen Funktionen in allen Fällen erzeugt.</span><span class="sxs-lookup"><span data-stu-id="c4e75-557">The term semantically identical is used here to mean that execution of the anonymous functions will, in all cases, produce the same effects given the same arguments.</span></span> <span data-ttu-id="c4e75-558">Diese Regel erlaubt, Code wie den folgenden optimiert werden soll.</span><span class="sxs-lookup"><span data-stu-id="c4e75-558">This rule permits code such as the following to be optimized.</span></span>

```csharp
delegate double Function(double x);

class Test
{
    static double[] Apply(double[] a, Function f) {
        double[] result = new double[a.Length];
        for (int i = 0; i < a.Length; i++) result[i] = f(a[i]);
        return result;
    }

    static void F(double[] a, double[] b) {
        a = Apply(a, (double x) => Math.Sin(x));
        b = Apply(b, (double y) => Math.Sin(y));
        ...
    }
}
```

<span data-ttu-id="c4e75-559">Da die beiden anonyme Funktionsdelegaten demselben (leeren haben) Satz von erfassten äußeren Variablen, und da die anonyme Funktionen semantisch identisch sind, wird der Compiler zulässig die Delegaten, der auf die gleiche Zielmethode zu verweisen.</span><span class="sxs-lookup"><span data-stu-id="c4e75-559">Since the two anonymous function delegates have the same (empty) set of captured outer variables, and since the anonymous functions are semantically identical, the compiler is permitted to have the delegates refer to the same target method.</span></span> <span data-ttu-id="c4e75-560">Tatsächlich ist der Compiler zulässig, die dieselbe Delegatinstanz aus sowohl anonyme Funktionsausdrücke zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="c4e75-560">Indeed, the compiler is permitted to return the very same delegate instance from both anonymous function expressions.</span></span>

### <a name="evaluation-of-anonymous-function-conversions-to-expression-tree-types"></a><span data-ttu-id="c4e75-561">Auswertung von Konvertierungen ausdrucksbaumstrukturtypen anonyme Funktion</span><span class="sxs-lookup"><span data-stu-id="c4e75-561">Evaluation of anonymous function conversions to expression tree types</span></span>

<span data-ttu-id="c4e75-562">Konvertierung von einer anonymen Funktion in einen Typ für die Ausdrucksbaumstruktur erzeugt eine Ausdrucksbaumstruktur ([ausdrucksbaumstrukturtypen](types.md#expression-tree-types)).</span><span class="sxs-lookup"><span data-stu-id="c4e75-562">Conversion of an anonymous function to an expression tree type produces an expression tree ([Expression tree types](types.md#expression-tree-types)).</span></span> <span data-ttu-id="c4e75-563">Genauer gesagt, führt die Auswertung der Konvertierung des anonymen Funktion für die Entwicklung von einem Objektstruktur, die die Struktur der anonymen Funktion selbst darstellt.</span><span class="sxs-lookup"><span data-stu-id="c4e75-563">More precisely, evaluation of the anonymous function conversion leads to the construction of an object structure that represents the structure of the anonymous function itself.</span></span> <span data-ttu-id="c4e75-564">Die genaue Struktur der Ausdrucksbaumstruktur als auch die genauen Schritte zum Erstellen, sind die Implementierung definiert.</span><span class="sxs-lookup"><span data-stu-id="c4e75-564">The precise structure of the expression tree, as well as the exact process for creating it, are implementation defined.</span></span>

### <a name="implementation-example"></a><span data-ttu-id="c4e75-565">Beispiel für die Implementierung</span><span class="sxs-lookup"><span data-stu-id="c4e75-565">Implementation example</span></span>

<span data-ttu-id="c4e75-566">Dieser Abschnitt beschreibt eine mögliche Implementierung der anonymen Funktion Konvertierungen in Bezug auf andere Konstrukte in C#.</span><span class="sxs-lookup"><span data-stu-id="c4e75-566">This section describes a possible implementation of anonymous function conversions in terms of other C# constructs.</span></span> <span data-ttu-id="c4e75-567">Die hier beschriebene Implementierung basiert darauf, dass die gleichen Prinzipien, die vom Microsoft C#-Compiler verwendet, aber es ist keine beauftragten-Implementierung, noch ist es das einzig mögliche.</span><span class="sxs-lookup"><span data-stu-id="c4e75-567">The implementation described here is based on the same principles used by the Microsoft C# compiler, but it is by no means a mandated implementation, nor is it the only one possible.</span></span> <span data-ttu-id="c4e75-568">Konvertierungen in Ausdrucksbaumstrukturen, wird nur kurz erwähnt, wie die genaue Semantik außerhalb des Bereichs dieser Spezifikation.</span><span class="sxs-lookup"><span data-stu-id="c4e75-568">It only briefly mentions conversions to expression trees, as their exact semantics are outside the scope of this specification.</span></span>

<span data-ttu-id="c4e75-569">Der übrige Teil dieses Abschnitts enthält mehrere Beispiele für Code, der anonyme Funktionen mit unterschiedlichen Eigenschaften enthält.</span><span class="sxs-lookup"><span data-stu-id="c4e75-569">The remainder of this section gives several examples of code that contains anonymous functions with different characteristics.</span></span> <span data-ttu-id="c4e75-570">Für jedes Beispiel erfolgt eine entsprechende Übersetzung in Code, der nur anderen C#-Konstrukten verwendet.</span><span class="sxs-lookup"><span data-stu-id="c4e75-570">For each example, a corresponding translation to code that uses only other C# constructs is provided.</span></span> <span data-ttu-id="c4e75-571">In den Beispielen wird der Bezeichner `D` davon stellen den folgenden Delegattyp:</span><span class="sxs-lookup"><span data-stu-id="c4e75-571">In the examples, the identifier `D` is assumed by represent the following delegate type:</span></span>
```csharp
public delegate void D();
```

<span data-ttu-id="c4e75-572">Die einfachste Form einer anonymen Funktion ist eine, die keine äußeren Variablen erfasst:</span><span class="sxs-lookup"><span data-stu-id="c4e75-572">The simplest form of an anonymous function is one that captures no outer variables:</span></span>
```csharp
class Test
{
    static void F() {
        D d = () => { Console.WriteLine("test"); };
    }
}
```

<span data-ttu-id="c4e75-573">Dies kann in eine Instanziierung von Delegaten übersetzt werden, die vom Compiler generierte statische Methode verweist, in dem der Code der anonymen Funktion platziert wird:</span><span class="sxs-lookup"><span data-stu-id="c4e75-573">This can be translated to a delegate instantiation that references a compiler generated static method in which the code of the anonymous function is placed:</span></span>
```csharp
class Test
{
    static void F() {
        D d = new D(__Method1);
    }

    static void __Method1() {
        Console.WriteLine("test");
    }
}
```

<span data-ttu-id="c4e75-574">Im folgenden Beispiel verweist die anonyme Funktion Instanzmember `this`:</span><span class="sxs-lookup"><span data-stu-id="c4e75-574">In the following example, the anonymous function references instance members of `this`:</span></span>
```csharp
class Test
{
    int x;

    void F() {
        D d = () => { Console.WriteLine(x); };
    }
}
```

<span data-ttu-id="c4e75-575">Dies kann auf eine vom Compiler generierten Instanz-Methode, die den Code der anonymen Funktion übersetzt werden:</span><span class="sxs-lookup"><span data-stu-id="c4e75-575">This can be translated to a compiler generated instance method containing the code of the anonymous function:</span></span>
```csharp
class Test
{
    int x;

    void F() {
        D d = new D(__Method1);
    }

    void __Method1() {
        Console.WriteLine(x);
    }
}
```

<span data-ttu-id="c4e75-576">In diesem Beispiel werden die anonyme Funktion eine lokale Variable erfasst:</span><span class="sxs-lookup"><span data-stu-id="c4e75-576">In this example, the anonymous function captures a local variable:</span></span>
```csharp
class Test
{
    void F() {
        int y = 123;
        D d = () => { Console.WriteLine(y); };
    }
}
```

<span data-ttu-id="c4e75-577">Die Lebensdauer der lokalen Variablen muss jetzt auf mindestens die Lebensdauer des Delegaten anonyme Funktion erweitert werden.</span><span class="sxs-lookup"><span data-stu-id="c4e75-577">The lifetime of the local variable must now be extended to at least the lifetime of the anonymous function delegate.</span></span> <span data-ttu-id="c4e75-578">Dies kann erreicht werden, indem "anheben" die lokale Variable in einem Feld einer vom Compiler generierten Klasse.</span><span class="sxs-lookup"><span data-stu-id="c4e75-578">This can be achieved by "hoisting" the local variable into a field of a compiler generated class.</span></span> <span data-ttu-id="c4e75-579">Instanziierung der lokalen Variablen ([Instanziierung von lokalen Variablen](expressions.md#instantiation-of-local-variables)) klicken Sie dann zum Erstellen einer Instanz von der vom Compiler generierten Klasse und den Zugriff auf die lokale Variable entspricht, für den Zugriff auf ein Feld in der Instanz von entspricht. die vom Compiler generierten Klasse.</span><span class="sxs-lookup"><span data-stu-id="c4e75-579">Instantiation of the local variable ([Instantiation of local variables](expressions.md#instantiation-of-local-variables)) then corresponds to creating an instance of the compiler generated class, and accessing the local variable corresponds to accessing a field in the instance of the compiler generated class.</span></span> <span data-ttu-id="c4e75-580">Darüber hinaus wird die anonyme Funktion eine Instanzmethode der vom Compiler generierten Klasse:</span><span class="sxs-lookup"><span data-stu-id="c4e75-580">Furthermore, the anonymous function becomes an instance method of the compiler generated class:</span></span>
```csharp
class Test
{
    void F() {
        __Locals1 __locals1 = new __Locals1();
        __locals1.y = 123;
        D d = new D(__locals1.__Method1);
    }

    class __Locals1
    {
        public int y;

        public void __Method1() {
            Console.WriteLine(y);
        }
    }
}
```

<span data-ttu-id="c4e75-581">Zum Schluss die folgenden anonymen Funktion erfasst `this` und zweier lokaler Variablen mit verschiedenen Lebensdauer:</span><span class="sxs-lookup"><span data-stu-id="c4e75-581">Finally, the following anonymous function captures `this` as well as two local variables with different lifetimes:</span></span>
```csharp
class Test
{
    int x;

    void F() {
        int y = 123;
        for (int i = 0; i < 10; i++) {
            int z = i * 2;
            D d = () => { Console.WriteLine(x + y + z); };
        }
    }
}
```

<span data-ttu-id="c4e75-582">Hier wird eine vom Compiler generierten Klasse erstellt, für jede Anweisung-block in der lokalen Variablen erfasst werden, so, dass die lokalen Variablen in anderen Blöcken unabhängige Lebensdauer aufweisen können.</span><span class="sxs-lookup"><span data-stu-id="c4e75-582">Here, a compiler generated class is created for each statement block in which locals are captured such that the locals in the different blocks can have independent lifetimes.</span></span> <span data-ttu-id="c4e75-583">Eine Instanz von `__Locals2`, die vom Compiler generierten-Klasse für den Block inner-Anweisung enthält, die lokale Variable `z` und ein Feld, das eine Instanz des verweist `__Locals1`.</span><span class="sxs-lookup"><span data-stu-id="c4e75-583">An instance of `__Locals2`, the compiler generated class for the inner statement block, contains the local variable `z` and a field that references an instance of `__Locals1`.</span></span>  <span data-ttu-id="c4e75-584">Eine Instanz von `__Locals1`, die vom Compiler generierten-Klasse für den äußeren Anweisungsblock enthält die lokale Variable `y` und ein Feld, das Verweise `this` der einschließenden Funktion-Elements.</span><span class="sxs-lookup"><span data-stu-id="c4e75-584">An instance of `__Locals1`, the compiler generated class for the outer statement block, contains the local variable `y` and a field that references `this` of the enclosing function member.</span></span> <span data-ttu-id="c4e75-585">Erfasst alle mit diese Datenstrukturen zu erreichen, kann das äußere Variablen durch eine Instanz der `__Local2`, und der Code der anonymen Funktion kann daher als eine Instanzmethode dieser Klasse implementiert werden.</span><span class="sxs-lookup"><span data-stu-id="c4e75-585">With these data structures it is possible to reach all captured outer variables through an instance of `__Local2`, and the code of the anonymous function can thus be implemented as an instance method of that class.</span></span>

```csharp
class Test
{
    void F() {
        __Locals1 __locals1 = new __Locals1();
        __locals1.__this = this;
        __locals1.y = 123;
        for (int i = 0; i < 10; i++) {
            __Locals2 __locals2 = new __Locals2();
            __locals2.__locals1 = __locals1;
            __locals2.z = i * 2;
            D d = new D(__locals2.__Method1);
        }
    }

    class __Locals1
    {
        public Test __this;
        public int y;
    }

    class __Locals2
    {
        public __Locals1 __locals1;
        public int z;

        public void __Method1() {
            Console.WriteLine(__locals1.__this.x + __locals1.y + z);
        }
    }
}
```

<span data-ttu-id="c4e75-586">Das gleiche Verfahren, die hier angewendet werden, um die lokale Variablen erfassen kann auch verwendet werden, wenn anonyme Funktionen in Ausdrucksbaumstrukturen konvertiert: Verweise auf die vom Compiler generierten Objekte können in der Ausdrucksbaumstruktur gespeichert werden, und den Zugriff auf die lokalen Variablen dargestellt werden kann, wie das Feld für die folgenden Objekte zugreift.</span><span class="sxs-lookup"><span data-stu-id="c4e75-586">The same technique applied here to capture local variables can also be used when converting anonymous functions to expression trees: References to the compiler generated objects can be stored in the expression tree, and access to the local variables can be represented as field accesses on these objects.</span></span> <span data-ttu-id="c4e75-587">Der Vorteil dieses Ansatzes ist, dass die "transformierten" lokalen Variablen von Delegaten und Ausdrucksbaumstrukturen gemeinsam genutzt werden können.</span><span class="sxs-lookup"><span data-stu-id="c4e75-587">The advantage of this approach is that it allows the "lifted" local variables to be shared between delegates and expression trees.</span></span>

## <a name="method-group-conversions"></a><span data-ttu-id="c4e75-588">Konvertierungen für Gruppe</span><span class="sxs-lookup"><span data-stu-id="c4e75-588">Method group conversions</span></span>

<span data-ttu-id="c4e75-589">Eine implizite Konvertierung ([implizite Konvertierungen](conversions.md#implicit-conversions)) aus einer Methodengruppe vorhanden ist ([ausdrucksklassifizierungen](expressions.md#expression-classifications)) in einen kompatiblen Delegattyp.</span><span class="sxs-lookup"><span data-stu-id="c4e75-589">An implicit conversion ([Implicit conversions](conversions.md#implicit-conversions)) exists from a method group ([Expression classifications](expressions.md#expression-classifications)) to a compatible delegate type.</span></span> <span data-ttu-id="c4e75-590">Erhalten einen Delegattyp `D` und einen Ausdruck `E` , die als eine Methodengruppe klassifiziert ist, ist eine implizite Konvertierung von vorhanden `E` zu `D` Wenn `E` enthält mindestens eine Methode, die in sein (Normalform angewendet wird [Anwendbarer Funktionsmember](expressions.md#applicable-function-member)) auf eine Argumentliste erstellt, durch Nutzung der Parametertypen und Modifizierern von `D`, wie im folgenden beschrieben.</span><span class="sxs-lookup"><span data-stu-id="c4e75-590">Given a delegate type `D` and an expression `E` that is classified as a method group, an implicit conversion exists from `E` to `D` if `E` contains at least one method that is applicable in its normal form ([Applicable function member](expressions.md#applicable-function-member)) to an argument list constructed by use of the parameter types and modifiers of `D`, as described in the following.</span></span>

<span data-ttu-id="c4e75-591">Die Anwendung während der Kompilierung einer Konvertierung von einer Methodengruppe `E` in einen Delegattyp `D` wird im folgenden beschrieben.</span><span class="sxs-lookup"><span data-stu-id="c4e75-591">The compile-time application of a conversion from a method group `E` to a delegate type `D` is described in the following.</span></span> <span data-ttu-id="c4e75-592">Beachten Sie, dass das Vorhandensein eine implizite Konvertierung von `E` zu `D` garantiert nicht, dass die Anwendung während der Kompilierung der Konvertierung ohne Fehler durchgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="c4e75-592">Note that the existence of an implicit conversion from `E` to `D` does not guarantee that the compile-time application of the conversion will succeed without error.</span></span>

*  <span data-ttu-id="c4e75-593">Eine einzelne Methode `M` ausgewählt ist, den Aufruf einer Methode entsprechen ([Methodenaufrufe](expressions.md#method-invocations)) des Formulars `E(A)`, mit der folgenden Änderungen:</span><span class="sxs-lookup"><span data-stu-id="c4e75-593">A single method `M` is selected corresponding to a method invocation ([Method invocations](expressions.md#method-invocations)) of the form `E(A)`, with the following modifications:</span></span>
    * <span data-ttu-id="c4e75-594">Die Argumentliste `A` ist eine Liste von Ausdrücken, jede klassifizierte, wie eine Variable und mit dem Typ und die Modifizierer (`ref` oder `out`) des entsprechenden Parameters in der *Formal_parameter_list* von `D`.</span><span class="sxs-lookup"><span data-stu-id="c4e75-594">The argument list `A` is a list of expressions, each classified as a variable and with the type and modifier (`ref` or `out`) of the corresponding parameter in the *formal_parameter_list* of `D`.</span></span>
    * <span data-ttu-id="c4e75-595">Die Candidate-Methoden, die berücksichtigt werden nur die Methoden, die in ihren Normalform angewendet werden ([Anwendbarer Funktionsmember](expressions.md#applicable-function-member)), nicht auf die nur in ihre erweiterte Form angewendet.</span><span class="sxs-lookup"><span data-stu-id="c4e75-595">The candidate methods considered are only those methods that are applicable in their normal form ([Applicable function member](expressions.md#applicable-function-member)), not those applicable only in their expanded form.</span></span>
*  <span data-ttu-id="c4e75-596">Wenn der Algorithmus des [Methodenaufrufe](expressions.md#method-invocations) einen Fehler erzeugt, und klicken Sie dann ein Fehler während der Kompilierung auftritt.</span><span class="sxs-lookup"><span data-stu-id="c4e75-596">If the algorithm of [Method invocations](expressions.md#method-invocations) produces an error, then a compile-time error occurs.</span></span> <span data-ttu-id="c4e75-597">Andernfalls erzeugt der Algorithmus eine einzelne bewährte Methode `M` müssen die gleiche Anzahl von Parametern wie `D` und die Konvertierung wird als vorhanden angesehen.</span><span class="sxs-lookup"><span data-stu-id="c4e75-597">Otherwise the algorithm produces a single best method `M` having the same number of parameters as `D` and the conversion is considered to exist.</span></span>
*  <span data-ttu-id="c4e75-598">Die ausgewählte Methode `M` kompatibel sein muss ([delegieren Kompatibilität](delegates.md#delegate-compatibility)) mit dem Delegattyp `D`, oder andernfalls ein Kompilierungsfehler tritt auf.</span><span class="sxs-lookup"><span data-stu-id="c4e75-598">The selected method `M` must be compatible ([Delegate compatibility](delegates.md#delegate-compatibility)) with the delegate type `D`, or otherwise, a compile-time error occurs.</span></span>
*  <span data-ttu-id="c4e75-599">Wenn die ausgewählte Methode `M` ist eine Instanzmethode, die zugeordneten Instanzausdruck `E` bestimmt das Zielobjekt des Delegaten.</span><span class="sxs-lookup"><span data-stu-id="c4e75-599">If the selected method `M` is an instance method, the instance expression associated with `E` determines the target object of the delegate.</span></span>
*  <span data-ttu-id="c4e75-600">Wenn die ausgewählte Methode M eine Erweiterungsmethode die durch einen Elementzugriff auf ein Instanzenausdruck gekennzeichnet ist ist, bestimmt dieser Instanzausdruck das Zielobjekt des Delegaten.</span><span class="sxs-lookup"><span data-stu-id="c4e75-600">If the selected method M is an extension method which is denoted by means of a member access on an instance expression, that instance expression determines the target object of the delegate.</span></span>
*  <span data-ttu-id="c4e75-601">Das Ergebnis der Konvertierung ist ein Wert vom Typ `D`, d. h. ein neu erstellter Delegat, der auf dem ausgewählten Methode und die Ziel-Objekt verweist.</span><span class="sxs-lookup"><span data-stu-id="c4e75-601">The result of the conversion is a value of type `D`, namely a newly created delegate that refers to the selected method and target object.</span></span>
*  <span data-ttu-id="c4e75-602">Beachten Sie, die diesen Prozess für die Erstellung eines Delegaten an eine Erweiterungsmethode führen können, wenn der Algorithmus des [Methodenaufrufe](expressions.md#method-invocations) finden Sie eine Instanzmethode jedoch erfolgreich ausgeführt wird, bei der Verarbeitung des Aufrufs `E(A)` als Erweiterung Methodenaufruf ([Erweiterung Methodenaufrufe](expressions.md#extension-method-invocations)).</span><span class="sxs-lookup"><span data-stu-id="c4e75-602">Note that this process can lead to the creation of a delegate to an extension method, if the algorithm of [Method invocations](expressions.md#method-invocations) fails to find an instance method but succeeds in processing the invocation of `E(A)` as an extension method invocation ([Extension method invocations](expressions.md#extension-method-invocations)).</span></span> <span data-ttu-id="c4e75-603">Ein Delegat, die so erstellte erfasst die Erweiterungsmethode als auch als erstes Argument.</span><span class="sxs-lookup"><span data-stu-id="c4e75-603">A delegate thus created captures the extension method as well as its first argument.</span></span>

<span data-ttu-id="c4e75-604">Das folgende Beispiel zeigt die Gruppe Konvertierungen:</span><span class="sxs-lookup"><span data-stu-id="c4e75-604">The following example demonstrates method group conversions:</span></span>
```csharp
delegate string D1(object o);

delegate object D2(string s);

delegate object D3();

delegate string D4(object o, params object[] a);

delegate string D5(int i);

class Test
{
    static string F(object o) {...}

    static void G() {
        D1 d1 = F;            // Ok
        D2 d2 = F;            // Ok
        D3 d3 = F;            // Error -- not applicable
        D4 d4 = F;            // Error -- not applicable in normal form
        D5 d5 = F;            // Error -- applicable but not compatible

    }
}
```

<span data-ttu-id="c4e75-605">Die Zuweisung zu `d1` implizit konvertiert die Methodengruppe `F` auf einen Wert vom Typ `D1`.</span><span class="sxs-lookup"><span data-stu-id="c4e75-605">The assignment to `d1` implicitly converts the method group `F` to a value of type `D1`.</span></span>

<span data-ttu-id="c4e75-606">Die Zuweisung zu `d2` zeigt, wie es ist möglich, einen Delegaten an eine Methode erstellen, die über weniger abgeleitete (Contravariant) Typen verfügt und eine abgeleitete (covariant)-Rückgabetyp.</span><span class="sxs-lookup"><span data-stu-id="c4e75-606">The assignment to `d2` shows how it is possible to create a delegate to a method that has less derived (contravariant) parameter types and a more derived (covariant) return type.</span></span>

<span data-ttu-id="c4e75-607">Die Zuweisung zu `d3` zeigt wie keine Konvertierung möglich ist, wenn die Methode nicht anwendbar ist.</span><span class="sxs-lookup"><span data-stu-id="c4e75-607">The assignment to `d3` shows how no conversion exists if the method is not applicable.</span></span>

<span data-ttu-id="c4e75-608">Die Zuweisung zu `d4` zeigt, wie die Methode in der Normalform angewendet werden muss.</span><span class="sxs-lookup"><span data-stu-id="c4e75-608">The assignment to `d4` shows how the method must be applicable in its normal form.</span></span>

<span data-ttu-id="c4e75-609">Die Zuweisung zu `d5` zeigt, wie Parameter und Rückgabetypen Typen des Delegaten und der Methode unterscheidet nur für Verweistypen zulässig sind.</span><span class="sxs-lookup"><span data-stu-id="c4e75-609">The assignment to `d5` shows how parameter and return types of the delegate and method are allowed to differ only for reference types.</span></span>

<span data-ttu-id="c4e75-610">Wie bei allen anderen implizite und explizite Konvertierungen kann der Cast-Operator verwendet werden, um explizit eine Methode gruppenkonvertierung auszuführen.</span><span class="sxs-lookup"><span data-stu-id="c4e75-610">As with all other implicit and explicit conversions, the cast operator can be used to explicitly perform a method group conversion.</span></span> <span data-ttu-id="c4e75-611">Das Beispiel</span><span class="sxs-lookup"><span data-stu-id="c4e75-611">Thus, the example</span></span>
```csharp
object obj = new EventHandler(myDialog.OkClick);
```
<span data-ttu-id="c4e75-612">könnte stattdessen geschrieben werden</span><span class="sxs-lookup"><span data-stu-id="c4e75-612">could instead be written</span></span>
```csharp
object obj = (EventHandler)myDialog.OkClick;
```

<span data-ttu-id="c4e75-613">Methodengruppen möglicherweise Auflösung von funktionsüberladungen beeinflussen und Typrückschluss teilnehmen.</span><span class="sxs-lookup"><span data-stu-id="c4e75-613">Method groups may influence overload resolution, and participate in type inference.</span></span> <span data-ttu-id="c4e75-614">Finden Sie unter [Funktionsmember](expressions.md#function-members) Weitere Details.</span><span class="sxs-lookup"><span data-stu-id="c4e75-614">See [Function members](expressions.md#function-members) for further details.</span></span>

<span data-ttu-id="c4e75-615">Die Laufzeit-Auswertung von einer Methode die gruppenkonvertierung wird wie folgt aus:</span><span class="sxs-lookup"><span data-stu-id="c4e75-615">The run-time evaluation of a method group conversion proceeds as follows:</span></span>

*  <span data-ttu-id="c4e75-616">Wenn die Methode, die zum Zeitpunkt der Kompilierung ausgewählt, eine Instanzmethode ist, oder es ist eine Erweiterungsmethode, die als eine Instanzmethode zugegriffen wird, richtet sich das Zielobjekt des Delegaten aus der zugeordneten Instanzausdruck `E`:</span><span class="sxs-lookup"><span data-stu-id="c4e75-616">If the method selected at compile-time is an instance method, or it is an extension method which is accessed as an instance method, the target object of the delegate is determined from the instance expression associated with `E`:</span></span>
    * <span data-ttu-id="c4e75-617">Die Instanzausdruck wird ausgewertet.</span><span class="sxs-lookup"><span data-stu-id="c4e75-617">The instance expression is evaluated.</span></span> <span data-ttu-id="c4e75-618">Wenn diese Evaluierungsversion auf eine Ausnahme auslöst, werden keine weiteren Schritte ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="c4e75-618">If this evaluation causes an exception, no further steps are executed.</span></span>
    * <span data-ttu-id="c4e75-619">Wenn der Instanzausdruck ist eine *Reference_type*, der Wert, der durch den Instanzausdruck berechnet wird, das Zielobjekt.</span><span class="sxs-lookup"><span data-stu-id="c4e75-619">If the instance expression is of a *reference_type*, the value computed by the instance expression becomes the target object.</span></span> <span data-ttu-id="c4e75-620">Wenn die ausgewählte Methode eine Instanzmethode ist und das Zielobjekt ist `null`, `System.NullReferenceException` wird ausgelöst, und keine weiteren Schritte ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="c4e75-620">If the selected method is an instance method and the target object is `null`, a `System.NullReferenceException` is thrown and no further steps are executed.</span></span>
    * <span data-ttu-id="c4e75-621">Wenn der Instanzausdruck ist eine *Value_type*, ein Boxing-Vorgang ([Boxing-Konvertierung](types.md#boxing-conversions)) wird ausgeführt, um den Wert auf ein Objekt zu konvertieren und dieses Objekt wird das Zielobjekt.</span><span class="sxs-lookup"><span data-stu-id="c4e75-621">If the instance expression is of a *value_type*, a boxing operation ([Boxing conversions](types.md#boxing-conversions)) is performed to convert the value to an object, and this object becomes the target object.</span></span>
*  <span data-ttu-id="c4e75-622">Andernfalls wird die ausgewählte Methode Teil eines Aufrufs der statischen Methode aus, und das Zielobjekt des Delegaten ist `null`.</span><span class="sxs-lookup"><span data-stu-id="c4e75-622">Otherwise the selected method is part of a static method call, and the target object of the delegate is `null`.</span></span>
*  <span data-ttu-id="c4e75-623">Eine neue Instanz des Delegattyps `D` zugeordnet ist.</span><span class="sxs-lookup"><span data-stu-id="c4e75-623">A new instance of the delegate type `D` is allocated.</span></span> <span data-ttu-id="c4e75-624">Wenn nicht genügend Arbeitsspeicher verfügbar, um die neue Instanz einer `System.OutOfMemoryException` wird ausgelöst, und keine weiteren Schritte ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="c4e75-624">If there is not enough memory available to allocate the new instance, a `System.OutOfMemoryException` is thrown and no further steps are executed.</span></span>
*  <span data-ttu-id="c4e75-625">Die neue Delegatinstanz wird mit einem Verweis auf die Methode, die zum Zeitpunkt der Kompilierung bestimmt wurde initialisiert, und ein Verweis auf das Zielobjekt oben berechnete.</span><span class="sxs-lookup"><span data-stu-id="c4e75-625">The new delegate instance is initialized with a reference to the method that was determined at compile-time and a reference to the target object computed above.</span></span>
