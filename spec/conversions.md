---
ms.openlocfilehash: 4d6d28a3127bc701867afe157aa5496377a06f69
ms.sourcegitcommit: 63d276488c9770a565fd787020783ffc1d2af9d6
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 12/05/2019
ms.locfileid: "74868003"
---
# <a name="conversions"></a><span data-ttu-id="463f3-101">Konvertierungen</span><span class="sxs-lookup"><span data-stu-id="463f3-101">Conversions</span></span>

<span data-ttu-id="463f3-102">Eine ***Konvertierung*** ermöglicht es, einen Ausdruck als einen bestimmten Typ zu behandeln.</span><span class="sxs-lookup"><span data-stu-id="463f3-102">A ***conversion*** enables an expression to be treated as being of a particular type.</span></span> <span data-ttu-id="463f3-103">Eine Konvertierung kann bewirken, dass ein Ausdruck eines bestimmten Typs als einen anderen Typ behandelt wird, oder es kann dazu führen, dass ein Ausdruck ohne einen Typ einen Typ erhält.</span><span class="sxs-lookup"><span data-stu-id="463f3-103">A conversion may cause an expression of a given type to be treated as having a different type, or it may cause an expression without a type to get a type.</span></span> <span data-ttu-id="463f3-104">Konvertierungen können ***implizit*** oder ***explizit***sein. Dadurch wird bestimmt, ob eine explizite Umwandlung erforderlich ist.</span><span class="sxs-lookup"><span data-stu-id="463f3-104">Conversions can be ***implicit*** or ***explicit***, and this determines whether an explicit cast is required.</span></span> <span data-ttu-id="463f3-105">Beispielsweise ist die Konvertierung von Typ `int` in Typ `long` implizit, sodass Ausdrücke vom Typ `int` implizit als Typ `long`behandelt werden können.</span><span class="sxs-lookup"><span data-stu-id="463f3-105">For instance, the conversion from type `int` to type `long` is implicit, so expressions of type `int` can implicitly be treated as type `long`.</span></span> <span data-ttu-id="463f3-106">Die umgekehrte Konvertierung vom Typ `long` in den Typ `int`ist explizit, sodass eine explizite Umwandlung erforderlich ist.</span><span class="sxs-lookup"><span data-stu-id="463f3-106">The opposite conversion, from type `long` to type `int`, is explicit and so an explicit cast is required.</span></span>

```csharp
int a = 123;
long b = a;         // implicit conversion from int to long
int c = (int) b;    // explicit conversion from long to int
```

<span data-ttu-id="463f3-107">Einige Konvertierungen werden von der Sprache definiert.</span><span class="sxs-lookup"><span data-stu-id="463f3-107">Some conversions are defined by the language.</span></span> <span data-ttu-id="463f3-108">Programme können auch Ihre eigenen Konvertierungen ([benutzerdefinierte Konvertierungen](conversions.md#user-defined-conversions)) definieren.</span><span class="sxs-lookup"><span data-stu-id="463f3-108">Programs may also define their own conversions ([User-defined conversions](conversions.md#user-defined-conversions)).</span></span>

## <a name="implicit-conversions"></a><span data-ttu-id="463f3-109">Implizite Konvertierungen</span><span class="sxs-lookup"><span data-stu-id="463f3-109">Implicit conversions</span></span>

<span data-ttu-id="463f3-110">Die folgenden Konvertierungen werden als implizite Konvertierungen klassifiziert:</span><span class="sxs-lookup"><span data-stu-id="463f3-110">The following conversions are classified as implicit conversions:</span></span>

*  <span data-ttu-id="463f3-111">Identitäts Konvertierungen</span><span class="sxs-lookup"><span data-stu-id="463f3-111">Identity conversions</span></span>
*  <span data-ttu-id="463f3-112">Implizite numerische Konvertierungen</span><span class="sxs-lookup"><span data-stu-id="463f3-112">Implicit numeric conversions</span></span>
*  <span data-ttu-id="463f3-113">Implizite Enumerationskonvertierungen</span><span class="sxs-lookup"><span data-stu-id="463f3-113">Implicit enumeration conversions</span></span>
*  <span data-ttu-id="463f3-114">Implizite interinterpolierte Zeichen folgen Konvertierungen</span><span class="sxs-lookup"><span data-stu-id="463f3-114">Implicit interpolated string conversions</span></span>
*  <span data-ttu-id="463f3-115">Implizite Konvertierungen, die NULL zulassen</span><span class="sxs-lookup"><span data-stu-id="463f3-115">Implicit nullable conversions</span></span>
*  <span data-ttu-id="463f3-116">NULL Literale Konvertierungen</span><span class="sxs-lookup"><span data-stu-id="463f3-116">Null literal conversions</span></span>
*  <span data-ttu-id="463f3-117">Implizite Verweis Konvertierungen</span><span class="sxs-lookup"><span data-stu-id="463f3-117">Implicit reference conversions</span></span>
*  <span data-ttu-id="463f3-118">Boxing-Konvertierungen</span><span class="sxs-lookup"><span data-stu-id="463f3-118">Boxing conversions</span></span>
*  <span data-ttu-id="463f3-119">Implizite dynamische Konvertierungen</span><span class="sxs-lookup"><span data-stu-id="463f3-119">Implicit dynamic conversions</span></span>
*  <span data-ttu-id="463f3-120">Implizite Konstante Ausdrucks Konvertierungen</span><span class="sxs-lookup"><span data-stu-id="463f3-120">Implicit constant expression conversions</span></span>
*  <span data-ttu-id="463f3-121">Benutzerdefinierte implizite Konvertierungen</span><span class="sxs-lookup"><span data-stu-id="463f3-121">User-defined implicit conversions</span></span>
*  <span data-ttu-id="463f3-122">Anonyme Funktions Konvertierungen</span><span class="sxs-lookup"><span data-stu-id="463f3-122">Anonymous function conversions</span></span>
*  <span data-ttu-id="463f3-123">Methoden Gruppen Konvertierungen</span><span class="sxs-lookup"><span data-stu-id="463f3-123">Method group conversions</span></span>

<span data-ttu-id="463f3-124">Implizite Konvertierungen können in einer Vielzahl von Situationen auftreten, einschließlich Funktionsmember-Aufrufe ([Überprüfung der dynamischen Überladungs Auflösung](expressions.md#compile-time-checking-of-dynamic-overload-resolution)), Umwandlungs Ausdrücke (Umwandlungs[Ausdrücke](expressions.md#cast-expressions)) und Zuweisungen ([Zuweisungs Operatoren](expressions.md#assignment-operators)).</span><span class="sxs-lookup"><span data-stu-id="463f3-124">Implicit conversions can occur in a variety of situations, including function member invocations ([Compile-time checking of dynamic overload resolution](expressions.md#compile-time-checking-of-dynamic-overload-resolution)), cast expressions ([Cast expressions](expressions.md#cast-expressions)), and assignments ([Assignment operators](expressions.md#assignment-operators)).</span></span>

<span data-ttu-id="463f3-125">Die vordefinierten impliziten Konvertierungen sind immer erfolgreich und bewirken nie, dass Ausnahmen ausgelöst werden.</span><span class="sxs-lookup"><span data-stu-id="463f3-125">The pre-defined implicit conversions always succeed and never cause exceptions to be thrown.</span></span> <span data-ttu-id="463f3-126">Ordnungsgemäß entworfene benutzerdefinierte implizite Konvertierungen sollten auch diese Merkmale aufweisen.</span><span class="sxs-lookup"><span data-stu-id="463f3-126">Properly designed user-defined implicit conversions should exhibit these characteristics as well.</span></span>

<span data-ttu-id="463f3-127">Zum Zweck der Konvertierung werden die Typen `object` und `dynamic` als gleichwertig betrachtet.</span><span class="sxs-lookup"><span data-stu-id="463f3-127">For the purposes of conversion, the types `object` and `dynamic` are considered equivalent.</span></span>

<span data-ttu-id="463f3-128">Dynamische Konvertierungen ([implizite dynamische Konvertierungen](conversions.md#implicit-dynamic-conversions) und [explizite dynamische Konvertierungen](conversions.md#explicit-dynamic-conversions)) gelten jedoch nur für Ausdrücke vom Typ `dynamic` ([der dynamische Typ](types.md#the-dynamic-type)).</span><span class="sxs-lookup"><span data-stu-id="463f3-128">However, dynamic conversions ([Implicit dynamic conversions](conversions.md#implicit-dynamic-conversions) and [Explicit dynamic conversions](conversions.md#explicit-dynamic-conversions)) apply only to expressions of type `dynamic` ([The dynamic type](types.md#the-dynamic-type)).</span></span>

### <a name="identity-conversion"></a><span data-ttu-id="463f3-129">Identitäts Konvertierung</span><span class="sxs-lookup"><span data-stu-id="463f3-129">Identity conversion</span></span>

<span data-ttu-id="463f3-130">Eine Identitäts Konvertierung konvertiert von einem beliebigen Typ in denselben Typ.</span><span class="sxs-lookup"><span data-stu-id="463f3-130">An identity conversion converts from any type to the same type.</span></span> <span data-ttu-id="463f3-131">Diese Konvertierung besteht darin, dass eine Entität, die bereits über einen erforderlichen Typ verfügt, in diesen Typ konvertiert werden kann.</span><span class="sxs-lookup"><span data-stu-id="463f3-131">This conversion exists such that an entity that already has a required type can be said to be convertible to that type.</span></span>

*  <span data-ttu-id="463f3-132">Da `object` und `dynamic` als gleichwertig betrachtet werden, gibt es eine Identitäts Konvertierung zwischen `object` und `dynamic`sowie zwischen konstruierten Typen, die beim Ersetzen aller Vorkommen von `dynamic` durch `object`identisch sind.</span><span class="sxs-lookup"><span data-stu-id="463f3-132">Because `object` and `dynamic` are considered equivalent there is an identity conversion between `object` and `dynamic`, and between constructed types that are the same when replacing all occurrences of `dynamic` with `object`.</span></span>

### <a name="implicit-numeric-conversions"></a><span data-ttu-id="463f3-133">Implizite numerische Konvertierungen</span><span class="sxs-lookup"><span data-stu-id="463f3-133">Implicit numeric conversions</span></span>

<span data-ttu-id="463f3-134">Die impliziten numerischen Konvertierungen lauten:</span><span class="sxs-lookup"><span data-stu-id="463f3-134">The implicit numeric conversions are:</span></span>

*  <span data-ttu-id="463f3-135">Von `sbyte` bis `short`, `int`, `long`, `float`, `double`oder `decimal`.</span><span class="sxs-lookup"><span data-stu-id="463f3-135">From `sbyte` to `short`, `int`, `long`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="463f3-136">Von `byte` bis `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `float`, `double`oder `decimal`.</span><span class="sxs-lookup"><span data-stu-id="463f3-136">From `byte` to `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="463f3-137">Von `short` bis `int`, `long`, `float`, `double`oder `decimal`.</span><span class="sxs-lookup"><span data-stu-id="463f3-137">From `short` to `int`, `long`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="463f3-138">Von `ushort` bis `int`, `uint`, `long`, `ulong`, `float`, `double`oder `decimal`.</span><span class="sxs-lookup"><span data-stu-id="463f3-138">From `ushort` to `int`, `uint`, `long`, `ulong`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="463f3-139">Von `int` bis `long`, `float`, `double`oder `decimal`.</span><span class="sxs-lookup"><span data-stu-id="463f3-139">From `int` to `long`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="463f3-140">Von `uint` bis `long`, `ulong`, `float`, `double`oder `decimal`.</span><span class="sxs-lookup"><span data-stu-id="463f3-140">From `uint` to `long`, `ulong`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="463f3-141">Von `long` bis `float`, `double`oder `decimal`.</span><span class="sxs-lookup"><span data-stu-id="463f3-141">From `long` to `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="463f3-142">Von `ulong` bis `float`, `double`oder `decimal`.</span><span class="sxs-lookup"><span data-stu-id="463f3-142">From `ulong` to `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="463f3-143">Von `char` bis `ushort`, `int`, `uint`, `long`, `ulong`, `float`, `double`oder `decimal`.</span><span class="sxs-lookup"><span data-stu-id="463f3-143">From `char` to `ushort`, `int`, `uint`, `long`, `ulong`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="463f3-144">Von `float` in `double`.</span><span class="sxs-lookup"><span data-stu-id="463f3-144">From `float` to `double`.</span></span>

<span data-ttu-id="463f3-145">Konvertierungen von `int`, `uint`, `long`oder `ulong` in `float` und aus `long` oder `ulong` zu `double` können zu einem Genauigkeits Verlust führen, aber nie zu einem Verlust der Größe führen.</span><span class="sxs-lookup"><span data-stu-id="463f3-145">Conversions from `int`, `uint`, `long`, or `ulong` to `float` and from `long` or `ulong` to `double` may cause a loss of precision, but will never cause a loss of magnitude.</span></span> <span data-ttu-id="463f3-146">Die anderen impliziten numerischen Konvertierungen verlieren nie Informationen.</span><span class="sxs-lookup"><span data-stu-id="463f3-146">The other implicit numeric conversions never lose any information.</span></span>

<span data-ttu-id="463f3-147">Es gibt keine impliziten Konvertierungen in den `char` Typ, sodass Werte der anderen ganzzahligen Typen nicht automatisch in den `char` Typ konvertiert werden.</span><span class="sxs-lookup"><span data-stu-id="463f3-147">There are no implicit conversions to the `char` type, so values of the other integral types do not automatically convert to the `char` type.</span></span>

### <a name="implicit-enumeration-conversions"></a><span data-ttu-id="463f3-148">Implizite Enumerationskonvertierungen</span><span class="sxs-lookup"><span data-stu-id="463f3-148">Implicit enumeration conversions</span></span>

<span data-ttu-id="463f3-149">Eine implizite Enumerationskonvertierung ermöglicht das Konvertieren des *decimal_integer_literal* `0` in beliebige *enum_type* und in beliebige *nullable_type* , deren zugrunde liegender Typ ein *enum_type*ist.</span><span class="sxs-lookup"><span data-stu-id="463f3-149">An implicit enumeration conversion permits the *decimal_integer_literal* `0` to be converted to any *enum_type* and to any *nullable_type* whose underlying type is an *enum_type*.</span></span> <span data-ttu-id="463f3-150">Im letzteren Fall wird die Konvertierung ausgewertet, indem Sie in die zugrunde liegende *enum_type* konvertiert und das Ergebnis umwickelt ([Nullable-Typen](types.md#nullable-types)).</span><span class="sxs-lookup"><span data-stu-id="463f3-150">In the latter case the conversion is evaluated by converting to the underlying *enum_type* and wrapping the result ([Nullable types](types.md#nullable-types)).</span></span>

### <a name="implicit-interpolated-string-conversions"></a><span data-ttu-id="463f3-151">Implizite interinterpolierte Zeichen folgen Konvertierungen</span><span class="sxs-lookup"><span data-stu-id="463f3-151">Implicit interpolated string conversions</span></span>

<span data-ttu-id="463f3-152">Eine implizite interpolierte Zeichen folgen Konvertierung ermöglicht das Konvertieren eines *interpolated_string_expression* ([interpoliert](expressions.md#interpolated-strings)Zeichen folgen) in `System.IFormattable` oder `System.FormattableString` (das `System.IFormattable`implementiert).</span><span class="sxs-lookup"><span data-stu-id="463f3-152">An implicit interpolated string conversion permits an *interpolated_string_expression* ([Interpolated strings](expressions.md#interpolated-strings)) to be converted to `System.IFormattable` or `System.FormattableString` (which implements `System.IFormattable`).</span></span>

<span data-ttu-id="463f3-153">Wenn diese Konvertierung angewendet wird, wird ein Zeichen folgen Wert nicht aus der interinterpolierten Zeichenfolge zusammengesetzt.</span><span class="sxs-lookup"><span data-stu-id="463f3-153">When this conversion is applied a string value is not composed from the interpolated string.</span></span> <span data-ttu-id="463f3-154">Stattdessen wird eine Instanz von `System.FormattableString` erstellt, wie in [interpoliert](expressions.md#interpolated-strings)-Zeichen folgen beschrieben.</span><span class="sxs-lookup"><span data-stu-id="463f3-154">Instead an instance of `System.FormattableString` is created, as further described in [Interpolated strings](expressions.md#interpolated-strings).</span></span>

### <a name="implicit-nullable-conversions"></a><span data-ttu-id="463f3-155">Implizite Konvertierungen, die NULL zulassen</span><span class="sxs-lookup"><span data-stu-id="463f3-155">Implicit nullable conversions</span></span>

<span data-ttu-id="463f3-156">Vordefinierte implizite Konvertierungen, die nicht auf NULL festleg Bare Werttypen angewendet werden, können auch mit null-fähigen Formularen dieser Typen verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="463f3-156">Predefined implicit conversions that operate on non-nullable value types can also be used with nullable forms of those types.</span></span> <span data-ttu-id="463f3-157">Für jede der vordefinierten impliziten Identitäts-und numerischen Konvertierungen, die von einem Werttyp, der keine NULL-Werte zulässt, `S` in einen Werttyp, der nicht auf NULL festgelegt werden kann `T`, sind die folgenden impliziten Konvertierungen vorhanden:</span><span class="sxs-lookup"><span data-stu-id="463f3-157">For each of the predefined implicit identity and numeric conversions that convert from a non-nullable value type `S` to a non-nullable value type `T`, the following implicit nullable conversions exist:</span></span>

*  <span data-ttu-id="463f3-158">Eine implizite Konvertierung von `S?` in `T?`.</span><span class="sxs-lookup"><span data-stu-id="463f3-158">An implicit conversion from `S?` to `T?`.</span></span>
*  <span data-ttu-id="463f3-159">Eine implizite Konvertierung von `S` in `T?`.</span><span class="sxs-lookup"><span data-stu-id="463f3-159">An implicit conversion from `S` to `T?`.</span></span>

<span data-ttu-id="463f3-160">Die Auswertung einer impliziten Konvertierung auf NULL-Werte, die auf einer zugrunde liegenden Konvertierung von `S` in `T` basiert, verläuft wie folgt:</span><span class="sxs-lookup"><span data-stu-id="463f3-160">Evaluation of an implicit nullable conversion based on an underlying conversion from `S` to `T` proceeds as follows:</span></span>

*  <span data-ttu-id="463f3-161">Wenn die Konvertierung, die NULL-Werte zulässt, von `S?` in `T?`erfolgt:</span><span class="sxs-lookup"><span data-stu-id="463f3-161">If the nullable conversion is from `S?` to `T?`:</span></span>
    * <span data-ttu-id="463f3-162">Wenn der Quellwert NULL ist (`HasValue`-Eigenschaft ist false), ist das Ergebnis der NULL-Wert des Typs `T?`.</span><span class="sxs-lookup"><span data-stu-id="463f3-162">If the source value is null (`HasValue` property is false), the result is the null value of type `T?`.</span></span>
    * <span data-ttu-id="463f3-163">Andernfalls wird die Konvertierung als zum Entpacken von `S?` in `S`ausgewertet, gefolgt von der zugrunde liegenden Konvertierung von `S` in `T`, gefolgt von einem Wrapping ([Nullable-Typen](types.md#nullable-types)) von `T` zu `T?`.</span><span class="sxs-lookup"><span data-stu-id="463f3-163">Otherwise, the conversion is evaluated as an unwrapping from `S?` to `S`, followed by the underlying conversion from `S` to `T`, followed by a wrapping ([Nullable types](types.md#nullable-types)) from `T` to `T?`.</span></span>

*  <span data-ttu-id="463f3-164">Wenn die Konvertierung, die NULL-Werte zulässt, von `S` auf `T?`erfolgt, wird die Konvertierung als die zugrunde liegende Konvertierung von `S` in `T` gefolgt von einem Wrapping von `T` zu `T?`ausgewertet.</span><span class="sxs-lookup"><span data-stu-id="463f3-164">If the nullable conversion is from `S` to `T?`, the conversion is evaluated as the underlying conversion from `S` to `T` followed by a wrapping from `T` to `T?`.</span></span>

### <a name="null-literal-conversions"></a><span data-ttu-id="463f3-165">NULL Literale Konvertierungen</span><span class="sxs-lookup"><span data-stu-id="463f3-165">Null literal conversions</span></span>

<span data-ttu-id="463f3-166">Eine implizite Konvertierung ist vom `null` Literaltyp zu einem beliebigen Typ, der NULL-Werte zulässt.</span><span class="sxs-lookup"><span data-stu-id="463f3-166">An implicit conversion exists from the `null` literal to any nullable type.</span></span> <span data-ttu-id="463f3-167">Diese Konvertierung erzeugt den NULL-Wert ([Werte zulässt-Typen](types.md#nullable-types)) des angegebenen Typs, der NULL-Werte zulässt.</span><span class="sxs-lookup"><span data-stu-id="463f3-167">This conversion produces the null value ([Nullable types](types.md#nullable-types)) of the given nullable type.</span></span>

### <a name="implicit-reference-conversions"></a><span data-ttu-id="463f3-168">Implizite Verweis Konvertierungen</span><span class="sxs-lookup"><span data-stu-id="463f3-168">Implicit reference conversions</span></span>

<span data-ttu-id="463f3-169">Die impliziten Verweis Konvertierungen sind:</span><span class="sxs-lookup"><span data-stu-id="463f3-169">The implicit reference conversions are:</span></span>

*  <span data-ttu-id="463f3-170">Von allen *reference_type* bis `object` und `dynamic`.</span><span class="sxs-lookup"><span data-stu-id="463f3-170">From any *reference_type* to `object` and `dynamic`.</span></span>
*  <span data-ttu-id="463f3-171">Von allen *class_type* `S` zu beliebigen *class_type* `T`wird die angegebene `S` von `T`abgeleitet.</span><span class="sxs-lookup"><span data-stu-id="463f3-171">From any *class_type* `S` to any *class_type* `T`, provided `S` is derived from `T`.</span></span>
*  <span data-ttu-id="463f3-172">Von allen *class_type* `S` bis hin zu beliebigen *INTERFACE_TYPE* `T`implementiert `S` `T`implementiert.</span><span class="sxs-lookup"><span data-stu-id="463f3-172">From any *class_type* `S` to any *interface_type* `T`, provided `S` implements `T`.</span></span>
*  <span data-ttu-id="463f3-173">Von allen *INTERFACE_TYPE* `S` zu beliebigen *INTERFACE_TYPE* `T`wird die angegebene `S` von `T`abgeleitet.</span><span class="sxs-lookup"><span data-stu-id="463f3-173">From any *interface_type* `S` to any *interface_type* `T`, provided `S` is derived from `T`.</span></span>
*  <span data-ttu-id="463f3-174">Aus einer *array_type* `S` mit einem Elementtyp `SE` zu einer *array_type* `T` mit einem Elementtyp `TE`, wenn alle folgenden Punkte zutreffen:</span><span class="sxs-lookup"><span data-stu-id="463f3-174">From an *array_type* `S` with an element type `SE` to an *array_type* `T` with an element type `TE`, provided all of the following are true:</span></span>
    * <span data-ttu-id="463f3-175">`S` und `T` unterscheiden sich nur in Elementtyp.</span><span class="sxs-lookup"><span data-stu-id="463f3-175">`S` and `T` differ only in element type.</span></span> <span data-ttu-id="463f3-176">Anders ausgedrückt: `S` und `T` haben die gleiche Anzahl von Dimensionen.</span><span class="sxs-lookup"><span data-stu-id="463f3-176">In other words, `S` and `T` have the same number of dimensions.</span></span>
    * <span data-ttu-id="463f3-177">Sowohl `SE` als auch `TE` sind *reference_type*s.</span><span class="sxs-lookup"><span data-stu-id="463f3-177">Both `SE` and `TE` are *reference_type*s.</span></span>
    * <span data-ttu-id="463f3-178">Eine implizite Verweis Konvertierung ist von `SE` in `TE`vorhanden.</span><span class="sxs-lookup"><span data-stu-id="463f3-178">An implicit reference conversion exists from `SE` to `TE`.</span></span>
*  <span data-ttu-id="463f3-179">Von allen *array_type* bis `System.Array` und den Schnittstellen, die es implementiert.</span><span class="sxs-lookup"><span data-stu-id="463f3-179">From any *array_type* to `System.Array` and the interfaces it implements.</span></span>
*  <span data-ttu-id="463f3-180">Von einem eindimensionalen Arraytyp `S[]` zu `System.Collections.Generic.IList<T>` und dessen Basis Schnittstellen, vorausgesetzt, dass es eine implizite Identität oder Verweis Konvertierung von `S` in `T`gibt.</span><span class="sxs-lookup"><span data-stu-id="463f3-180">From a single-dimensional array type `S[]` to `System.Collections.Generic.IList<T>` and its base interfaces, provided that there is an implicit identity or reference conversion from `S` to `T`.</span></span>
*  <span data-ttu-id="463f3-181">Von allen *delegate_type* bis `System.Delegate` und den Schnittstellen, die es implementiert.</span><span class="sxs-lookup"><span data-stu-id="463f3-181">From any *delegate_type* to `System.Delegate` and the interfaces it implements.</span></span>
*  <span data-ttu-id="463f3-182">Von der NULL-Literale zu beliebigen *reference_type*.</span><span class="sxs-lookup"><span data-stu-id="463f3-182">From the null literal to any *reference_type*.</span></span>
*  <span data-ttu-id="463f3-183">Von allen *reference_type* zu einem *reference_type* `T`, wenn es eine implizite Identität oder Verweis Konvertierung in einen *reference_type* hat `T0` und `T0` über eine Identitäts Konvertierung in `T`verfügt.</span><span class="sxs-lookup"><span data-stu-id="463f3-183">From any *reference_type* to a *reference_type* `T` if it has an implicit identity or reference conversion to a *reference_type* `T0` and `T0` has an identity conversion to `T`.</span></span>
*  <span data-ttu-id="463f3-184">Von einer beliebigen *reference_type* zu einer Schnittstelle oder einem Delegattyp `T`, wenn Sie eine implizite Identität oder Verweis Konvertierung in eine Schnittstelle oder einen Delegattyp aufweist `T0` und `T0` die Varianz konvertierbar ([Varianz Konvertierung](interfaces.md#variance-conversion)) zum `T`ist.</span><span class="sxs-lookup"><span data-stu-id="463f3-184">From any *reference_type* to an interface or delegate type `T` if it has an implicit identity or reference conversion to an interface or delegate type `T0` and `T0` is variance-convertible ([Variance conversion](interfaces.md#variance-conversion)) to `T`.</span></span>
*  <span data-ttu-id="463f3-185">Implizite Konvertierungen mit Typparametern, die als Verweis Typen bekannt sind.</span><span class="sxs-lookup"><span data-stu-id="463f3-185">Implicit conversions involving type parameters that are known to be reference types.</span></span> <span data-ttu-id="463f3-186">Weitere Informationen zu impliziten Konvertierungen, die Typparameter einschließen, finden Sie unter [implizite Konvertierungen mit Typparametern](conversions.md#implicit-conversions-involving-type-parameters) .</span><span class="sxs-lookup"><span data-stu-id="463f3-186">See [Implicit conversions involving type parameters](conversions.md#implicit-conversions-involving-type-parameters) for more details on implicit conversions involving type parameters.</span></span>

<span data-ttu-id="463f3-187">Die impliziten Verweis Konvertierungen sind Konvertierungen zwischen *reference_type*en, die sich als immer erfolgreich erweisen können und daher keine Überprüfungen zur Laufzeit erfordern.</span><span class="sxs-lookup"><span data-stu-id="463f3-187">The implicit reference conversions are those conversions between *reference_type*s that can be proven to always succeed, and therefore require no checks at run-time.</span></span>

<span data-ttu-id="463f3-188">Verweis Konvertierungen, implizit oder explizit, ändern niemals die referenzielle Identität des Objekts, das konvertiert wird.</span><span class="sxs-lookup"><span data-stu-id="463f3-188">Reference conversions, implicit or explicit, never change the referential identity of the object being converted.</span></span> <span data-ttu-id="463f3-189">Anders ausgedrückt: während eine Verweis Konvertierung den Typ des Verweises ändern kann, ändert Sie niemals den Typ oder Wert des Objekts, auf das verwiesen wird.</span><span class="sxs-lookup"><span data-stu-id="463f3-189">In other words, while a reference conversion may change the type of the reference, it never changes the type or value of the object being referred to.</span></span>

### <a name="boxing-conversions"></a><span data-ttu-id="463f3-190">Boxing-Konvertierungen</span><span class="sxs-lookup"><span data-stu-id="463f3-190">Boxing conversions</span></span>

<span data-ttu-id="463f3-191">Eine Boxing-Konvertierung ermöglicht das implizite Konvertieren eines *value_type* in einen Verweistyp.</span><span class="sxs-lookup"><span data-stu-id="463f3-191">A boxing conversion permits a *value_type* to be implicitly converted to a reference type.</span></span> <span data-ttu-id="463f3-192">Eine Boxing-Konvertierung ist von allen *non_nullable_value_type* zu `object` und `dynamic`, `System.ValueType` und in alle *INTERFACE_TYPE* , die vom *non_nullable_value_type*implementiert werden, vorhanden.</span><span class="sxs-lookup"><span data-stu-id="463f3-192">A boxing conversion exists from any *non_nullable_value_type* to `object` and `dynamic`, to `System.ValueType` and to any *interface_type* implemented by the *non_nullable_value_type*.</span></span> <span data-ttu-id="463f3-193">Außerdem kann eine *enum_type* in den Typ `System.Enum`konvertiert werden.</span><span class="sxs-lookup"><span data-stu-id="463f3-193">Furthermore an *enum_type* can be converted to the type `System.Enum`.</span></span>

<span data-ttu-id="463f3-194">Eine Boxing-Konvertierung ist aus einer *nullable_type* in einen Verweistyp vorhanden, und zwar nur dann, wenn eine Boxing-Konvertierung von der zugrunde liegenden *non_nullable_value_type* in den Verweistyp vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="463f3-194">A boxing conversion exists from a *nullable_type* to a reference type, if and only if a boxing conversion exists from the underlying *non_nullable_value_type* to the reference type.</span></span>

<span data-ttu-id="463f3-195">Ein Werttyp verfügt über eine Boxing-Konvertierung in einen Schnittstellentyp `I` wenn er eine Boxing-Konvertierung in einen Schnittstellentyp `I0` und `I0` über eine Identitäts Konvertierung in `I`verfügt.</span><span class="sxs-lookup"><span data-stu-id="463f3-195">A value type has a boxing conversion to an interface type `I` if it has a boxing conversion to an interface type `I0` and `I0` has an identity conversion to `I`.</span></span>

<span data-ttu-id="463f3-196">Ein Werttyp verfügt über eine Boxing-Konvertierung in einen Schnittstellentyp `I` wenn er eine Boxing-Konvertierung in eine Schnittstelle oder einen Delegattyp aufweist `I0` und `I0` Varianz konvertierbar ([Varianz Konvertierung](interfaces.md#variance-conversion)) zum `I`ist.</span><span class="sxs-lookup"><span data-stu-id="463f3-196">A value type has a boxing conversion to an interface type `I` if it has a boxing conversion to an interface or delegate type `I0` and `I0` is variance-convertible ([Variance conversion](interfaces.md#variance-conversion)) to `I`.</span></span>

<span data-ttu-id="463f3-197">Das Boxing eines Werts einer *non_nullable_value_type* besteht aus der Zuordnung einer Objektinstanz und dem Kopieren des *value_type* Werts in diese Instanz.</span><span class="sxs-lookup"><span data-stu-id="463f3-197">Boxing a value of a *non_nullable_value_type* consists of allocating an object instance and copying the *value_type* value into that instance.</span></span> <span data-ttu-id="463f3-198">Eine Struktur kann in den Typ `System.ValueType`gekapselt werden, da dies eine Basisklasse für alle Strukturen ([Vererbung](structs.md#inheritance)) ist.</span><span class="sxs-lookup"><span data-stu-id="463f3-198">A struct can be boxed to the type `System.ValueType`, since that is a base class for all structs ([Inheritance](structs.md#inheritance)).</span></span>

<span data-ttu-id="463f3-199">Das Boxing eines Werts eines *nullable_type* verläuft wie folgt:</span><span class="sxs-lookup"><span data-stu-id="463f3-199">Boxing a value of a *nullable_type* proceeds as follows:</span></span>

*  <span data-ttu-id="463f3-200">Wenn der Quellwert NULL ist (`HasValue`-Eigenschaft ist false), ist das Ergebnis ein NULL-Verweis des Zieltyps.</span><span class="sxs-lookup"><span data-stu-id="463f3-200">If the source value is null (`HasValue` property is false), the result is a null reference of the target type.</span></span>
*  <span data-ttu-id="463f3-201">Andernfalls ist das Ergebnis ein Verweis auf eine `T`, die durch das Entpacken und Boxing des Quell Werts erzeugt wird.</span><span class="sxs-lookup"><span data-stu-id="463f3-201">Otherwise, the result is a reference to a boxed `T` produced by unwrapping and boxing the source value.</span></span>

<span data-ttu-id="463f3-202">Boxing-Konvertierungen werden weiter unten in [Boxing-Konvertierungen](types.md#boxing-conversions)beschrieben.</span><span class="sxs-lookup"><span data-stu-id="463f3-202">Boxing conversions are described further in [Boxing conversions](types.md#boxing-conversions).</span></span>

### <a name="implicit-dynamic-conversions"></a><span data-ttu-id="463f3-203">Implizite dynamische Konvertierungen</span><span class="sxs-lookup"><span data-stu-id="463f3-203">Implicit dynamic conversions</span></span>

<span data-ttu-id="463f3-204">Eine implizite dynamische Konvertierung ist von einem Ausdruck vom Typ `dynamic` in einen beliebigen Typ `T`vorhanden.</span><span class="sxs-lookup"><span data-stu-id="463f3-204">An implicit dynamic conversion exists from an expression of type `dynamic` to any type `T`.</span></span> <span data-ttu-id="463f3-205">Die Konvertierung ist dynamisch gebunden ([dynamische Bindung](expressions.md#dynamic-binding)). Dies bedeutet, dass eine implizite Konvertierung zur Laufzeit vom Lauf Zeittyp des Ausdrucks zum `T`durchgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="463f3-205">The conversion is dynamically bound ([Dynamic binding](expressions.md#dynamic-binding)), which means that an implicit conversion will be sought at run-time from the run-time type of the expression to `T`.</span></span> <span data-ttu-id="463f3-206">Wenn keine Konvertierung gefunden wird, wird eine Lauf Zeit Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="463f3-206">If no conversion is found, a run-time exception is thrown.</span></span>

<span data-ttu-id="463f3-207">Beachten Sie, dass diese implizite Konvertierung scheinbar gegen den Rat am Anfang von [impliziten Konvertierungen](conversions.md#implicit-conversions) verstößt, dass eine implizite Konvertierung nie eine Ausnahme auslösen sollte.</span><span class="sxs-lookup"><span data-stu-id="463f3-207">Note that this implicit conversion seemingly violates the advice in the beginning of [Implicit conversions](conversions.md#implicit-conversions) that an implicit conversion should never cause an exception.</span></span> <span data-ttu-id="463f3-208">Dabei handelt es sich jedoch nicht um die Konvertierung, sondern um die *Suche nach* der Konvertierung, die die Ausnahme verursacht.</span><span class="sxs-lookup"><span data-stu-id="463f3-208">However it is not the conversion itself, but the *finding* of the conversion that causes the exception.</span></span> <span data-ttu-id="463f3-209">Das Risiko von Lauf Zeit Ausnahmen ist die Verwendung der dynamischen Bindung.</span><span class="sxs-lookup"><span data-stu-id="463f3-209">The risk of run-time exceptions is inherent in the use of dynamic binding.</span></span> <span data-ttu-id="463f3-210">Wenn die dynamische Bindung der Konvertierung nicht erwünscht ist, kann der Ausdruck zuerst in `object`und dann in den gewünschten Typ konvertiert werden.</span><span class="sxs-lookup"><span data-stu-id="463f3-210">If dynamic binding of the conversion is not desired, the expression can be first converted to `object`, and then to the desired type.</span></span>

<span data-ttu-id="463f3-211">Das folgende Beispiel veranschaulicht implizite dynamische Konvertierungen:</span><span class="sxs-lookup"><span data-stu-id="463f3-211">The following example illustrates implicit dynamic conversions:</span></span>

```csharp
object o  = "object"
dynamic d = "dynamic";

string s1 = o; // Fails at compile-time -- no conversion exists
string s2 = d; // Compiles and succeeds at run-time
int i     = d; // Compiles but fails at run-time -- no conversion exists
```

<span data-ttu-id="463f3-212">Die Zuweisungen zu `s2` und `i` beide verwenden implizite dynamische Konvertierungen, bei denen die Bindung der Vorgänge bis zur Laufzeit angehalten wird.</span><span class="sxs-lookup"><span data-stu-id="463f3-212">The assignments to `s2` and `i` both employ implicit dynamic conversions, where the binding of the operations is suspended until run-time.</span></span> <span data-ttu-id="463f3-213">Zur Laufzeit werden implizite Konvertierungen vom Lauf Zeittyp `d` -- `string`-bis zum Zieltyp durchgeführt.</span><span class="sxs-lookup"><span data-stu-id="463f3-213">At run-time, implicit conversions are sought from the run-time type of `d` -- `string` -- to the target type.</span></span> <span data-ttu-id="463f3-214">Es wurde eine Konvertierung gefunden, um `string`, aber nicht `int`.</span><span class="sxs-lookup"><span data-stu-id="463f3-214">A conversion is found to `string` but not to `int`.</span></span>

### <a name="implicit-constant-expression-conversions"></a><span data-ttu-id="463f3-215">Implizite Konstante Ausdrucks Konvertierungen</span><span class="sxs-lookup"><span data-stu-id="463f3-215">Implicit constant expression conversions</span></span>

<span data-ttu-id="463f3-216">Eine implizite Konstante Ausdrucks Konvertierung ermöglicht die folgenden Konvertierungen:</span><span class="sxs-lookup"><span data-stu-id="463f3-216">An implicit constant expression conversion permits the following conversions:</span></span>

*  <span data-ttu-id="463f3-217">Eine *constant_expression* ([Konstante Ausdrücke](expressions.md#constant-expressions)) vom Typ `int` kann in den Typ `sbyte`, `byte`, `short`, `ushort`, `uint`oder `ulong`konvertiert werden, sofern der Wert des *constant_expression* innerhalb des Bereichs des Zieltyps liegt.</span><span class="sxs-lookup"><span data-stu-id="463f3-217">A *constant_expression* ([Constant expressions](expressions.md#constant-expressions)) of type `int` can be converted to type `sbyte`, `byte`, `short`, `ushort`, `uint`, or `ulong`, provided the value of the *constant_expression* is within the range of the destination type.</span></span>
*  <span data-ttu-id="463f3-218">Eine *constant_expression* vom Typ `long` kann in den Typ `ulong`konvertiert werden, sofern der Wert des *constant_expression* nicht negativ ist.</span><span class="sxs-lookup"><span data-stu-id="463f3-218">A *constant_expression* of type `long` can be converted to type `ulong`, provided the value of the *constant_expression* is not negative.</span></span>

### <a name="implicit-conversions-involving-type-parameters"></a><span data-ttu-id="463f3-219">Implizite Konvertierungen mit Typparametern</span><span class="sxs-lookup"><span data-stu-id="463f3-219">Implicit conversions involving type parameters</span></span>

<span data-ttu-id="463f3-220">Die folgenden impliziten Konvertierungen sind für einen angegebenen Typparameter `T`vorhanden:</span><span class="sxs-lookup"><span data-stu-id="463f3-220">The following implicit conversions exist for a given type parameter `T`:</span></span>

*  <span data-ttu-id="463f3-221">Von `T` bis zur effektiven Basisklasse `C`, von `T` zu einer beliebigen Basisklasse `C`und von `T` bis zu einer beliebigen Schnittstelle, die von `C`implementiert wird.</span><span class="sxs-lookup"><span data-stu-id="463f3-221">From `T` to its effective base class `C`, from `T` to any base class of `C`, and from `T` to any interface implemented by `C`.</span></span> <span data-ttu-id="463f3-222">Wenn `T` ein Werttyp ist, wird die Konvertierung zur Laufzeit als Boxing-Konvertierung ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="463f3-222">At run-time, if `T` is a value type, the conversion is executed as a boxing conversion.</span></span> <span data-ttu-id="463f3-223">Andernfalls wird die Konvertierung als implizite Verweis Konvertierung oder Identitäts Konvertierung ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="463f3-223">Otherwise, the conversion is executed as an implicit reference conversion or identity conversion.</span></span>
*  <span data-ttu-id="463f3-224">Von `T` bis zu einem Schnittstellentyp `I` in den effektiven Schnittstellen Satz `T`und von `T` auf eine beliebige Basisschnittstelle `I`.</span><span class="sxs-lookup"><span data-stu-id="463f3-224">From `T` to an interface type `I` in `T`'s effective interface set and from `T` to any base interface of `I`.</span></span> <span data-ttu-id="463f3-225">Wenn `T` ein Werttyp ist, wird die Konvertierung zur Laufzeit als Boxing-Konvertierung ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="463f3-225">At run-time, if `T` is a value type, the conversion is executed as a boxing conversion.</span></span> <span data-ttu-id="463f3-226">Andernfalls wird die Konvertierung als implizite Verweis Konvertierung oder Identitäts Konvertierung ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="463f3-226">Otherwise, the conversion is executed as an implicit reference conversion or identity conversion.</span></span>
*  <span data-ttu-id="463f3-227">Von `T` bis zu einem Typparameter `U`ist `T` von `U` abhängig ([Typparameter Einschränkungen](classes.md#type-parameter-constraints)).</span><span class="sxs-lookup"><span data-stu-id="463f3-227">From `T` to a type parameter `U`, provided `T` depends on `U` ([Type parameter constraints](classes.md#type-parameter-constraints)).</span></span> <span data-ttu-id="463f3-228">Wenn `U` ein Werttyp ist, sind `T` und `U` bei der Laufzeit notwendigerweise denselben Typ, und es wird keine Konvertierung durchgeführt.</span><span class="sxs-lookup"><span data-stu-id="463f3-228">At run-time, if `U` is a value type, then `T` and `U` are necessarily the same type and no conversion is performed.</span></span> <span data-ttu-id="463f3-229">Andernfalls, wenn `T` ein Werttyp ist, wird die Konvertierung als Boxing-Konvertierung ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="463f3-229">Otherwise, if `T` is a value type, the conversion is executed as a boxing conversion.</span></span> <span data-ttu-id="463f3-230">Andernfalls wird die Konvertierung als implizite Verweis Konvertierung oder Identitäts Konvertierung ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="463f3-230">Otherwise, the conversion is executed as an implicit reference conversion or identity conversion.</span></span>
*  <span data-ttu-id="463f3-231">Von der NULL-Literale bis zu `T`, wird `T` als Verweistyp bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="463f3-231">From the null literal to `T`, provided `T` is known to be a reference type.</span></span>
*  <span data-ttu-id="463f3-232">Von `T` bis zu einem Verweistyp `I`, wenn eine implizite Konvertierung in einen Verweistyp `S0` und `S0` über eine Identitäts Konvertierung in `S`verfügt.</span><span class="sxs-lookup"><span data-stu-id="463f3-232">From `T` to a reference type `I` if it has an implicit conversion to a reference type `S0` and `S0` has an identity conversion to `S`.</span></span> <span data-ttu-id="463f3-233">Zur Laufzeit wird die Konvertierung auf die gleiche Weise ausgeführt wie die Konvertierung in `S0`.</span><span class="sxs-lookup"><span data-stu-id="463f3-233">At run-time the conversion is executed the same way as the conversion to `S0`.</span></span>
*  <span data-ttu-id="463f3-234">Von `T` bis zu einem Schnittstellentyp `I`, wenn eine implizite Konvertierung in eine Schnittstelle oder einen Delegattyp erfolgt `I0` und `I0` in `I` Varianz konvertierbar ist ([Varianz Konvertierung](interfaces.md#variance-conversion)).</span><span class="sxs-lookup"><span data-stu-id="463f3-234">From `T` to an interface type `I` if it has an implicit conversion to an interface or delegate type `I0` and `I0` is variance-convertible to `I` ([Variance conversion](interfaces.md#variance-conversion)).</span></span> <span data-ttu-id="463f3-235">Wenn `T` ein Werttyp ist, wird die Konvertierung zur Laufzeit als Boxing-Konvertierung ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="463f3-235">At run-time, if `T` is a value type, the conversion is executed as a boxing conversion.</span></span> <span data-ttu-id="463f3-236">Andernfalls wird die Konvertierung als implizite Verweis Konvertierung oder Identitäts Konvertierung ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="463f3-236">Otherwise, the conversion is executed as an implicit reference conversion or identity conversion.</span></span>

<span data-ttu-id="463f3-237">Wenn `T` bekannt ist, dass es sich um einen Verweistyp ([Typparameter Einschränkungen](classes.md#type-parameter-constraints)) handelt, werden die obigen Konvertierungen als implizite Verweis Konvertierungen ([implizite Verweis Konvertierungen](conversions.md#implicit-reference-conversions)) klassifiziert.</span><span class="sxs-lookup"><span data-stu-id="463f3-237">If `T` is known to be a reference type ([Type parameter constraints](classes.md#type-parameter-constraints)), the conversions above are all classified as implicit reference conversions ([Implicit reference conversions](conversions.md#implicit-reference-conversions)).</span></span> <span data-ttu-id="463f3-238">Wenn `T` nicht bekannt ist, dass es sich um einen Verweistyp handelt, werden die obigen Konvertierungen als boxkonvertierungen ([Boxing-Konvertierungen](conversions.md#boxing-conversions)) klassifiziert.</span><span class="sxs-lookup"><span data-stu-id="463f3-238">If `T` is not known to be a reference type, the conversions above are classified as boxing conversions ([Boxing conversions](conversions.md#boxing-conversions)).</span></span>

### <a name="user-defined-implicit-conversions"></a><span data-ttu-id="463f3-239">Benutzerdefinierte implizite Konvertierungen</span><span class="sxs-lookup"><span data-stu-id="463f3-239">User-defined implicit conversions</span></span>

<span data-ttu-id="463f3-240">Eine benutzerdefinierte implizite Konvertierung besteht aus einer optionalen standardmäßigen impliziten Konvertierung, gefolgt von der Ausführung eines benutzerdefinierten impliziten Konvertierungs Operators, gefolgt von einer anderen optionalen standardmäßigen impliziten Konvertierung.</span><span class="sxs-lookup"><span data-stu-id="463f3-240">A user-defined implicit conversion consists of an optional standard implicit conversion, followed by execution of a user-defined implicit conversion operator, followed by another optional standard implicit conversion.</span></span> <span data-ttu-id="463f3-241">Die genauen Regeln für das Auswerten benutzerdefinierter impliziter Konvertierungen werden bei der [Verarbeitung von benutzerdefinierten impliziten Konvertierungen](conversions.md#processing-of-user-defined-implicit-conversions)beschrieben.</span><span class="sxs-lookup"><span data-stu-id="463f3-241">The exact rules for evaluating user-defined implicit conversions are described in [Processing of user-defined implicit conversions](conversions.md#processing-of-user-defined-implicit-conversions).</span></span>

### <a name="anonymous-function-conversions-and-method-group-conversions"></a><span data-ttu-id="463f3-242">Anonyme Funktions Konvertierungen und Methoden Gruppen Konvertierungen</span><span class="sxs-lookup"><span data-stu-id="463f3-242">Anonymous function conversions and method group conversions</span></span>

<span data-ttu-id="463f3-243">Anonyme Funktionen und Methoden Gruppen weisen keine Typen in und von sich selbst auf, können aber implizit in Delegattypen oder Ausdrucks Baumstruktur konvertiert werden.</span><span class="sxs-lookup"><span data-stu-id="463f3-243">Anonymous functions and method groups do not have types in and of themselves, but may be implicitly converted to delegate types or expression tree types.</span></span> <span data-ttu-id="463f3-244">Anonyme Funktions Konvertierungen werden ausführlicher in [Anonyme Funktions Konvertierungen](conversions.md#anonymous-function-conversions) und Methoden Gruppen Konvertierungen in [Methoden Gruppen Konvertierungen](conversions.md#method-group-conversions)beschrieben.</span><span class="sxs-lookup"><span data-stu-id="463f3-244">Anonymous function conversions are described in more detail in [Anonymous function conversions](conversions.md#anonymous-function-conversions) and method group conversions in [Method group conversions](conversions.md#method-group-conversions).</span></span>

## <a name="explicit-conversions"></a><span data-ttu-id="463f3-245">Explizite Konvertierungen</span><span class="sxs-lookup"><span data-stu-id="463f3-245">Explicit conversions</span></span>

<span data-ttu-id="463f3-246">Die folgenden Konvertierungen werden als explizite Konvertierungen klassifiziert:</span><span class="sxs-lookup"><span data-stu-id="463f3-246">The following conversions are classified as explicit conversions:</span></span>

*  <span data-ttu-id="463f3-247">Alle impliziten Konvertierungen.</span><span class="sxs-lookup"><span data-stu-id="463f3-247">All implicit conversions.</span></span>
*  <span data-ttu-id="463f3-248">Explizite numerische Konvertierungen.</span><span class="sxs-lookup"><span data-stu-id="463f3-248">Explicit numeric conversions.</span></span>
*  <span data-ttu-id="463f3-249">Explizite Enumerationskonvertierungen.</span><span class="sxs-lookup"><span data-stu-id="463f3-249">Explicit enumeration conversions.</span></span>
*  <span data-ttu-id="463f3-250">Explizite Konvertierungen, die NULL zulassen.</span><span class="sxs-lookup"><span data-stu-id="463f3-250">Explicit nullable conversions.</span></span>
*  <span data-ttu-id="463f3-251">Explizite Verweis Konvertierungen.</span><span class="sxs-lookup"><span data-stu-id="463f3-251">Explicit reference conversions.</span></span>
*  <span data-ttu-id="463f3-252">Explizite Schnittstellen Konvertierungen.</span><span class="sxs-lookup"><span data-stu-id="463f3-252">Explicit interface conversions.</span></span>
*  <span data-ttu-id="463f3-253">Unboxing-Konvertierungen.</span><span class="sxs-lookup"><span data-stu-id="463f3-253">Unboxing conversions.</span></span>
*  <span data-ttu-id="463f3-254">Explizite dynamische Konvertierungen</span><span class="sxs-lookup"><span data-stu-id="463f3-254">Explicit dynamic conversions</span></span>
*  <span data-ttu-id="463f3-255">Benutzerdefinierte explizite Konvertierungen.</span><span class="sxs-lookup"><span data-stu-id="463f3-255">User-defined explicit conversions.</span></span>

<span data-ttu-id="463f3-256">Explizite Konvertierungen können in Umwandlungs Ausdrücken (Umwandlungs[Ausdrücke](expressions.md#cast-expressions)) auftreten.</span><span class="sxs-lookup"><span data-stu-id="463f3-256">Explicit conversions can occur in cast expressions ([Cast expressions](expressions.md#cast-expressions)).</span></span>

<span data-ttu-id="463f3-257">Der Satz expliziter Konvertierungen umfasst alle impliziten Konvertierungen.</span><span class="sxs-lookup"><span data-stu-id="463f3-257">The set of explicit conversions includes all implicit conversions.</span></span> <span data-ttu-id="463f3-258">Dies bedeutet, dass redundante Umwandlungs Ausdrücke zulässig sind.</span><span class="sxs-lookup"><span data-stu-id="463f3-258">This means that redundant cast expressions are allowed.</span></span>

<span data-ttu-id="463f3-259">Die expliziten Konvertierungen, bei denen es sich nicht um implizite Konvertierungen handelt, sind Konvertierungen, die sich nicht immer als erfolgreich erweisen können, Konvertierungen, die bekanntermaßen Informationen verlieren, und Konvertierungen zwischen Domänen von Typen ausreichend verschieden sind, Angabe.</span><span class="sxs-lookup"><span data-stu-id="463f3-259">The explicit conversions that are not implicit conversions are conversions that cannot be proven to always succeed, conversions that are known to possibly lose information, and conversions across domains of types sufficiently different to merit explicit notation.</span></span>

### <a name="explicit-numeric-conversions"></a><span data-ttu-id="463f3-260">Explizite numerische Konvertierungen</span><span class="sxs-lookup"><span data-stu-id="463f3-260">Explicit numeric conversions</span></span>

<span data-ttu-id="463f3-261">Die expliziten numerischen Konvertierungen sind Konvertierungen von einer *numeric_type* in eine andere *numeric_type* , für die eine implizite numerische Konvertierung ([implizite numerische Konvertierungen](conversions.md#implicit-numeric-conversions)) nicht bereits vorhanden ist:</span><span class="sxs-lookup"><span data-stu-id="463f3-261">The explicit numeric conversions are the conversions from a *numeric_type* to another *numeric_type* for which an implicit numeric conversion ([Implicit numeric conversions](conversions.md#implicit-numeric-conversions)) does not already exist:</span></span>

*  <span data-ttu-id="463f3-262">Von `sbyte` bis `byte`, `ushort`, `uint`, `ulong`oder `char`.</span><span class="sxs-lookup"><span data-stu-id="463f3-262">From `sbyte` to `byte`, `ushort`, `uint`, `ulong`, or `char`.</span></span>
*  <span data-ttu-id="463f3-263">Von `byte` bis `sbyte` und `char`.</span><span class="sxs-lookup"><span data-stu-id="463f3-263">From `byte` to `sbyte` and `char`.</span></span>
*  <span data-ttu-id="463f3-264">Von `short` bis `sbyte`, `byte`, `ushort`, `uint`, `ulong`oder `char`.</span><span class="sxs-lookup"><span data-stu-id="463f3-264">From `short` to `sbyte`, `byte`, `ushort`, `uint`, `ulong`, or `char`.</span></span>
*  <span data-ttu-id="463f3-265">Von `ushort` bis `sbyte`, `byte`, `short`oder `char`.</span><span class="sxs-lookup"><span data-stu-id="463f3-265">From `ushort` to `sbyte`, `byte`, `short`, or `char`.</span></span>
*  <span data-ttu-id="463f3-266">Von `int` bis `sbyte`, `byte`, `short`, `ushort`, `uint`, `ulong`oder `char`.</span><span class="sxs-lookup"><span data-stu-id="463f3-266">From `int` to `sbyte`, `byte`, `short`, `ushort`, `uint`, `ulong`, or `char`.</span></span>
*  <span data-ttu-id="463f3-267">Von `uint` bis `sbyte`, `byte`, `short`, `ushort`, `int`oder `char`.</span><span class="sxs-lookup"><span data-stu-id="463f3-267">From `uint` to `sbyte`, `byte`, `short`, `ushort`, `int`, or `char`.</span></span>
*  <span data-ttu-id="463f3-268">Von `long` bis `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `ulong`oder `char`.</span><span class="sxs-lookup"><span data-stu-id="463f3-268">From `long` to `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `ulong`, or `char`.</span></span>
*  <span data-ttu-id="463f3-269">Von `ulong` bis `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`oder `char`.</span><span class="sxs-lookup"><span data-stu-id="463f3-269">From `ulong` to `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, or `char`.</span></span>
*  <span data-ttu-id="463f3-270">Von `char` bis `sbyte`, `byte`oder `short`.</span><span class="sxs-lookup"><span data-stu-id="463f3-270">From `char` to `sbyte`, `byte`, or `short`.</span></span>
*  <span data-ttu-id="463f3-271">Von `float` bis `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`oder `decimal`.</span><span class="sxs-lookup"><span data-stu-id="463f3-271">From `float` to `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, or `decimal`.</span></span>
*  <span data-ttu-id="463f3-272">Von `double` bis `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`oder `decimal`.</span><span class="sxs-lookup"><span data-stu-id="463f3-272">From `double` to `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, or `decimal`.</span></span>
*  <span data-ttu-id="463f3-273">Von `decimal` bis `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`oder `double`.</span><span class="sxs-lookup"><span data-stu-id="463f3-273">From `decimal` to `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, or `double`.</span></span>

<span data-ttu-id="463f3-274">Da die expliziten Konvertierungen alle impliziten und expliziten numerischen Konvertierungen einschließen, ist es immer möglich, mithilfe eines Umwandlungs Ausdrucks (Umwandlungs[Ausdrücke](expressions.md#cast-expressions)) von beliebigen *numeric_type* in andere *numeric_type* zu konvertieren.</span><span class="sxs-lookup"><span data-stu-id="463f3-274">Because the explicit conversions include all implicit and explicit numeric conversions, it is always possible to convert from any *numeric_type* to any other *numeric_type* using a cast expression ([Cast expressions](expressions.md#cast-expressions)).</span></span>

<span data-ttu-id="463f3-275">Die expliziten numerischen Konvertierungen verlieren möglicherweise Informationen oder bewirken möglicherweise, dass Ausnahmen ausgelöst werden.</span><span class="sxs-lookup"><span data-stu-id="463f3-275">The explicit numeric conversions possibly lose information or possibly cause exceptions to be thrown.</span></span> <span data-ttu-id="463f3-276">Eine explizite numerische Konvertierung wird wie folgt verarbeitet:</span><span class="sxs-lookup"><span data-stu-id="463f3-276">An explicit numeric conversion is processed as follows:</span></span>

*  <span data-ttu-id="463f3-277">Für eine Konvertierung eines ganzzahligen Typs in einen anderen ganzzahligen Typ hängt die Verarbeitung vom Kontext der Überlauf Überprüfung (die aktivierten und deaktivierten[Operatoren](expressions.md#the-checked-and-unchecked-operators)) ab, in der die Konvertierung stattfindet:</span><span class="sxs-lookup"><span data-stu-id="463f3-277">For a conversion from an integral type to another integral type, the processing depends on the overflow checking context ([The checked and unchecked operators](expressions.md#the-checked-and-unchecked-operators)) in which the conversion takes place:</span></span>
    * <span data-ttu-id="463f3-278">In einem `checked` Kontext wird die Konvertierung erfolgreich ausgeführt, wenn der Wert des Quell Operanden innerhalb des Bereichs des Zieltyps liegt, aber eine `System.OverflowException` auslöst, wenn der Wert des Quell Operanden außerhalb des Bereichs des Zieltyps liegt.</span><span class="sxs-lookup"><span data-stu-id="463f3-278">In a `checked` context, the conversion succeeds if the value of the source operand is within the range of the destination type, but throws a `System.OverflowException` if the value of the source operand is outside the range of the destination type.</span></span>
    * <span data-ttu-id="463f3-279">In einem `unchecked` Kontext ist die Konvertierung immer erfolgreich und wird wie folgt fortgesetzt.</span><span class="sxs-lookup"><span data-stu-id="463f3-279">In an `unchecked` context, the conversion always succeeds, and proceeds as follows.</span></span>
        * <span data-ttu-id="463f3-280">Wenn der Quelltyp größer als der Zieltyp ist, wird der Quellwert abgeschnitten, indem die wichtigsten „zusätzlichen“ Teile verworfen werden.</span><span class="sxs-lookup"><span data-stu-id="463f3-280">If the source type is larger than the destination type, then the source value is truncated by discarding its "extra" most significant bits.</span></span> <span data-ttu-id="463f3-281">Das Ergebnis wird dann als Wert des Zieltyps behandelt.</span><span class="sxs-lookup"><span data-stu-id="463f3-281">The result is then treated as a value of the destination type.</span></span>
        * <span data-ttu-id="463f3-282">Wenn der Quelltyp kleiner als der Zieltyp ist, wird der Quellwert entweder mit Vorzeichen oder Nullen (0) erweitert, sodass er die gleiche Größe wie der Zieltyp aufweist.</span><span class="sxs-lookup"><span data-stu-id="463f3-282">If the source type is smaller than the destination type, then the source value is either sign-extended or zero-extended so that it is the same size as the destination type.</span></span> <span data-ttu-id="463f3-283">Die Vorzeichenerweiterung wird verwendet, wenn der Quelltyp mit einem Vorzeichen versehen ist. Die Erweiterung mit Nullen (0) wird verwendet, wenn der Quelltyp mit keinem Vorzeichen versehen ist.</span><span class="sxs-lookup"><span data-stu-id="463f3-283">Sign-extension is used if the source type is signed; zero-extension is used if the source type is unsigned.</span></span> <span data-ttu-id="463f3-284">Das Ergebnis wird dann als Wert des Zieltyps behandelt.</span><span class="sxs-lookup"><span data-stu-id="463f3-284">The result is then treated as a value of the destination type.</span></span>
        * <span data-ttu-id="463f3-285">Wenn der Quelltyp die gleiche Größe wie der Zieltyp aufweist, wird der Quellwert als Wert vom Zieltyp behandelt.</span><span class="sxs-lookup"><span data-stu-id="463f3-285">If the source type is the same size as the destination type, then the source value is treated as a value of the destination type.</span></span>
*  <span data-ttu-id="463f3-286">Bei einer Konvertierung von `decimal` in einen ganzzahligen Typ wird der Quellwert auf 0 (null) bis zum nächstgelegenen ganzzahligen Wert gerundet, und dieser ganzzahlige Wert wird das Ergebnis der Konvertierung.</span><span class="sxs-lookup"><span data-stu-id="463f3-286">For a conversion from `decimal` to an integral type, the source value is rounded towards zero to the nearest integral value, and this integral value becomes the result of the conversion.</span></span> <span data-ttu-id="463f3-287">Wenn sich der resultierende ganzzahlige Wert außerhalb des Bereichs des Zieltyps befindet, wird eine `System.OverflowException` ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="463f3-287">If the resulting integral value is outside the range of the destination type, a `System.OverflowException` is thrown.</span></span>
*  <span data-ttu-id="463f3-288">Bei einer Konvertierung von `float` oder `double` in einen ganzzahligen Typ hängt die Verarbeitung vom Kontext der Überlauf Überprüfung (die aktivierten und deaktivierten[Operatoren](expressions.md#the-checked-and-unchecked-operators)) ab, in der die Konvertierung stattfindet:</span><span class="sxs-lookup"><span data-stu-id="463f3-288">For a conversion from `float` or `double` to an integral type, the processing depends on the overflow checking context ([The checked and unchecked operators](expressions.md#the-checked-and-unchecked-operators)) in which the conversion takes place:</span></span>
    * <span data-ttu-id="463f3-289">In einem `checked` Kontext verläuft die Konvertierung wie folgt:</span><span class="sxs-lookup"><span data-stu-id="463f3-289">In a `checked` context, the conversion proceeds as follows:</span></span>
        * <span data-ttu-id="463f3-290">Wenn der Wert des Operanden NaN oder Infinite ist, wird ein `System.OverflowException` ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="463f3-290">If the value of the operand is NaN or infinite, a `System.OverflowException` is thrown.</span></span>
        * <span data-ttu-id="463f3-291">Andernfalls wird der Quell Operand auf den nächsten ganzzahligen Wert in Richtung 0 (null) gerundet.</span><span class="sxs-lookup"><span data-stu-id="463f3-291">Otherwise, the source operand is rounded towards zero to the nearest integral value.</span></span> <span data-ttu-id="463f3-292">Wenn sich dieser ganzzahlige Wert innerhalb des Bereichs des Zieltyps befindet, ist dieser Wert das Ergebnis der Konvertierung.</span><span class="sxs-lookup"><span data-stu-id="463f3-292">If this integral value is within the range of the destination type then this value is the result of the conversion.</span></span>
        * <span data-ttu-id="463f3-293">Andernfalls wird eine `System.OverflowException` ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="463f3-293">Otherwise, a `System.OverflowException` is thrown.</span></span>
    * <span data-ttu-id="463f3-294">In einem `unchecked` Kontext ist die Konvertierung immer erfolgreich und wird wie folgt fortgesetzt.</span><span class="sxs-lookup"><span data-stu-id="463f3-294">In an `unchecked` context, the conversion always succeeds, and proceeds as follows.</span></span>
        * <span data-ttu-id="463f3-295">Wenn der Wert des Operanden NaN oder Infinite ist, ist das Ergebnis der Konvertierung ein nicht spezifizierter Wert des Zieltyps.</span><span class="sxs-lookup"><span data-stu-id="463f3-295">If the value of the operand is NaN or infinite, the result of the conversion is an unspecified value of the destination type.</span></span>
        * <span data-ttu-id="463f3-296">Andernfalls wird der Quell Operand auf den nächsten ganzzahligen Wert in Richtung 0 (null) gerundet.</span><span class="sxs-lookup"><span data-stu-id="463f3-296">Otherwise, the source operand is rounded towards zero to the nearest integral value.</span></span> <span data-ttu-id="463f3-297">Wenn sich dieser ganzzahlige Wert innerhalb des Bereichs des Zieltyps befindet, ist dieser Wert das Ergebnis der Konvertierung.</span><span class="sxs-lookup"><span data-stu-id="463f3-297">If this integral value is within the range of the destination type then this value is the result of the conversion.</span></span>
        * <span data-ttu-id="463f3-298">Andernfalls ist das Ergebnis der Konvertierung ein nicht spezifizierter Wert des Zieltyps.</span><span class="sxs-lookup"><span data-stu-id="463f3-298">Otherwise, the result of the conversion is an unspecified value of the destination type.</span></span>
*  <span data-ttu-id="463f3-299">Bei einer Konvertierung von `double` in `float`wird der `double` Wert auf den nächsten `float` Wert gerundet.</span><span class="sxs-lookup"><span data-stu-id="463f3-299">For a conversion from `double` to `float`, the `double` value is rounded to the nearest `float` value.</span></span> <span data-ttu-id="463f3-300">Wenn der `double` Wert zu klein ist, um als `float`darzustellen, wird das Ergebnis positiv 0 (null) oder negativ 0 (null).</span><span class="sxs-lookup"><span data-stu-id="463f3-300">If the `double` value is too small to represent as a `float`, the result becomes positive zero or negative zero.</span></span> <span data-ttu-id="463f3-301">Wenn der `double` Wert zu groß ist, um als `float`darzustellen, wird das Ergebnis positiv unendlich oder minus unendlich.</span><span class="sxs-lookup"><span data-stu-id="463f3-301">If the `double` value is too large to represent as a `float`, the result becomes positive infinity or negative infinity.</span></span> <span data-ttu-id="463f3-302">Wenn der `double` Wert NaN ist, ist das Ergebnis ebenfalls NaN.</span><span class="sxs-lookup"><span data-stu-id="463f3-302">If the `double` value is NaN, the result is also NaN.</span></span>
*  <span data-ttu-id="463f3-303">Bei einer Konvertierung von `float` oder `double` zu `decimal`wird der Quellwert in `decimal` Darstellung konvertiert und bei Bedarf auf die nächste Zahl nach dem 28. Dezimaltrennzeichen gerundet ([der Decimal-Typ](types.md#the-decimal-type)).</span><span class="sxs-lookup"><span data-stu-id="463f3-303">For a conversion from `float` or `double` to `decimal`, the source value is converted to `decimal` representation and rounded to the nearest number after the 28th decimal place if required ([The decimal type](types.md#the-decimal-type)).</span></span> <span data-ttu-id="463f3-304">Wenn der Quellwert zu klein ist, um als `decimal`darzustellen, wird das Ergebnis 0 (null).</span><span class="sxs-lookup"><span data-stu-id="463f3-304">If the source value is too small to represent as a `decimal`, the result becomes zero.</span></span> <span data-ttu-id="463f3-305">Wenn der Quellwert Nan, Infinity oder zu groß ist, um als `decimal`darzustellen, wird eine `System.OverflowException` ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="463f3-305">If the source value is NaN, infinity, or too large to represent as a `decimal`, a `System.OverflowException` is thrown.</span></span>
*  <span data-ttu-id="463f3-306">Bei einer Konvertierung von `decimal` in `float` oder `double`wird der `decimal` Wert auf den nächstgelegenen `double` oder `float` Wert gerundet.</span><span class="sxs-lookup"><span data-stu-id="463f3-306">For a conversion from `decimal` to `float` or `double`, the `decimal` value is rounded to the nearest `double` or `float` value.</span></span> <span data-ttu-id="463f3-307">Während diese Konvertierung die Genauigkeit verlieren kann, bewirkt dies nie, dass eine Ausnahme ausgelöst wird.</span><span class="sxs-lookup"><span data-stu-id="463f3-307">While this conversion may lose precision, it never causes an exception to be thrown.</span></span>

### <a name="explicit-enumeration-conversions"></a><span data-ttu-id="463f3-308">Explizite Enumerationskonvertierungen</span><span class="sxs-lookup"><span data-stu-id="463f3-308">Explicit enumeration conversions</span></span>

<span data-ttu-id="463f3-309">Die expliziten Enumerationskonvertierungen sind:</span><span class="sxs-lookup"><span data-stu-id="463f3-309">The explicit enumeration conversions are:</span></span>

*  <span data-ttu-id="463f3-310">Von `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, `double`oder `decimal` zu beliebigen *enum_type*.</span><span class="sxs-lookup"><span data-stu-id="463f3-310">From `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, `double`, or `decimal` to any *enum_type*.</span></span>
*  <span data-ttu-id="463f3-311">Von allen *enum_type* bis `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, `double`oder `decimal`.</span><span class="sxs-lookup"><span data-stu-id="463f3-311">From any *enum_type* to `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="463f3-312">Von allen *enum_type* zu anderen *enum_type*.</span><span class="sxs-lookup"><span data-stu-id="463f3-312">From any *enum_type* to any other *enum_type*.</span></span>

<span data-ttu-id="463f3-313">Eine explizite Enumerationskonvertierung zwischen zwei Typen wird verarbeitet, indem alle Beteiligten *enum_type* als zugrunde liegender Typ dieser *enum_type*behandelt und dann eine implizite oder explizite numerische Konvertierung zwischen den resultierenden Typen durchgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="463f3-313">An explicit enumeration conversion between two types is processed by treating any participating *enum_type* as the underlying type of that *enum_type*, and then performing an implicit or explicit numeric conversion between the resulting types.</span></span> <span data-ttu-id="463f3-314">Wenn z. b. eine *enum_type* `E` mit und zugrunde liegender `int`ist, wird eine Konvertierung von `E` in `byte` als explizite numerische Konvertierung ([explizite numerische Konvertierungen](conversions.md#explicit-numeric-conversions)) von `int` in `byte`verarbeitet, und eine Konvertierung von `byte` in `E` wird als implizite numerische Konvertierung ([implizite numerische Konvertierungen](conversions.md#implicit-numeric-conversions)) von `byte` in `int`verarbeitet.</span><span class="sxs-lookup"><span data-stu-id="463f3-314">For example, given an *enum_type* `E` with and underlying type of `int`, a conversion from `E` to `byte` is processed as an explicit numeric conversion ([Explicit numeric conversions](conversions.md#explicit-numeric-conversions)) from `int` to `byte`, and a conversion from `byte` to `E` is processed as an implicit numeric conversion ([Implicit numeric conversions](conversions.md#implicit-numeric-conversions)) from `byte` to `int`.</span></span>

### <a name="explicit-nullable-conversions"></a><span data-ttu-id="463f3-315">Explizite Konvertierungen, die NULL zulassen</span><span class="sxs-lookup"><span data-stu-id="463f3-315">Explicit nullable conversions</span></span>

<span data-ttu-id="463f3-316">***Explizite Konvertierungen*** , die NULL-Werte zulassen, ermöglichen vordefinierte explizite Konvertierungen, die für nicht auf NULL festleg Bare Werttypen verwendet werden, auch mit null-fähigen Formen dieser Typen</span><span class="sxs-lookup"><span data-stu-id="463f3-316">***Explicit nullable conversions*** permit predefined explicit conversions that operate on non-nullable value types to also be used with nullable forms of those types.</span></span> <span data-ttu-id="463f3-317">Für jede der vordefinierten expliziten Konvertierungen, die von einem Werttyp, der keine NULL-Werte zulässt, `S` in einen Werttyp, der keine NULL-Werte zulässt `T` ([Identitäts Konvertierung](conversions.md#identity-conversion), [implizite numerische Konvertierungen](conversions.md#implicit-numeric-conversions), [Implizite Enumerationskonvertierungen](conversions.md#implicit-enumeration-conversions), [explizite numerische Konvertierungen](conversions.md#explicit-numeric-conversions)und [Explizite Enumerationskonvertierungen](conversions.md#explicit-enumeration-conversions)), sind die folgenden Konvertierungen</span><span class="sxs-lookup"><span data-stu-id="463f3-317">For each of the predefined explicit conversions that convert from a non-nullable value type `S` to a non-nullable value type `T` ([Identity conversion](conversions.md#identity-conversion), [Implicit numeric conversions](conversions.md#implicit-numeric-conversions), [Implicit enumeration conversions](conversions.md#implicit-enumeration-conversions), [Explicit numeric conversions](conversions.md#explicit-numeric-conversions), and [Explicit enumeration conversions](conversions.md#explicit-enumeration-conversions)), the following nullable conversions exist:</span></span>

*  <span data-ttu-id="463f3-318">Eine explizite Konvertierung von `S?` in `T?`.</span><span class="sxs-lookup"><span data-stu-id="463f3-318">An explicit conversion from `S?` to `T?`.</span></span>
*  <span data-ttu-id="463f3-319">Eine explizite Konvertierung von `S` in `T?`.</span><span class="sxs-lookup"><span data-stu-id="463f3-319">An explicit conversion from `S` to `T?`.</span></span>
*  <span data-ttu-id="463f3-320">Eine explizite Konvertierung von `S?` in `T`.</span><span class="sxs-lookup"><span data-stu-id="463f3-320">An explicit conversion from `S?` to `T`.</span></span>

<span data-ttu-id="463f3-321">Die Auswertung einer Konvertierung, die NULL-Werte zulässt, basierend auf einer zugrunde liegenden Konvertierung von `S` in `T` verläuft wie folgt:</span><span class="sxs-lookup"><span data-stu-id="463f3-321">Evaluation of a nullable conversion based on an underlying conversion from `S` to `T` proceeds as follows:</span></span>

*  <span data-ttu-id="463f3-322">Wenn die Konvertierung, die NULL-Werte zulässt, von `S?` in `T?`erfolgt:</span><span class="sxs-lookup"><span data-stu-id="463f3-322">If the nullable conversion is from `S?` to `T?`:</span></span>
    * <span data-ttu-id="463f3-323">Wenn der Quellwert NULL ist (`HasValue`-Eigenschaft ist false), ist das Ergebnis der NULL-Wert des Typs `T?`.</span><span class="sxs-lookup"><span data-stu-id="463f3-323">If the source value is null (`HasValue` property is false), the result is the null value of type `T?`.</span></span>
    * <span data-ttu-id="463f3-324">Andernfalls wird die Konvertierung als ein zum Entpacken von `S?` in `S`ausgewertet, gefolgt von der zugrunde liegenden Konvertierung von `S` in `T`, gefolgt von einer Konvertierung von `T` zu `T?`.</span><span class="sxs-lookup"><span data-stu-id="463f3-324">Otherwise, the conversion is evaluated as an unwrapping from `S?` to `S`, followed by the underlying conversion from `S` to `T`, followed by a wrapping from `T` to `T?`.</span></span>
*  <span data-ttu-id="463f3-325">Wenn die Konvertierung, die NULL-Werte zulässt, von `S` auf `T?`erfolgt, wird die Konvertierung als die zugrunde liegende Konvertierung von `S` in `T` gefolgt von einem Wrapping von `T` zu `T?`ausgewertet.</span><span class="sxs-lookup"><span data-stu-id="463f3-325">If the nullable conversion is from `S` to `T?`, the conversion is evaluated as the underlying conversion from `S` to `T` followed by a wrapping from `T` to `T?`.</span></span>
*  <span data-ttu-id="463f3-326">Wenn die Konvertierung, die NULL-Werte zulässt, von `S?` in `T`erfolgt, wird die Konvertierung als ein zum Entpacken von `S?` in `S` gefolgt von der zugrunde liegenden Konvertierung von `S` in `T`ausgewertet.</span><span class="sxs-lookup"><span data-stu-id="463f3-326">If the nullable conversion is from `S?` to `T`, the conversion is evaluated as an unwrapping from `S?` to `S` followed by the underlying conversion from `S` to `T`.</span></span>

<span data-ttu-id="463f3-327">Beachten Sie, dass beim Versuch, einen Werte zulässt-Wert zu entpacken, eine Ausnahme ausgelöst wird, wenn der Wert `null`ist.</span><span class="sxs-lookup"><span data-stu-id="463f3-327">Note that an attempt to unwrap a nullable value will throw an exception if the value is `null`.</span></span>

### <a name="explicit-reference-conversions"></a><span data-ttu-id="463f3-328">Explizite Verweis Konvertierungen</span><span class="sxs-lookup"><span data-stu-id="463f3-328">Explicit reference conversions</span></span>

<span data-ttu-id="463f3-329">Die expliziten Verweis Konvertierungen lauten:</span><span class="sxs-lookup"><span data-stu-id="463f3-329">The explicit reference conversions are:</span></span>

*  <span data-ttu-id="463f3-330">Von `object` und `dynamic` bis hin zu anderen *reference_type*.</span><span class="sxs-lookup"><span data-stu-id="463f3-330">From `object` and `dynamic` to any other *reference_type*.</span></span>
*  <span data-ttu-id="463f3-331">Von allen *class_type* `S` bis hin zu beliebigen *class_type* `T`ist die angegebene `S` eine Basisklasse von `T`.</span><span class="sxs-lookup"><span data-stu-id="463f3-331">From any *class_type* `S` to any *class_type* `T`, provided `S` is a base class of `T`.</span></span>
*  <span data-ttu-id="463f3-332">Von allen *class_type* `S` bis hin zu beliebigen *INTERFACE_TYPE* `T`ist die angegebene `S` nicht versiegelt und bereitgestellt `S` implementiert `T`nicht.</span><span class="sxs-lookup"><span data-stu-id="463f3-332">From any *class_type* `S` to any *interface_type* `T`, provided `S` is not sealed and provided `S` does not implement `T`.</span></span>
*  <span data-ttu-id="463f3-333">Von allen *INTERFACE_TYPE* `S` bis hin zu beliebigen *class_type* `T`ist die angegebene `T` nicht versiegelt oder bereitgestellt `T` implementiert `S`.</span><span class="sxs-lookup"><span data-stu-id="463f3-333">From any *interface_type* `S` to any *class_type* `T`, provided `T` is not sealed or provided `T` implements `S`.</span></span>
*  <span data-ttu-id="463f3-334">Von allen *INTERFACE_TYPE* `S` zu beliebigen *INTERFACE_TYPE* `T`wird die angegebene `S` nicht von `T`abgeleitet.</span><span class="sxs-lookup"><span data-stu-id="463f3-334">From any *interface_type* `S` to any *interface_type* `T`, provided `S` is not derived from `T`.</span></span>
*  <span data-ttu-id="463f3-335">Aus einer *array_type* `S` mit einem Elementtyp `SE` zu einer *array_type* `T` mit einem Elementtyp `TE`, wenn alle folgenden Punkte zutreffen:</span><span class="sxs-lookup"><span data-stu-id="463f3-335">From an *array_type* `S` with an element type `SE` to an *array_type* `T` with an element type `TE`, provided all of the following are true:</span></span>
    * <span data-ttu-id="463f3-336">`S` und `T` unterscheiden sich nur in Elementtyp.</span><span class="sxs-lookup"><span data-stu-id="463f3-336">`S` and `T` differ only in element type.</span></span> <span data-ttu-id="463f3-337">Anders ausgedrückt: `S` und `T` haben die gleiche Anzahl von Dimensionen.</span><span class="sxs-lookup"><span data-stu-id="463f3-337">In other words, `S` and `T` have the same number of dimensions.</span></span>
    * <span data-ttu-id="463f3-338">Sowohl `SE` als auch `TE` sind *reference_type*s.</span><span class="sxs-lookup"><span data-stu-id="463f3-338">Both `SE` and `TE` are *reference_type*s.</span></span>
    * <span data-ttu-id="463f3-339">Eine explizite Verweis Konvertierung ist von `SE` in `TE`vorhanden.</span><span class="sxs-lookup"><span data-stu-id="463f3-339">An explicit reference conversion exists from `SE` to `TE`.</span></span>
*  <span data-ttu-id="463f3-340">Von `System.Array` und den Schnittstellen, die es für beliebige *array_type*implementiert.</span><span class="sxs-lookup"><span data-stu-id="463f3-340">From `System.Array` and the interfaces it implements to any *array_type*.</span></span>
*  <span data-ttu-id="463f3-341">Von einem eindimensionalen Arraytyp `S[]` zu `System.Collections.Generic.IList<T>` und den zugehörigen Basis Schnittstellen, vorausgesetzt, dass es eine explizite Verweis Konvertierung von `S` in `T`gibt.</span><span class="sxs-lookup"><span data-stu-id="463f3-341">From a single-dimensional array type `S[]` to `System.Collections.Generic.IList<T>` and its base interfaces, provided that there is an explicit reference conversion from `S` to `T`.</span></span>
*  <span data-ttu-id="463f3-342">Von `System.Collections.Generic.IList<S>` und den zugehörigen Basis Schnittstellen bis zu einem eindimensionalen Arraytyp `T[]`, vorausgesetzt, dass es eine explizite Identitäts-oder Verweis Konvertierung von `S` in `T`gibt.</span><span class="sxs-lookup"><span data-stu-id="463f3-342">From `System.Collections.Generic.IList<S>` and its base interfaces to a single-dimensional array type `T[]`, provided that there is an explicit identity or reference conversion from `S` to `T`.</span></span>
*  <span data-ttu-id="463f3-343">Von `System.Delegate` und den Schnittstellen, die es für beliebige *delegate_type*implementiert.</span><span class="sxs-lookup"><span data-stu-id="463f3-343">From `System.Delegate` and the interfaces it implements to any *delegate_type*.</span></span>
*  <span data-ttu-id="463f3-344">Von einem Referenztyp zu einem Verweistyp `T`, wenn er eine explizite Verweis Konvertierung in einen Verweistyp aufweist `T0` und `T0` über eine Identitäts Konvertierung `T`verfügt.</span><span class="sxs-lookup"><span data-stu-id="463f3-344">From a reference type to a reference type `T` if it has an explicit reference conversion to a reference type `T0` and `T0` has an identity conversion `T`.</span></span>
*  <span data-ttu-id="463f3-345">Von einem Referenztyp zu einer Schnittstelle oder einem Delegattyp `T`, wenn er eine explizite Verweis Konvertierung in eine Schnittstelle oder einen Delegattyp aufweist `T0` und entweder `T0` Varianz konvertierbar in `T` oder `T` von Varianz konvertierbar in `T0` ([Varianz Konvertierung](interfaces.md#variance-conversion)) ist.</span><span class="sxs-lookup"><span data-stu-id="463f3-345">From a reference type to an interface or delegate type `T` if it has an explicit reference conversion to an interface or delegate type `T0` and either `T0` is variance-convertible to `T` or `T` is variance-convertible to `T0` ([Variance conversion](interfaces.md#variance-conversion)).</span></span>
*  <span data-ttu-id="463f3-346">Von `D<S1...Sn>` bis `D<T1...Tn>`, bei dem `D<X1...Xn>` ein generischer Delegattyp ist, ist `D<S1...Sn>` nicht mit `D<T1...Tn>`kompatibel, und für jeden Typparameter `Xi` `D` Folgendes:</span><span class="sxs-lookup"><span data-stu-id="463f3-346">From `D<S1...Sn>` to `D<T1...Tn>` where `D<X1...Xn>` is a generic delegate type, `D<S1...Sn>` is not compatible with or identical to `D<T1...Tn>`, and for each type parameter `Xi` of `D` the following holds:</span></span>
    * <span data-ttu-id="463f3-347">Wenn `Xi` invariant ist, ist `Si` identisch mit `Ti`.</span><span class="sxs-lookup"><span data-stu-id="463f3-347">If `Xi` is invariant, then `Si` is identical to `Ti`.</span></span>
    * <span data-ttu-id="463f3-348">Wenn `Xi` kovariant ist, gibt es eine implizite oder explizite Identitäts-oder Verweis Konvertierung von `Si` in `Ti`.</span><span class="sxs-lookup"><span data-stu-id="463f3-348">If `Xi` is covariant, then there is an implicit or explicit identity or reference conversion from `Si` to `Ti`.</span></span>
    * <span data-ttu-id="463f3-349">Wenn `Xi` kontra Variant ist, sind `Si` und `Ti` entweder identische oder beide Verweis Typen.</span><span class="sxs-lookup"><span data-stu-id="463f3-349">If `Xi` is contravariant, then `Si` and `Ti` are either identical or both reference types.</span></span>
*  <span data-ttu-id="463f3-350">Explizite Konvertierungen mit Typparametern, die als Verweis Typen bekannt sind.</span><span class="sxs-lookup"><span data-stu-id="463f3-350">Explicit conversions involving type parameters that are known to be reference types.</span></span> <span data-ttu-id="463f3-351">Weitere Informationen zu expliziten Konvertierungen, die Typparameter einschließen, finden Sie unter [explizite Konvertierungen mit Typparametern](conversions.md#explicit-conversions-involving-type-parameters).</span><span class="sxs-lookup"><span data-stu-id="463f3-351">For more details on explicit conversions involving type parameters, see [Explicit conversions involving type parameters](conversions.md#explicit-conversions-involving-type-parameters).</span></span>

<span data-ttu-id="463f3-352">Die expliziten Verweis Konvertierungen sind Konvertierungen zwischen Verweis Typen, für die Laufzeitüberprüfungen erforderlich sind, um sicherzustellen, dass Sie korrekt sind.</span><span class="sxs-lookup"><span data-stu-id="463f3-352">The explicit reference conversions are those conversions between reference-types that require run-time checks to ensure they are correct.</span></span>

<span data-ttu-id="463f3-353">Damit eine explizite Verweis Konvertierung zur Laufzeit erfolgreich ist, muss der Wert des Quell Operanden `null`werden, oder der tatsächliche Typ des Objekts, auf das vom Quell Operanden verwiesen wird, muss ein Typ sein, der durch eine implizite Verweis Konvertierung ([implizite Verweis Konvertierungen](conversions.md#implicit-reference-conversions)[) oder](conversions.md#boxing-conversions)Boxing-Konvertierung in den Zieltyp konvertiert werden kann.</span><span class="sxs-lookup"><span data-stu-id="463f3-353">For an explicit reference conversion to succeed at run-time, the value of the source operand must be `null`, or the actual type of the object referenced by the source operand must be a type that can be converted to the destination type by an implicit reference conversion ([Implicit reference conversions](conversions.md#implicit-reference-conversions)) or boxing conversion ([Boxing conversions](conversions.md#boxing-conversions)).</span></span> <span data-ttu-id="463f3-354">Wenn eine explizite Verweis Konvertierung fehlschlägt, wird eine `System.InvalidCastException` ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="463f3-354">If an explicit reference conversion fails, a `System.InvalidCastException` is thrown.</span></span>

<span data-ttu-id="463f3-355">Verweis Konvertierungen, implizit oder explizit, ändern niemals die referenzielle Identität des Objekts, das konvertiert wird.</span><span class="sxs-lookup"><span data-stu-id="463f3-355">Reference conversions, implicit or explicit, never change the referential identity of the object being converted.</span></span> <span data-ttu-id="463f3-356">Anders ausgedrückt: während eine Verweis Konvertierung den Typ des Verweises ändern kann, ändert Sie niemals den Typ oder Wert des Objekts, auf das verwiesen wird.</span><span class="sxs-lookup"><span data-stu-id="463f3-356">In other words, while a reference conversion may change the type of the reference, it never changes the type or value of the object being referred to.</span></span>

### <a name="unboxing-conversions"></a><span data-ttu-id="463f3-357">Unboxing-Konvertierungen</span><span class="sxs-lookup"><span data-stu-id="463f3-357">Unboxing conversions</span></span>

<span data-ttu-id="463f3-358">Eine Unboxing-Konvertierung ermöglicht das explizite Konvertieren eines Verweis Typs in einen *value_type*.</span><span class="sxs-lookup"><span data-stu-id="463f3-358">An unboxing conversion permits a reference type to be explicitly converted to a *value_type*.</span></span> <span data-ttu-id="463f3-359">Eine Unboxing-Konvertierung ist von den Typen `object`, `dynamic` und `System.ValueType` zu beliebigen *non_nullable_value_type*und von allen *INTERFACE_TYPE* zu beliebigen *non_nullable_value_type* , die den *INTERFACE_TYPE*implementieren, vorhanden.</span><span class="sxs-lookup"><span data-stu-id="463f3-359">An unboxing conversion exists from the types `object`, `dynamic` and `System.ValueType` to any *non_nullable_value_type*, and from any *interface_type* to any *non_nullable_value_type* that implements the *interface_type*.</span></span> <span data-ttu-id="463f3-360">Darüber hinaus können Sie `System.Enum` in beliebige *enum_type*entpackt werden.</span><span class="sxs-lookup"><span data-stu-id="463f3-360">Furthermore type `System.Enum` can be unboxed to any *enum_type*.</span></span>

<span data-ttu-id="463f3-361">Eine Unboxing-Konvertierung ist von einem Referenztyp zu einem *nullable_type* vorhanden, wenn eine Unboxing-Konvertierung vom Verweistyp in den zugrunde liegenden *non_nullable_value_type* der *nullable_type*vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="463f3-361">An unboxing conversion exists from a reference type to a *nullable_type* if an unboxing conversion exists from the reference type to the underlying *non_nullable_value_type* of the *nullable_type*.</span></span>

<span data-ttu-id="463f3-362">Ein Werttyp `S` hat eine Unboxing-Konvertierung von einem Schnittstellentyp `I`, wenn er eine Unboxing-Konvertierung von einem Schnittstellentyp hat `I0` und `I0` über eine Identitäts Konvertierung in `I`verfügt.</span><span class="sxs-lookup"><span data-stu-id="463f3-362">A value type `S` has an unboxing conversion from an interface type `I` if it has an unboxing conversion from an interface type `I0` and `I0` has an identity conversion to `I`.</span></span>

<span data-ttu-id="463f3-363">Ein Werttyp `S` hat eine Unboxing-Konvertierung von einem Schnittstellentyp `I`, wenn er eine Unboxing-Konvertierung von einer Schnittstelle oder einem Delegattyp aufweist `I0` und entweder `I0` von Varianz konvertierbar in `I` oder `I` ist Varianz konvertierbar in `I0` ([Varianz Konvertierung](interfaces.md#variance-conversion)).</span><span class="sxs-lookup"><span data-stu-id="463f3-363">A value type `S` has an unboxing conversion from an interface type `I` if it has an unboxing conversion from an interface or delegate type `I0` and either `I0` is variance-convertible to `I` or `I` is variance-convertible to `I0` ([Variance conversion](interfaces.md#variance-conversion)).</span></span>

<span data-ttu-id="463f3-364">Ein Unboxing-Vorgang besteht darin, zuerst zu überprüfen, ob die Objektinstanz ein geachtelter Wert der angegebenen *value_type*ist, und dann den Wert aus der-Instanz zu kopieren.</span><span class="sxs-lookup"><span data-stu-id="463f3-364">An unboxing operation consists of first checking that the object instance is a boxed value of the given *value_type*, and then copying the value out of the instance.</span></span> <span data-ttu-id="463f3-365">Beim Unboxing eines NULL-Verweises auf einen *nullable_type* wird der NULL-Wert des *nullable_type*erzeugt.</span><span class="sxs-lookup"><span data-stu-id="463f3-365">Unboxing a null reference to a *nullable_type* produces the null value of the *nullable_type*.</span></span> <span data-ttu-id="463f3-366">Eine Struktur kann vom Typ `System.ValueType`entpackt werden, da dies eine Basisklasse für alle Strukturen ([Vererbung](structs.md#inheritance)) ist.</span><span class="sxs-lookup"><span data-stu-id="463f3-366">A struct can be unboxed from the type `System.ValueType`, since that is a base class for all structs ([Inheritance](structs.md#inheritance)).</span></span>

<span data-ttu-id="463f3-367">Unboxing-Konvertierungen werden weiter unten in [Unboxing-Konvertierungen](types.md#unboxing-conversions)beschrieben.</span><span class="sxs-lookup"><span data-stu-id="463f3-367">Unboxing conversions are described further in [Unboxing conversions](types.md#unboxing-conversions).</span></span>

### <a name="explicit-dynamic-conversions"></a><span data-ttu-id="463f3-368">Explizite dynamische Konvertierungen</span><span class="sxs-lookup"><span data-stu-id="463f3-368">Explicit dynamic conversions</span></span>

<span data-ttu-id="463f3-369">Eine explizite dynamische Konvertierung ist von einem Ausdruck vom Typ `dynamic` in einen beliebigen Typ `T`vorhanden.</span><span class="sxs-lookup"><span data-stu-id="463f3-369">An explicit dynamic conversion exists from an expression of type `dynamic` to any type `T`.</span></span> <span data-ttu-id="463f3-370">Die Konvertierung ist dynamisch gebunden ([dynamische Bindung](expressions.md#dynamic-binding)), was bedeutet, dass zur Laufzeit eine explizite Konvertierung vom Lauf Zeittyp des Ausdrucks zum `T`durchgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="463f3-370">The conversion is dynamically bound ([Dynamic binding](expressions.md#dynamic-binding)), which means that an explicit conversion will be sought at run-time from the run-time type of the expression to `T`.</span></span> <span data-ttu-id="463f3-371">Wenn keine Konvertierung gefunden wird, wird eine Lauf Zeit Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="463f3-371">If no conversion is found, a run-time exception is thrown.</span></span>

<span data-ttu-id="463f3-372">Wenn die dynamische Bindung der Konvertierung nicht erwünscht ist, kann der Ausdruck zuerst in `object`und dann in den gewünschten Typ konvertiert werden.</span><span class="sxs-lookup"><span data-stu-id="463f3-372">If dynamic binding of the conversion is not desired, the expression can be first converted to `object`, and then to the desired type.</span></span>

<span data-ttu-id="463f3-373">Nehmen Sie an, dass die folgende Klasse definiert ist:</span><span class="sxs-lookup"><span data-stu-id="463f3-373">Assume the following class is defined:</span></span>
```csharp
class C
{
    int i;

    public C(int i) { this.i = i; }

    public static explicit operator C(string s) 
    {
        return new C(int.Parse(s));
    }
}
```

<span data-ttu-id="463f3-374">Das folgende Beispiel veranschaulicht explizite dynamische Konvertierungen:</span><span class="sxs-lookup"><span data-stu-id="463f3-374">The following example illustrates explicit dynamic conversions:</span></span>
```csharp
object o  = "1";
dynamic d = "2";

var c1 = (C)o; // Compiles, but explicit reference conversion fails
var c2 = (C)d; // Compiles and user defined conversion succeeds
```

<span data-ttu-id="463f3-375">Die beste Konvertierung von `o` in `C` wird zur Kompilierzeit als explizite Verweis Konvertierung gefunden.</span><span class="sxs-lookup"><span data-stu-id="463f3-375">The best conversion of `o` to `C` is found at compile-time to be an explicit reference conversion.</span></span> <span data-ttu-id="463f3-376">Dies schlägt zur Laufzeit fehl, da `"1"` nicht tatsächlich eine `C`ist.</span><span class="sxs-lookup"><span data-stu-id="463f3-376">This fails at run-time, because `"1"` is not in fact a `C`.</span></span> <span data-ttu-id="463f3-377">Die Konvertierung von `d` in `C` wird jedoch als explizite dynamische Konvertierung zur Laufzeit angehalten, bei der eine benutzerdefinierte Konvertierung vom Lauf Zeittyp `d` -- `string` `C` gefunden wird und erfolgreich ist.</span><span class="sxs-lookup"><span data-stu-id="463f3-377">The conversion of `d` to `C` however, as an explicit dynamic conversion, is suspended to run-time, where a user defined conversion from the run-time type of `d` -- `string` -- to `C` is found, and succeeds.</span></span>

### <a name="explicit-conversions-involving-type-parameters"></a><span data-ttu-id="463f3-378">Explizite Konvertierungen mit Typparametern</span><span class="sxs-lookup"><span data-stu-id="463f3-378">Explicit conversions involving type parameters</span></span>

<span data-ttu-id="463f3-379">Die folgenden expliziten Konvertierungen sind für einen angegebenen Typparameter `T`vorhanden:</span><span class="sxs-lookup"><span data-stu-id="463f3-379">The following explicit conversions exist for a given type parameter `T`:</span></span>

*  <span data-ttu-id="463f3-380">Von der effektiven Basisklasse `C` `T` bis `T` und von jeder Basisklasse `C` bis `T`.</span><span class="sxs-lookup"><span data-stu-id="463f3-380">From the effective base class `C` of `T` to `T` and from any base class of `C` to `T`.</span></span> <span data-ttu-id="463f3-381">Wenn `T` ein Werttyp ist, wird die Konvertierung zur Laufzeit als Unboxing-Konvertierung ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="463f3-381">At run-time, if `T` is a value type, the conversion is executed as an unboxing conversion.</span></span> <span data-ttu-id="463f3-382">Andernfalls wird die Konvertierung als explizite Verweis Konvertierung oder Identitäts Konvertierung ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="463f3-382">Otherwise, the conversion is executed as an explicit reference conversion or identity conversion.</span></span>
*  <span data-ttu-id="463f3-383">Von einem beliebigen Schnittstellentyp zu `T`.</span><span class="sxs-lookup"><span data-stu-id="463f3-383">From any interface type to `T`.</span></span> <span data-ttu-id="463f3-384">Wenn `T` ein Werttyp ist, wird die Konvertierung zur Laufzeit als Unboxing-Konvertierung ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="463f3-384">At run-time, if `T` is a value type, the conversion is executed as an unboxing conversion.</span></span> <span data-ttu-id="463f3-385">Andernfalls wird die Konvertierung als explizite Verweis Konvertierung oder Identitäts Konvertierung ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="463f3-385">Otherwise, the conversion is executed as an explicit reference conversion or identity conversion.</span></span>
*  <span data-ttu-id="463f3-386">Von `T` bis zu allen *INTERFACE_TYPE* `I` gibt es keine implizite Konvertierung von `T` in `I`.</span><span class="sxs-lookup"><span data-stu-id="463f3-386">From `T` to any *interface_type* `I` provided there is not already an implicit conversion from `T` to `I`.</span></span> <span data-ttu-id="463f3-387">Wenn `T` ein Werttyp ist, wird die Konvertierung zur Laufzeit als Boxing-Konvertierung gefolgt von einer expliziten Verweis Konvertierung ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="463f3-387">At run-time, if `T` is a value type, the conversion is executed as a boxing conversion followed by an explicit reference conversion.</span></span> <span data-ttu-id="463f3-388">Andernfalls wird die Konvertierung als explizite Verweis Konvertierung oder Identitäts Konvertierung ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="463f3-388">Otherwise, the conversion is executed as an explicit reference conversion or identity conversion.</span></span>
*  <span data-ttu-id="463f3-389">Von einem Typparameter `U` zum `T`, sofern `T` von `U` abhängig sind ([Typparameter Einschränkungen](classes.md#type-parameter-constraints)).</span><span class="sxs-lookup"><span data-stu-id="463f3-389">From a type parameter `U` to `T`, provided `T` depends on `U` ([Type parameter constraints](classes.md#type-parameter-constraints)).</span></span> <span data-ttu-id="463f3-390">Wenn `U` ein Werttyp ist, sind `T` und `U` bei der Laufzeit notwendigerweise denselben Typ, und es wird keine Konvertierung durchgeführt.</span><span class="sxs-lookup"><span data-stu-id="463f3-390">At run-time, if `U` is a value type, then `T` and `U` are necessarily the same type and no conversion is performed.</span></span> <span data-ttu-id="463f3-391">Andernfalls wird die Konvertierung als Unboxing-Konvertierung ausgeführt, wenn `T` ein Werttyp ist.</span><span class="sxs-lookup"><span data-stu-id="463f3-391">Otherwise, if `T` is a value type, the conversion is executed as an unboxing conversion.</span></span> <span data-ttu-id="463f3-392">Andernfalls wird die Konvertierung als explizite Verweis Konvertierung oder Identitäts Konvertierung ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="463f3-392">Otherwise, the conversion is executed as an explicit reference conversion or identity conversion.</span></span>

<span data-ttu-id="463f3-393">Wenn `T` bekannt ist, dass es sich um einen Verweistyp handelt, werden die obigen Konvertierungen als explizite Verweis Konvertierungen klassifiziert ([explizite Verweis Konvertierungen](conversions.md#explicit-reference-conversions)).</span><span class="sxs-lookup"><span data-stu-id="463f3-393">If `T` is known to be a reference type, the conversions above are all classified as explicit reference conversions ([Explicit reference conversions](conversions.md#explicit-reference-conversions)).</span></span> <span data-ttu-id="463f3-394">Wenn `T` nicht bekannt ist, dass es sich um einen Verweistyp handelt, werden die obigen Konvertierungen als Unboxing-Konvertierungen ([Unboxing-Konvertierungen](conversions.md#unboxing-conversions)) klassifiziert.</span><span class="sxs-lookup"><span data-stu-id="463f3-394">If `T` is not known to be a reference type, the conversions above are classified as unboxing conversions ([Unboxing conversions](conversions.md#unboxing-conversions)).</span></span>

<span data-ttu-id="463f3-395">Die obigen Regeln erlauben keine direkte explizite Konvertierung von einem uneingeschränkten Typparameter in einen nicht-Schnittstellentyp, was möglicherweise überraschend ist.</span><span class="sxs-lookup"><span data-stu-id="463f3-395">The above rules do not permit a direct explicit conversion from an unconstrained type parameter to a non-interface type, which might be surprising.</span></span> <span data-ttu-id="463f3-396">Der Grund für diese Regel besteht darin, Verwirrung zu vermeiden und die Semantik solcher Konvertierungen zu löschen.</span><span class="sxs-lookup"><span data-stu-id="463f3-396">The reason for this rule is to prevent confusion and make the semantics of such conversions clear.</span></span> <span data-ttu-id="463f3-397">Betrachten Sie beispielsweise die folgende Deklaration:</span><span class="sxs-lookup"><span data-stu-id="463f3-397">For example, consider the following declaration:</span></span>
```csharp
class X<T>
{
    public static long F(T t) {
        return (long)t;                // Error 
    }
}
```

<span data-ttu-id="463f3-398">Wenn die direkte explizite Konvertierung von `t` in `int` zulässig wäre, kann man leicht davon ausgehen, dass `X<int>.F(7)` `7L`zurückgeben würde.</span><span class="sxs-lookup"><span data-stu-id="463f3-398">If the direct explicit conversion of `t` to `int` were permitted, one might easily expect that `X<int>.F(7)` would return `7L`.</span></span> <span data-ttu-id="463f3-399">Dies würde jedoch nicht der Fall sein, da die standardmäßigen numerischen Konvertierungen nur berücksichtigt werden, wenn die Typen bekannt sind, dass Sie zur Bindungs Zeit numerisch sind.</span><span class="sxs-lookup"><span data-stu-id="463f3-399">However, it would not, because the standard numeric conversions are only considered when the types are known to be numeric at binding-time.</span></span> <span data-ttu-id="463f3-400">Damit die Semantik eindeutig ist, muss das obige Beispiel stattdessen geschrieben werden:</span><span class="sxs-lookup"><span data-stu-id="463f3-400">In order to make the semantics clear, the above example must instead be written:</span></span>
```csharp
class X<T>
{
    public static long F(T t) {
        return (long)(object)t;        // Ok, but will only work when T is long
    }
}
```

<span data-ttu-id="463f3-401">Dieser Code wird jetzt kompiliert, aber das Ausführen von `X<int>.F(7)` würde zur Laufzeit eine Ausnahme auslösen, da ein geachtelter `int` nicht direkt in eine `long`konvertiert werden kann.</span><span class="sxs-lookup"><span data-stu-id="463f3-401">This code will now compile but executing `X<int>.F(7)` would then throw an exception at run-time, since a boxed `int` cannot be converted directly to a `long`.</span></span>

### <a name="user-defined-explicit-conversions"></a><span data-ttu-id="463f3-402">Benutzerdefinierte explizite Konvertierungen</span><span class="sxs-lookup"><span data-stu-id="463f3-402">User-defined explicit conversions</span></span>

<span data-ttu-id="463f3-403">Eine benutzerdefinierte explizite Konvertierung besteht aus einer optionalen expliziten Standard Konvertierung, gefolgt von der Ausführung eines benutzerdefinierten impliziten oder expliziten Konvertierungs Operators, gefolgt von einer anderen optionalen expliziten Standard Konvertierung.</span><span class="sxs-lookup"><span data-stu-id="463f3-403">A user-defined explicit conversion consists of an optional standard explicit conversion, followed by execution of a user-defined implicit or explicit conversion operator, followed by another optional standard explicit conversion.</span></span> <span data-ttu-id="463f3-404">Die genauen Regeln für das Auswerten benutzerdefinierter expliziter Konvertierungen werden bei der [Verarbeitung benutzerdefinierter expliziter Konvertierungen](conversions.md#processing-of-user-defined-explicit-conversions)beschrieben.</span><span class="sxs-lookup"><span data-stu-id="463f3-404">The exact rules for evaluating user-defined explicit conversions are described in [Processing of user-defined explicit conversions](conversions.md#processing-of-user-defined-explicit-conversions).</span></span>

## <a name="standard-conversions"></a><span data-ttu-id="463f3-405">Standardkonvertierungen</span><span class="sxs-lookup"><span data-stu-id="463f3-405">Standard conversions</span></span>

<span data-ttu-id="463f3-406">Bei den Standard Konvertierungen handelt es sich um vordefinierte Konvertierungen, die als Teil einer benutzerdefinierten Konvertierung auftreten können.</span><span class="sxs-lookup"><span data-stu-id="463f3-406">The standard conversions are those pre-defined conversions that can occur as part of a user-defined conversion.</span></span>

### <a name="standard-implicit-conversions"></a><span data-ttu-id="463f3-407">Implizite Standard Konvertierungen</span><span class="sxs-lookup"><span data-stu-id="463f3-407">Standard implicit conversions</span></span>

<span data-ttu-id="463f3-408">Die folgenden impliziten Konvertierungen werden als implizite Standard Konvertierungen klassifiziert:</span><span class="sxs-lookup"><span data-stu-id="463f3-408">The following implicit conversions are classified as standard implicit conversions:</span></span>

*  <span data-ttu-id="463f3-409">Identitäts Konvertierungen ([Identitäts Konvertierung](conversions.md#identity-conversion))</span><span class="sxs-lookup"><span data-stu-id="463f3-409">Identity conversions ([Identity conversion](conversions.md#identity-conversion))</span></span>
*  <span data-ttu-id="463f3-410">Implizite numerische Konvertierungen ([implizite numerische Konvertierungen](conversions.md#implicit-numeric-conversions))</span><span class="sxs-lookup"><span data-stu-id="463f3-410">Implicit numeric conversions ([Implicit numeric conversions](conversions.md#implicit-numeric-conversions))</span></span>
*  <span data-ttu-id="463f3-411">Implizite Konvertierungen, die NULL-Werte zulassen ([implizite Konvertierungen auf NULL](conversions.md#implicit-nullable-conversions)</span><span class="sxs-lookup"><span data-stu-id="463f3-411">Implicit nullable conversions ([Implicit nullable conversions](conversions.md#implicit-nullable-conversions))</span></span>
*  <span data-ttu-id="463f3-412">Implizite Verweis Konvertierungen ([implizite Verweis Konvertierungen](conversions.md#implicit-reference-conversions))</span><span class="sxs-lookup"><span data-stu-id="463f3-412">Implicit reference conversions ([Implicit reference conversions](conversions.md#implicit-reference-conversions))</span></span>
*  <span data-ttu-id="463f3-413">Boxing-Konvertierungen ([Boxing-Konvertierungen](conversions.md#boxing-conversions))</span><span class="sxs-lookup"><span data-stu-id="463f3-413">Boxing conversions ([Boxing conversions](conversions.md#boxing-conversions))</span></span>
*  <span data-ttu-id="463f3-414">Implizite Konstante Ausdrucks Konvertierungen ([implizite dynamische Konvertierungen](conversions.md#implicit-dynamic-conversions))</span><span class="sxs-lookup"><span data-stu-id="463f3-414">Implicit constant expression conversions ([Implicit dynamic conversions](conversions.md#implicit-dynamic-conversions))</span></span>
*  <span data-ttu-id="463f3-415">Implizite Konvertierungen mit Typparametern ([implizite Konvertierungen mit Typparametern](conversions.md#implicit-conversions-involving-type-parameters))</span><span class="sxs-lookup"><span data-stu-id="463f3-415">Implicit conversions involving type parameters ([Implicit conversions involving type parameters](conversions.md#implicit-conversions-involving-type-parameters))</span></span>

<span data-ttu-id="463f3-416">Die standardmäßigen impliziten Konvertierungen schließen speziell benutzerdefinierte implizite Konvertierungen aus.</span><span class="sxs-lookup"><span data-stu-id="463f3-416">The standard implicit conversions specifically exclude user-defined implicit conversions.</span></span>

### <a name="standard-explicit-conversions"></a><span data-ttu-id="463f3-417">Explizite Standard Konvertierungen</span><span class="sxs-lookup"><span data-stu-id="463f3-417">Standard explicit conversions</span></span>

<span data-ttu-id="463f3-418">Die expliziten Standard Konvertierungen sind alle standardmäßigen impliziten Konvertierungen und die Teilmenge der expliziten Konvertierungen, für die eine gegenteilige standardmäßige implizite Konvertierung vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="463f3-418">The standard explicit conversions are all standard implicit conversions plus the subset of the explicit conversions for which an opposite standard implicit conversion exists.</span></span> <span data-ttu-id="463f3-419">Anders ausgedrückt: Wenn eine implizite Standard Konvertierung von einem Typ `A` in einen Typ `B`vorhanden ist, ist eine explizite Standard Konvertierung vom Typ `A` in den Typ `B` und vom Typ `B` zum Typ `A`vorhanden.</span><span class="sxs-lookup"><span data-stu-id="463f3-419">In other words, if a standard implicit conversion exists from a type `A` to a type `B`, then a standard explicit conversion exists from type `A` to type `B` and from type `B` to type `A`.</span></span>

## <a name="user-defined-conversions"></a><span data-ttu-id="463f3-420">Benutzerdefinierte Konvertierungen</span><span class="sxs-lookup"><span data-stu-id="463f3-420">User-defined conversions</span></span>

<span data-ttu-id="463f3-421">C#ermöglicht das Erweitern der vordefinierten und expliziten Konvertierungen durch ***benutzerdefinierte Konvertierungen***.</span><span class="sxs-lookup"><span data-stu-id="463f3-421">C# allows the pre-defined implicit and explicit conversions to be augmented by ***user-defined conversions***.</span></span> <span data-ttu-id="463f3-422">Benutzerdefinierte Konvertierungen werden durch das Deklarieren von Konvertierungs Operatoren ([Konvertierungs Operatoren](classes.md#conversion-operators)) in Klassen-und Strukturtypen eingeführt.</span><span class="sxs-lookup"><span data-stu-id="463f3-422">User-defined conversions are introduced by declaring conversion operators ([Conversion operators](classes.md#conversion-operators)) in class and struct types.</span></span>

### <a name="permitted-user-defined-conversions"></a><span data-ttu-id="463f3-423">Zulässige benutzerdefinierte Konvertierungen</span><span class="sxs-lookup"><span data-stu-id="463f3-423">Permitted user-defined conversions</span></span>

<span data-ttu-id="463f3-424">C#gestattet, dass nur bestimmte benutzerdefinierte Konvertierungen deklariert werden.</span><span class="sxs-lookup"><span data-stu-id="463f3-424">C# permits only certain user-defined conversions to be declared.</span></span> <span data-ttu-id="463f3-425">Insbesondere ist es nicht möglich, eine bereits vorhandene implizite oder explizite Konvertierung neu zu definieren.</span><span class="sxs-lookup"><span data-stu-id="463f3-425">In particular, it is not possible to redefine an already existing implicit or explicit conversion.</span></span>

<span data-ttu-id="463f3-426">Verwenden Sie für einen angegebenen Quelltyp `S` und einen Zieltyp `T`, wenn `S` oder `T` Typen sind, die NULL-Werte zulassen, `S0` und `T0` auf ihre zugrunde liegenden Typen. andernfalls sind `S0` und `T0` gleich `S` bzw. `T`.</span><span class="sxs-lookup"><span data-stu-id="463f3-426">For a given source type `S` and target type `T`, if `S` or `T` are nullable types, let `S0` and `T0` refer to their underlying types, otherwise `S0` and `T0` are equal to `S` and `T` respectively.</span></span> <span data-ttu-id="463f3-427">Eine Klasse oder Struktur darf eine Konvertierung von einem Quelltyp `S` in einen Zieltyp deklarieren `T` nur dann, wenn Folgendes zutrifft:</span><span class="sxs-lookup"><span data-stu-id="463f3-427">A class or struct is permitted to declare a conversion from a source type `S` to a target type `T` only if all of the following are true:</span></span>

*  <span data-ttu-id="463f3-428">`S0` und `T0` sind unterschiedliche Typen.</span><span class="sxs-lookup"><span data-stu-id="463f3-428">`S0` and `T0` are different types.</span></span>
*  <span data-ttu-id="463f3-429">Entweder `S0` oder `T0` ist der Klassen-oder Strukturtyp, in dem die Operator Deklaration stattfindet.</span><span class="sxs-lookup"><span data-stu-id="463f3-429">Either `S0` or `T0` is the class or struct type in which the operator declaration takes place.</span></span>
*  <span data-ttu-id="463f3-430">Weder `S0` noch `T0` ist ein *INTERFACE_TYPE*.</span><span class="sxs-lookup"><span data-stu-id="463f3-430">Neither `S0` nor `T0` is an *interface_type*.</span></span>
*  <span data-ttu-id="463f3-431">Das Ausschließen von benutzerdefinierten Konvertierungen ist nicht von `S` zu `T` oder von `T` zum `S`vorhanden.</span><span class="sxs-lookup"><span data-stu-id="463f3-431">Excluding user-defined conversions, a conversion does not exist from `S` to `T` or from `T` to `S`.</span></span>

<span data-ttu-id="463f3-432">Die Einschränkungen, die für benutzerdefinierte Konvertierungen gelten, werden in den [Konvertierungs Operatoren](classes.md#conversion-operators)weiter erläutert.</span><span class="sxs-lookup"><span data-stu-id="463f3-432">The restrictions that apply to user-defined conversions are discussed further in [Conversion operators](classes.md#conversion-operators).</span></span>

### <a name="lifted-conversion-operators"></a><span data-ttu-id="463f3-433">Operator für gesteigerte Konvertierung</span><span class="sxs-lookup"><span data-stu-id="463f3-433">Lifted conversion operators</span></span>

<span data-ttu-id="463f3-434">Bei einem benutzerdefinierten Konvertierungs Operator, der von einem Werttyp, der keine NULL-Werte zulässt, `S` in einen Werttyp, der keine NULL-Werte zulässt `T`, ist ein ***Operator mit erhöhten Konvertierungen*** vorhanden, der von `S?` in `T?`konvertiert</span><span class="sxs-lookup"><span data-stu-id="463f3-434">Given a user-defined conversion operator that converts from a non-nullable value type `S` to a non-nullable value type `T`, a ***lifted conversion operator*** exists that converts from `S?` to `T?`.</span></span> <span data-ttu-id="463f3-435">Dieser Operator mit erhöhten Konvertierungen führt einen zum Entpacken von `S?` auf `S` gefolgt von der benutzerdefinierten Konvertierung von `S` in `T` gefolgt von einem Umbrüchen von `T` zu `T?`, mit dem Unterschied, dass ein NULL-Wert `S?` direkt in eine `T?`mit NULL-Wert konvertiert.</span><span class="sxs-lookup"><span data-stu-id="463f3-435">This lifted conversion operator performs an unwrapping from `S?` to `S` followed by the user-defined conversion from `S` to `T` followed by a wrapping from `T` to `T?`, except that a null valued `S?` converts directly to a null valued `T?`.</span></span>

<span data-ttu-id="463f3-436">Ein Operator mit erhöhten Konvertierungen hat dieselbe implizite oder explizite Klassifizierung wie der zugrunde liegende benutzerdefinierte Konvertierungs Operator.</span><span class="sxs-lookup"><span data-stu-id="463f3-436">A lifted conversion operator has the same implicit or explicit classification as its underlying user-defined conversion operator.</span></span> <span data-ttu-id="463f3-437">Der Begriff "benutzerdefinierte Konvertierung" gilt für die Verwendung von benutzerdefinierten und erhöhten Konvertierungs Operatoren.</span><span class="sxs-lookup"><span data-stu-id="463f3-437">The term "user-defined conversion" applies to the use of both user-defined and lifted conversion operators.</span></span>

### <a name="evaluation-of-user-defined-conversions"></a><span data-ttu-id="463f3-438">Auswertung von benutzerdefinierten Konvertierungen</span><span class="sxs-lookup"><span data-stu-id="463f3-438">Evaluation of user-defined conversions</span></span>

<span data-ttu-id="463f3-439">Eine benutzerdefinierte Konvertierung konvertiert einen Wert vom Typ, der als ***Quelltyp***bezeichnet wird, in einen anderen Typ, der als ***Zieltyp***bezeichnet wird.</span><span class="sxs-lookup"><span data-stu-id="463f3-439">A user-defined conversion converts a value from its type, called the ***source type***, to another type, called the ***target type***.</span></span> <span data-ttu-id="463f3-440">Bei der Auswertung einer benutzerdefinierten Konvertierung wird das Auffinden des ***spezifischsten*** benutzerdefinierten Konvertierungs Operators für bestimmte Quell-und Zieltypen ermittelt.</span><span class="sxs-lookup"><span data-stu-id="463f3-440">Evaluation of a user-defined conversion centers on finding the ***most specific*** user-defined conversion operator for the particular source and target types.</span></span> <span data-ttu-id="463f3-441">Diese Bestimmung ist in mehrere Schritte unterteilt:</span><span class="sxs-lookup"><span data-stu-id="463f3-441">This determination is broken into several steps:</span></span>

*  <span data-ttu-id="463f3-442">Suchen des Satzes von Klassen und Strukturen, von denen benutzerdefinierte Konvertierungs Operatoren berücksichtigt werden.</span><span class="sxs-lookup"><span data-stu-id="463f3-442">Finding the set of classes and structs from which user-defined conversion operators will be considered.</span></span> <span data-ttu-id="463f3-443">Diese Gruppe besteht aus dem Quelltyp und den zugehörigen Basisklassen sowie dem Zieltyp und den zugehörigen Basisklassen (mit den impliziten Annahmen, dass nur Klassen und Strukturen benutzerdefinierte Operatoren deklarieren können, und dass nicht Klassentypen keine Basisklassen aufweisen).</span><span class="sxs-lookup"><span data-stu-id="463f3-443">This set consists of the source type and its base classes and the target type and its base classes (with the implicit assumptions that only classes and structs can declare user-defined operators, and that non-class types have no base classes).</span></span> <span data-ttu-id="463f3-444">Wenn entweder der Quell-oder Zieltyp ein nullable_type ist, wird stattdessen der zugrunde liegende Typ verwendet, wenn der Quell-oder Zieltyp einist.</span><span class="sxs-lookup"><span data-stu-id="463f3-444">For the purposes of this step, if either the source or target type is a *nullable_type*, their underlying type is used instead.</span></span>
*  <span data-ttu-id="463f3-445">Aus diesem Satz von Typen, um zu bestimmen, welche benutzerdefinierten und erhöhten Konvertierungs Operatoren anwendbar sind.</span><span class="sxs-lookup"><span data-stu-id="463f3-445">From that set of types, determining which user-defined and lifted conversion operators are applicable.</span></span> <span data-ttu-id="463f3-446">Damit ein Konvertierungs Operator anwendbar ist, muss es möglich sein, eine Standard Konvertierung ([Standard Konvertierungen](conversions.md#standard-conversions)) vom Quelltyp in den Operanden des Operators auszuführen. Außerdem muss es möglich sein, eine Standard Konvertierung vom Ergebnistyp des Operators in den Zieltyp auszuführen.</span><span class="sxs-lookup"><span data-stu-id="463f3-446">For a conversion operator to be applicable, it must be possible to perform a standard conversion ([Standard conversions](conversions.md#standard-conversions)) from the source type to the operand type of the operator, and it must be possible to perform a standard conversion from the result type of the operator to the target type.</span></span>
*  <span data-ttu-id="463f3-447">Aus dem Satz der anwendbaren benutzerdefinierten Operatoren, wobei festgelegt wird, welcher Operator eindeutig der spezifischsten ist.</span><span class="sxs-lookup"><span data-stu-id="463f3-447">From the set of applicable user-defined operators, determining which operator is unambiguously the most specific.</span></span> <span data-ttu-id="463f3-448">In der Regel ist der spezifischere Operator der Operator, dessen Operanden dem Quelltyp "am nächsten" und dessen Ergebnistyp "am nächsten" dem Zieltyp entspricht.</span><span class="sxs-lookup"><span data-stu-id="463f3-448">In general terms, the most specific operator is the operator whose operand type is "closest" to the source type and whose result type is "closest" to the target type.</span></span> <span data-ttu-id="463f3-449">Benutzerdefinierte Konvertierungs Operatoren werden für gesteigerte Konvertierungs Operatoren bevorzugt.</span><span class="sxs-lookup"><span data-stu-id="463f3-449">User-defined conversion operators are preferred over lifted conversion operators.</span></span> <span data-ttu-id="463f3-450">Die genauen Regeln zum Einrichten des spezifischsten benutzerdefinierten Konvertierungs Operators werden in den folgenden Abschnitten definiert.</span><span class="sxs-lookup"><span data-stu-id="463f3-450">The exact rules for establishing the most specific user-defined conversion operator are defined in the following sections.</span></span>

<span data-ttu-id="463f3-451">Nachdem ein spezifiziererer benutzerdefinierter Konvertierungs Operator identifiziert wurde, umfasst die tatsächliche Ausführung der benutzerdefinierten Konvertierung bis zu drei Schritte:</span><span class="sxs-lookup"><span data-stu-id="463f3-451">Once a most specific user-defined conversion operator has been identified, the actual execution of the user-defined conversion involves up to three steps:</span></span>

*  <span data-ttu-id="463f3-452">Wenn dies erforderlich ist, wird eine Standard Konvertierung vom Quelltyp in den Operanden des benutzerdefinierten oder des aufzurufenden Konvertierungs Operators durchgeführt.</span><span class="sxs-lookup"><span data-stu-id="463f3-452">First, if required, performing a standard conversion from the source type to the operand type of the user-defined or lifted conversion operator.</span></span>
*  <span data-ttu-id="463f3-453">Im nächsten Schritt wird der benutzerdefinierte oder der Operator für die Aufhebung der Konvertierung aufgerufen, um die Konvertierung auszuführen.</span><span class="sxs-lookup"><span data-stu-id="463f3-453">Next, invoking the user-defined or lifted conversion operator to perform the conversion.</span></span>
*  <span data-ttu-id="463f3-454">Wenn dies erforderlich ist, wird eine Standard Konvertierung vom Ergebnistyp des benutzerdefinierten oder des Operators für die gesteigerte Konvertierung in den Zieltyp durchgeführt.</span><span class="sxs-lookup"><span data-stu-id="463f3-454">Finally, if required, performing a standard conversion from the result type of the user-defined or lifted conversion operator to the target type.</span></span>

<span data-ttu-id="463f3-455">Die Auswertung einer benutzerdefinierten Konvertierung umfasst nie mehr als einen benutzerdefinierten oder einen Operator mit erhöhten Konvertierungen.</span><span class="sxs-lookup"><span data-stu-id="463f3-455">Evaluation of a user-defined conversion never involves more than one user-defined or lifted conversion operator.</span></span> <span data-ttu-id="463f3-456">Anders ausgedrückt: bei einer Konvertierung vom Typ `S` in den Typ `T` wird nie zuerst eine benutzerdefinierte Konvertierung von `S` in `X` ausgeführt und dann eine benutzerdefinierte Konvertierung von `X` in `T`ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="463f3-456">In other words, a conversion from type `S` to type `T` will never first execute a user-defined conversion from `S` to `X` and then execute a user-defined conversion from `X` to `T`.</span></span>

<span data-ttu-id="463f3-457">Die genauen Definitionen der Auswertung benutzerdefinierter impliziter oder expliziter Konvertierungen werden in den folgenden Abschnitten angegeben.</span><span class="sxs-lookup"><span data-stu-id="463f3-457">Exact definitions of evaluation of user-defined implicit or explicit conversions are given in the following sections.</span></span> <span data-ttu-id="463f3-458">In den Definitionen werden die folgenden Begriffe verwendet:</span><span class="sxs-lookup"><span data-stu-id="463f3-458">The definitions make use of the following terms:</span></span>

*  <span data-ttu-id="463f3-459">Wenn eine standardmäßige implizite Konvertierung ([standardmäßige implizite Konvertierungen](conversions.md#standard-implicit-conversions)) von einem Typ vorhanden ist, der `A` in einen Typ `B`ist, und wenn weder `A` noch `B` *INTERFACE_TYPE*s sind, wird `A` als ***mit `B`umschlossen*** bezeichnet, und `B` ***wird als "`A`"*** bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="463f3-459">If a standard implicit conversion ([Standard implicit conversions](conversions.md#standard-implicit-conversions)) exists from a type `A` to a type `B`, and if neither `A` nor `B` are *interface_type*s, then `A` is said to be ***encompassed by*** `B`, and `B` is said to ***encompass*** `A`.</span></span>
*  <span data-ttu-id="463f3-460">Der ***umfassendste Typ*** in einer Reihe von Typen ist der einzige Typ, der alle anderen Typen im Satz umfasst.</span><span class="sxs-lookup"><span data-stu-id="463f3-460">The ***most encompassing type*** in a set of types is the one type that encompasses all other types in the set.</span></span> <span data-ttu-id="463f3-461">Wenn kein einzelner Typ alle anderen Typen umfasst, hat der Satz keinen ganz umfassenden Typ.</span><span class="sxs-lookup"><span data-stu-id="463f3-461">If no single type encompasses all other types, then the set has no most encompassing type.</span></span> <span data-ttu-id="463f3-462">In intuitiver Hinsicht ist der umfassendste Typ der "größte" Typ im Satz – der einzige Typ, in den jeder der anderen Typen implizit konvertiert werden kann.</span><span class="sxs-lookup"><span data-stu-id="463f3-462">In more intuitive terms, the most encompassing type is the "largest" type in the set—the one type to which each of the other types can be implicitly converted.</span></span>
*  <span data-ttu-id="463f3-463">Der ***am häufigsten*** in einem Satz von Typen eingeschlossenen Typ ist ein Typ, der von allen anderen Typen im Satz eingeschlossen wird.</span><span class="sxs-lookup"><span data-stu-id="463f3-463">The ***most encompassed type*** in a set of types is the one type that is encompassed by all other types in the set.</span></span> <span data-ttu-id="463f3-464">Wenn kein einzelner Typ von allen anderen Typen eingeschlossen wird, hat der Satz nicht den meisten Typ.</span><span class="sxs-lookup"><span data-stu-id="463f3-464">If no single type is encompassed by all other types, then the set has no most encompassed type.</span></span> <span data-ttu-id="463f3-465">In intuitiver Hinsicht ist der Typ, der am häufigsten in der Menge enthalten ist, der "kleinste" Typ im Satz – ein Typ, der implizit in jeden der anderen Typen konvertiert werden kann.</span><span class="sxs-lookup"><span data-stu-id="463f3-465">In more intuitive terms, the most encompassed type is the "smallest" type in the set—the one type that can be implicitly converted to each of the other types.</span></span>

### <a name="processing-of-user-defined-implicit-conversions"></a><span data-ttu-id="463f3-466">Verarbeiten von benutzerdefinierten impliziten Konvertierungen</span><span class="sxs-lookup"><span data-stu-id="463f3-466">Processing of user-defined implicit conversions</span></span>

<span data-ttu-id="463f3-467">Eine benutzerdefinierte implizite Konvertierung vom Typ `S` in den Typ `T` wird wie folgt verarbeitet:</span><span class="sxs-lookup"><span data-stu-id="463f3-467">A user-defined implicit conversion from type `S` to type `T` is processed as follows:</span></span>

*  <span data-ttu-id="463f3-468">Bestimmen Sie die Typen `S0` und `T0`.</span><span class="sxs-lookup"><span data-stu-id="463f3-468">Determine the types `S0` and `T0`.</span></span> <span data-ttu-id="463f3-469">Wenn `S` oder `T` Typen NULL-Werte zulassen, sind `S0` und `T0` ihre zugrunde liegenden Typen. andernfalls sind `S0` und `T0` gleich `S` bzw. `T`.</span><span class="sxs-lookup"><span data-stu-id="463f3-469">If `S` or `T` are nullable types, `S0` and `T0` are their underlying types, otherwise `S0` and `T0` are equal to `S` and `T` respectively.</span></span>
*  <span data-ttu-id="463f3-470">Suchen Sie den Satz von Typen, `D`, von dem benutzerdefinierte Konvertierungs Operatoren berücksichtigt werden.</span><span class="sxs-lookup"><span data-stu-id="463f3-470">Find the set of types, `D`, from which user-defined conversion operators will be considered.</span></span> <span data-ttu-id="463f3-471">Dieser Satz besteht aus `S0` (wenn `S0` eine Klasse oder Struktur ist), den Basisklassen von `S0` (wenn `S0` eine Klasse ist) und `T0` (wenn `T0` eine Klasse oder Struktur ist).</span><span class="sxs-lookup"><span data-stu-id="463f3-471">This set consists of `S0` (if `S0` is a class or struct), the base classes of `S0` (if `S0` is a class), and `T0` (if `T0` is a class or struct).</span></span>
*  <span data-ttu-id="463f3-472">Suchen Sie den Satz der anwendbaren benutzerdefinierten und erhöhten Konvertierungs Operatoren, `U`.</span><span class="sxs-lookup"><span data-stu-id="463f3-472">Find the set of applicable user-defined and lifted conversion operators, `U`.</span></span> <span data-ttu-id="463f3-473">Dieser Satz besteht aus den benutzerdefinierten und angehobenen impliziten Konvertierungs Operatoren, die von den Klassen oder Strukturen in `D` deklariert werden, die von einem Typ konvertieren, der `S` in einen von `T`umschlossen Typ konvertiert.</span><span class="sxs-lookup"><span data-stu-id="463f3-473">This set consists of the user-defined and lifted implicit conversion operators declared by the classes or structs in `D` that convert from a type encompassing `S` to a type encompassed by `T`.</span></span> <span data-ttu-id="463f3-474">Wenn `U` leer ist, ist die Konvertierung nicht definiert, und es tritt ein Kompilierzeitfehler auf.</span><span class="sxs-lookup"><span data-stu-id="463f3-474">If `U` is empty, the conversion is undefined and a compile-time error occurs.</span></span>
*  <span data-ttu-id="463f3-475">Suchen Sie den spezifischsten Quelltyp (`SX`) der Operatoren in `U`:</span><span class="sxs-lookup"><span data-stu-id="463f3-475">Find the most specific source type, `SX`, of the operators in `U`:</span></span>
    * <span data-ttu-id="463f3-476">Wenn einer der Operatoren in `U` aus `S`konvertieren, wird `SX` `S`.</span><span class="sxs-lookup"><span data-stu-id="463f3-476">If any of the operators in `U` convert from `S`, then `SX` is `S`.</span></span>
    * <span data-ttu-id="463f3-477">Andernfalls ist `SX` der in der kombinierten Gruppe von Quell Typen der Operatoren in `U`der Typ, der am häufigsten eingeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="463f3-477">Otherwise, `SX` is the most encompassed type in the combined set of source types of the operators in `U`.</span></span> <span data-ttu-id="463f3-478">Wenn nicht genau ein Typ gefunden werden kann, der in der zwischen Version enthalten ist, ist die Konvertierung mehrdeutig, und es tritt ein Kompilierzeitfehler auf.</span><span class="sxs-lookup"><span data-stu-id="463f3-478">If exactly one most encompassed type cannot be found, then the conversion is ambiguous and a compile-time error occurs.</span></span>
*  <span data-ttu-id="463f3-479">Suchen Sie den spezifischsten Zieltyp (`TX`) der Operatoren in `U`:</span><span class="sxs-lookup"><span data-stu-id="463f3-479">Find the most specific target type, `TX`, of the operators in `U`:</span></span>
    * <span data-ttu-id="463f3-480">Wenn einer der Operatoren in `U` in `T`konvertiert wird, wird `TX` `T`.</span><span class="sxs-lookup"><span data-stu-id="463f3-480">If any of the operators in `U` convert to `T`, then `TX` is `T`.</span></span>
    * <span data-ttu-id="463f3-481">Andernfalls ist `TX` der umfassendste Typ in der kombinierten Gruppe von Zieltypen der Operatoren in `U`.</span><span class="sxs-lookup"><span data-stu-id="463f3-481">Otherwise, `TX` is the most encompassing type in the combined set of target types of the operators in `U`.</span></span> <span data-ttu-id="463f3-482">Wenn genau ein Typ mit der höchsten Verfügbarkeit nicht gefunden werden kann, ist die Konvertierung mehrdeutig, und es tritt ein Kompilierzeitfehler auf.</span><span class="sxs-lookup"><span data-stu-id="463f3-482">If exactly one most encompassing type cannot be found, then the conversion is ambiguous and a compile-time error occurs.</span></span>
*  <span data-ttu-id="463f3-483">Suchen Sie den spezifischsten Konvertierungs Operator:</span><span class="sxs-lookup"><span data-stu-id="463f3-483">Find the most specific conversion operator:</span></span>
    * <span data-ttu-id="463f3-484">Wenn `U` genau einen benutzerdefinierten Konvertierungs Operator enthält, der von `SX` in `TX`konvertiert, ist dies der spezifischere Konvertierungs Operator.</span><span class="sxs-lookup"><span data-stu-id="463f3-484">If `U` contains exactly one user-defined conversion operator that converts from `SX` to `TX`, then this is the most specific conversion operator.</span></span>
    * <span data-ttu-id="463f3-485">Andernfalls, wenn `U` genau einen Operator mit erhöhten Umwandlungen enthält, der von `SX` in `TX`konvertiert, ist dies der spezifischere Konvertierungs Operator.</span><span class="sxs-lookup"><span data-stu-id="463f3-485">Otherwise, if `U` contains exactly one lifted conversion operator that converts from `SX` to `TX`, then this is the most specific conversion operator.</span></span>
    * <span data-ttu-id="463f3-486">Andernfalls ist die Konvertierung mehrdeutig, und es tritt ein Kompilierzeitfehler auf.</span><span class="sxs-lookup"><span data-stu-id="463f3-486">Otherwise, the conversion is ambiguous and a compile-time error occurs.</span></span>
*  <span data-ttu-id="463f3-487">Übernehmen Sie schließlich die Konvertierung:</span><span class="sxs-lookup"><span data-stu-id="463f3-487">Finally, apply the conversion:</span></span>
    * <span data-ttu-id="463f3-488">Wenn `S` nicht `SX`ist, wird eine standardmäßige implizite Konvertierung von `S` in `SX` ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="463f3-488">If `S` is not `SX`, then a standard implicit conversion from `S` to `SX` is performed.</span></span>
    * <span data-ttu-id="463f3-489">Der spezifischere Konvertierungs Operator wird aufgerufen, um von `SX` in `TX`zu konvertieren.</span><span class="sxs-lookup"><span data-stu-id="463f3-489">The most specific conversion operator is invoked to convert from `SX` to `TX`.</span></span>
    * <span data-ttu-id="463f3-490">Wenn `TX` nicht `T`ist, wird eine standardmäßige implizite Konvertierung von `TX` in `T` ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="463f3-490">If `TX` is not `T`, then a standard implicit conversion from `TX` to `T` is performed.</span></span>

### <a name="processing-of-user-defined-explicit-conversions"></a><span data-ttu-id="463f3-491">Verarbeiten benutzerdefinierter expliziter Konvertierungen</span><span class="sxs-lookup"><span data-stu-id="463f3-491">Processing of user-defined explicit conversions</span></span>

<span data-ttu-id="463f3-492">Eine benutzerdefinierte explizite Konvertierung vom Typ `S` in den Typ `T` wird wie folgt verarbeitet:</span><span class="sxs-lookup"><span data-stu-id="463f3-492">A user-defined explicit conversion from type `S` to type `T` is processed as follows:</span></span>

*  <span data-ttu-id="463f3-493">Bestimmen Sie die Typen `S0` und `T0`.</span><span class="sxs-lookup"><span data-stu-id="463f3-493">Determine the types `S0` and `T0`.</span></span> <span data-ttu-id="463f3-494">Wenn `S` oder `T` Typen NULL-Werte zulassen, sind `S0` und `T0` ihre zugrunde liegenden Typen. andernfalls sind `S0` und `T0` gleich `S` bzw. `T`.</span><span class="sxs-lookup"><span data-stu-id="463f3-494">If `S` or `T` are nullable types, `S0` and `T0` are their underlying types, otherwise `S0` and `T0` are equal to `S` and `T` respectively.</span></span>
*  <span data-ttu-id="463f3-495">Suchen Sie den Satz von Typen, `D`, von dem benutzerdefinierte Konvertierungs Operatoren berücksichtigt werden.</span><span class="sxs-lookup"><span data-stu-id="463f3-495">Find the set of types, `D`, from which user-defined conversion operators will be considered.</span></span> <span data-ttu-id="463f3-496">Dieser Satz besteht aus `S0` (wenn `S0` eine Klasse oder Struktur ist), den Basisklassen von `S0` (wenn `S0` eine Klasse ist), `T0` (wenn `T0` eine Klasse oder Struktur ist) und den Basisklassen von `T0` (wenn `T0` eine Klasse ist).</span><span class="sxs-lookup"><span data-stu-id="463f3-496">This set consists of `S0` (if `S0` is a class or struct), the base classes of `S0` (if `S0` is a class), `T0` (if `T0` is a class or struct), and the base classes of `T0` (if `T0` is a class).</span></span>
*  <span data-ttu-id="463f3-497">Suchen Sie den Satz der anwendbaren benutzerdefinierten und erhöhten Konvertierungs Operatoren, `U`.</span><span class="sxs-lookup"><span data-stu-id="463f3-497">Find the set of applicable user-defined and lifted conversion operators, `U`.</span></span> <span data-ttu-id="463f3-498">Dieser Satz besteht aus den benutzerdefinierten, impliziten oder expliziten Konvertierungs Operatoren, die von den Klassen oder Strukturen in `D` deklariert werden, die von einem Typ konvertieren, der durch `S` in einen Typ konvertiert wird, der durch `T`eingeschlossen oder eingeschlossen wird.</span><span class="sxs-lookup"><span data-stu-id="463f3-498">This set consists of the user-defined and lifted implicit or explicit conversion operators declared by the classes or structs in `D` that convert from a type encompassing or encompassed by `S` to a type encompassing or encompassed by `T`.</span></span> <span data-ttu-id="463f3-499">Wenn `U` leer ist, ist die Konvertierung nicht definiert, und es tritt ein Kompilierzeitfehler auf.</span><span class="sxs-lookup"><span data-stu-id="463f3-499">If `U` is empty, the conversion is undefined and a compile-time error occurs.</span></span>
*  <span data-ttu-id="463f3-500">Suchen Sie den spezifischsten Quelltyp (`SX`) der Operatoren in `U`:</span><span class="sxs-lookup"><span data-stu-id="463f3-500">Find the most specific source type, `SX`, of the operators in `U`:</span></span>
    * <span data-ttu-id="463f3-501">Wenn einer der Operatoren in `U` aus `S`konvertieren, wird `SX` `S`.</span><span class="sxs-lookup"><span data-stu-id="463f3-501">If any of the operators in `U` convert from `S`, then `SX` is `S`.</span></span>
    * <span data-ttu-id="463f3-502">Andernfalls ist `SX`, wenn einer der Operatoren in `U` von Typen konvertiert, die `S`umfassen, der am häufigsten in der kombinierten Gruppe von Quell Typen dieser Operatoren enthaltenen Typ.</span><span class="sxs-lookup"><span data-stu-id="463f3-502">Otherwise, if any of the operators in `U` convert from types that encompass `S`, then `SX` is the most encompassed type in the combined set of source types of those operators.</span></span> <span data-ttu-id="463f3-503">Wenn kein Typ gefunden werden kann, ist die Konvertierung mehrdeutig, und es tritt ein Kompilierzeitfehler auf.</span><span class="sxs-lookup"><span data-stu-id="463f3-503">If no most encompassed type can be found, then the conversion is ambiguous and a compile-time error occurs.</span></span>
    * <span data-ttu-id="463f3-504">Andernfalls ist `SX` der umfassendste Typ in der kombinierten Gruppe von Quell Typen der Operatoren in `U`.</span><span class="sxs-lookup"><span data-stu-id="463f3-504">Otherwise, `SX` is the most encompassing type in the combined set of source types of the operators in `U`.</span></span> <span data-ttu-id="463f3-505">Wenn genau ein Typ mit der höchsten Verfügbarkeit nicht gefunden werden kann, ist die Konvertierung mehrdeutig, und es tritt ein Kompilierzeitfehler auf.</span><span class="sxs-lookup"><span data-stu-id="463f3-505">If exactly one most encompassing type cannot be found, then the conversion is ambiguous and a compile-time error occurs.</span></span>
*  <span data-ttu-id="463f3-506">Suchen Sie den spezifischsten Zieltyp (`TX`) der Operatoren in `U`:</span><span class="sxs-lookup"><span data-stu-id="463f3-506">Find the most specific target type, `TX`, of the operators in `U`:</span></span>
    * <span data-ttu-id="463f3-507">Wenn einer der Operatoren in `U` in `T`konvertiert wird, wird `TX` `T`.</span><span class="sxs-lookup"><span data-stu-id="463f3-507">If any of the operators in `U` convert to `T`, then `TX` is `T`.</span></span>
    * <span data-ttu-id="463f3-508">Wenn einer der Operatoren in `U` in Typen konvertiert werden soll, die von `T`eingeschlossen werden, dann ist `TX` der umfassendste Typ in der kombinierten Gruppe von Zieltypen dieser Operatoren.</span><span class="sxs-lookup"><span data-stu-id="463f3-508">Otherwise, if any of the operators in `U` convert to types that are encompassed by `T`, then `TX` is the most encompassing type in the combined set of target types of those operators.</span></span> <span data-ttu-id="463f3-509">Wenn genau ein Typ mit der höchsten Verfügbarkeit nicht gefunden werden kann, ist die Konvertierung mehrdeutig, und es tritt ein Kompilierzeitfehler auf.</span><span class="sxs-lookup"><span data-stu-id="463f3-509">If exactly one most encompassing type cannot be found, then the conversion is ambiguous and a compile-time error occurs.</span></span>
    * <span data-ttu-id="463f3-510">Andernfalls ist `TX` der kombinierte Typ in der kombinierten Menge von Zieltypen der Operatoren in `U`.</span><span class="sxs-lookup"><span data-stu-id="463f3-510">Otherwise, `TX` is the most encompassed type in the combined set of target types of the operators in `U`.</span></span> <span data-ttu-id="463f3-511">Wenn kein Typ gefunden werden kann, ist die Konvertierung mehrdeutig, und es tritt ein Kompilierzeitfehler auf.</span><span class="sxs-lookup"><span data-stu-id="463f3-511">If no most encompassed type can be found, then the conversion is ambiguous and a compile-time error occurs.</span></span>
*  <span data-ttu-id="463f3-512">Suchen Sie den spezifischsten Konvertierungs Operator:</span><span class="sxs-lookup"><span data-stu-id="463f3-512">Find the most specific conversion operator:</span></span>
    * <span data-ttu-id="463f3-513">Wenn `U` genau einen benutzerdefinierten Konvertierungs Operator enthält, der von `SX` in `TX`konvertiert, ist dies der spezifischere Konvertierungs Operator.</span><span class="sxs-lookup"><span data-stu-id="463f3-513">If `U` contains exactly one user-defined conversion operator that converts from `SX` to `TX`, then this is the most specific conversion operator.</span></span>
    * <span data-ttu-id="463f3-514">Andernfalls, wenn `U` genau einen Operator mit erhöhten Umwandlungen enthält, der von `SX` in `TX`konvertiert, ist dies der spezifischere Konvertierungs Operator.</span><span class="sxs-lookup"><span data-stu-id="463f3-514">Otherwise, if `U` contains exactly one lifted conversion operator that converts from `SX` to `TX`, then this is the most specific conversion operator.</span></span>
    * <span data-ttu-id="463f3-515">Andernfalls ist die Konvertierung mehrdeutig, und es tritt ein Kompilierzeitfehler auf.</span><span class="sxs-lookup"><span data-stu-id="463f3-515">Otherwise, the conversion is ambiguous and a compile-time error occurs.</span></span>
*  <span data-ttu-id="463f3-516">Übernehmen Sie schließlich die Konvertierung:</span><span class="sxs-lookup"><span data-stu-id="463f3-516">Finally, apply the conversion:</span></span>
    * <span data-ttu-id="463f3-517">Wenn `S` nicht `SX`ist, wird eine explizite Standard Konvertierung von `S` in `SX` ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="463f3-517">If `S` is not `SX`, then a standard explicit conversion from `S` to `SX` is performed.</span></span>
    * <span data-ttu-id="463f3-518">Der spezifischere benutzerdefinierte Konvertierungs Operator wird aufgerufen, um von `SX` in `TX`zu konvertieren.</span><span class="sxs-lookup"><span data-stu-id="463f3-518">The most specific user-defined conversion operator is invoked to convert from `SX` to `TX`.</span></span>
    * <span data-ttu-id="463f3-519">Wenn `TX` nicht `T`ist, wird eine explizite Standard Konvertierung von `TX` in `T` ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="463f3-519">If `TX` is not `T`, then a standard explicit conversion from `TX` to `T` is performed.</span></span>

## <a name="anonymous-function-conversions"></a><span data-ttu-id="463f3-520">Anonyme Funktions Konvertierungen</span><span class="sxs-lookup"><span data-stu-id="463f3-520">Anonymous function conversions</span></span>

<span data-ttu-id="463f3-521">Eine *anonymous_method_expression* oder *lambda_expression* wird als anonyme Funktion ([Anonyme Funktions Ausdrücke](expressions.md#anonymous-function-expressions)) klassifiziert.</span><span class="sxs-lookup"><span data-stu-id="463f3-521">An *anonymous_method_expression* or *lambda_expression* is classified as an anonymous function ([Anonymous function expressions](expressions.md#anonymous-function-expressions)).</span></span> <span data-ttu-id="463f3-522">Der Ausdruck weist keinen Typ auf, kann aber implizit in einen kompatiblen Delegattyp oder Ausdrucks Strukturtyp konvertiert werden.</span><span class="sxs-lookup"><span data-stu-id="463f3-522">The expression does not have a type but can be implicitly converted to a compatible delegate type or expression tree type.</span></span> <span data-ttu-id="463f3-523">Ein anonymer Funktions `F` ist insbesondere mit einem `D` bereitgestellten Delegattyp kompatibel:</span><span class="sxs-lookup"><span data-stu-id="463f3-523">Specifically, an anonymous function `F` is compatible with a delegate type `D` provided:</span></span>

*  <span data-ttu-id="463f3-524">Wenn `F` eine *anonymous_function_signature*enthält, verfügen `D` und `F` über die gleiche Anzahl von Parametern.</span><span class="sxs-lookup"><span data-stu-id="463f3-524">If `F` contains an *anonymous_function_signature*, then `D` and `F` have the same number of parameters.</span></span>
*  <span data-ttu-id="463f3-525">Wenn `F` keinen *anonymous_function_signature*enthält, haben `D` möglicherweise NULL oder mehr Parameter eines beliebigen Typs, solange kein Parameter von `D` den `out` Parametermodifizierer aufweist.</span><span class="sxs-lookup"><span data-stu-id="463f3-525">If `F` does not contain an *anonymous_function_signature*, then `D` may have zero or more parameters of any type, as long as no parameter of `D` has the `out` parameter modifier.</span></span>
*  <span data-ttu-id="463f3-526">Wenn `F` über eine explizit typisierte Parameterliste verfügt, weist jeder Parameter in `D` den gleichen Typ und die gleichen Modifizierer wie der entsprechende Parameter in `F`auf.</span><span class="sxs-lookup"><span data-stu-id="463f3-526">If `F` has an explicitly typed parameter list, each parameter in `D` has the same type and modifiers as the corresponding parameter in `F`.</span></span>
*  <span data-ttu-id="463f3-527">Wenn `F` eine implizit typisierte Parameterliste aufweist, hat `D` keine `ref` oder `out` Parameter.</span><span class="sxs-lookup"><span data-stu-id="463f3-527">If `F` has an implicitly typed parameter list, `D` has no `ref` or `out` parameters.</span></span>
*  <span data-ttu-id="463f3-528">Wenn der Text des `F` ein Ausdruck ist und entweder `D` einen `void` Rückgabetyp hat oder `F` Async ist und `D` den Rückgabetyp `Task`hat, dann ist der Text des `F` ein gültiger Ausdruck (WRT [Expressions](expressions.md)), der als *`D`* ([Ausdrucks Anweisungen](statements.md#expression-statements)) zulässig ist.</span><span class="sxs-lookup"><span data-stu-id="463f3-528">If the body of `F` is an expression, and either `D` has a `void` return type or `F` is async and `D` has the return type `Task`, then when each parameter of `F` is given the type of the corresponding parameter in `D`, the body of `F` is a valid expression (wrt [Expressions](expressions.md)) that would be permitted as a *statement_expression* ([Expression statements](statements.md#expression-statements)).</span></span>
*  <span data-ttu-id="463f3-529">Wenn der Hauptteil des `F` ein Anweisungsblock ist und entweder `D` einen `void` Rückgabetyp hat oder `F` Async und `D` den Rückgabetyp `Task`hat, ist der Text des `F` ein gültiger Anweisungsblock (WRT- [Blöcke](statements.md#blocks)), in dem keine `D`Anweisung einen Ausdruck angibt.</span><span class="sxs-lookup"><span data-stu-id="463f3-529">If the body of `F` is a statement block, and either `D` has a `void` return type or `F` is async and `D` has the return type `Task`, then when each parameter of `F` is given the type of the corresponding parameter in `D`, the body of `F` is a valid statement block (wrt [Blocks](statements.md#blocks)) in which no `return` statement specifies an expression.</span></span>
*  <span data-ttu-id="463f3-530">Wenn der Text des `F` ein Ausdruck ist und *entweder* `F` nicht Async ist und `D` einen nicht leeren Rückgabetyp `T`hat, *oder* `F` asynchron ist und `D` einen Rückgabetyp `Task<T>`hat, ist der Text des `F` ein gültiger Ausdruck (WRT [Expressions](expressions.md)), der implizit in `D`konvertiert werden kann.</span><span class="sxs-lookup"><span data-stu-id="463f3-530">If the body of `F` is an expression, and *either* `F` is non-async and `D` has a non-void return type `T`, *or* `F` is async and `D` has a return type `Task<T>`, then when each parameter of `F` is given the type of the corresponding parameter in `D`, the body of `F` is a valid expression (wrt [Expressions](expressions.md)) that is implicitly convertible to `T`.</span></span>
*  <span data-ttu-id="463f3-531">Wenn der Hauptteil des `F` ein Anweisungsblock ist und *entweder* `F` nicht Async ist und `D` einen nicht leeren Rückgabetyp `T`hat, *oder* `F` ist async, und `D` hat einen Rückgabetyp `Task<T>`. Wenn jedem Parameter `F` der Typ des entsprechenden Parameters in `D`zugewiesen wird, ist der Text des `F` ein gültiger Anweisungsblock (WRT- [Blöcke](statements.md#blocks)) mit einem nicht erreichbaren Endpunkt, bei dem jede `return` Anweisung einen Ausdruck angibt, der implizit in `T`konvertiert werden kann.</span><span class="sxs-lookup"><span data-stu-id="463f3-531">If the body of `F` is a statement block, and *either* `F` is non-async and `D` has a non-void return type `T`, *or* `F` is async and `D` has a return type `Task<T>`, then when each parameter of `F` is given the type of the corresponding parameter in `D`, the body of `F` is a valid statement block (wrt [Blocks](statements.md#blocks)) with a non-reachable end point in which each `return` statement specifies an expression that is implicitly convertible to `T`.</span></span>

<span data-ttu-id="463f3-532">Aus Gründen der Kürze verwendet dieser Abschnitt die Kurzform für die Aufgaben Typen `Task` und `Task<T>` ([Async-Funktionen](classes.md#async-functions)).</span><span class="sxs-lookup"><span data-stu-id="463f3-532">For the purpose of brevity, this section uses the short form for the task types `Task` and `Task<T>` ([Async functions](classes.md#async-functions)).</span></span>

<span data-ttu-id="463f3-533">Ein Lambda-Ausdruck `F` ist mit einem Ausdrucks bauentyp kompatibel `Expression<D>` wenn `F` mit dem Delegattyp `D`kompatibel ist.</span><span class="sxs-lookup"><span data-stu-id="463f3-533">A lambda expression `F` is compatible with an expression tree type `Expression<D>` if `F` is compatible with the delegate type `D`.</span></span> <span data-ttu-id="463f3-534">Beachten Sie, dass dies nicht für anonyme Methoden gilt, sondern nur für Lambda-Ausdrücke.</span><span class="sxs-lookup"><span data-stu-id="463f3-534">Note that this does not apply to anonymous methods, only lambda expressions.</span></span>

<span data-ttu-id="463f3-535">Bestimmte Lambda-Ausdrücke können nicht in Ausdrucks Baumstruktur Typen konvertiert werden: Obwohl die Konvertierung *vorhanden*ist, schlägt Sie zur Kompilierzeit fehl.</span><span class="sxs-lookup"><span data-stu-id="463f3-535">Certain lambda expressions cannot be converted to expression tree types: Even though the conversion *exists*, it fails at compile-time.</span></span> <span data-ttu-id="463f3-536">Dies ist der Fall, wenn der Lambda-Ausdruck:</span><span class="sxs-lookup"><span data-stu-id="463f3-536">This is the case if the lambda expression:</span></span>

*  <span data-ttu-id="463f3-537">Weist einen *Block* Text auf.</span><span class="sxs-lookup"><span data-stu-id="463f3-537">Has a *block* body</span></span>
*  <span data-ttu-id="463f3-538">Enthält einfache oder Verbund Zuweisungs Operatoren.</span><span class="sxs-lookup"><span data-stu-id="463f3-538">Contains simple or compound assignment operators</span></span>
*  <span data-ttu-id="463f3-539">Enthält einen dynamisch gebundenen Ausdruck.</span><span class="sxs-lookup"><span data-stu-id="463f3-539">Contains a dynamically bound expression</span></span>
*  <span data-ttu-id="463f3-540">Ist Async</span><span class="sxs-lookup"><span data-stu-id="463f3-540">Is async</span></span>

<span data-ttu-id="463f3-541">In den folgenden Beispielen wird ein generischer Delegattyp `Func<A,R>` verwendet, der eine Funktion darstellt, die ein Argument vom Typ `A` annimmt und einen Wert vom Typ `R`zurückgibt:</span><span class="sxs-lookup"><span data-stu-id="463f3-541">The examples that follow use a generic delegate type `Func<A,R>` which represents a function that takes an argument of type `A` and returns a value of type `R`:</span></span>
```csharp
delegate R Func<A,R>(A arg);
```

<span data-ttu-id="463f3-542">In den Zuweisungen</span><span class="sxs-lookup"><span data-stu-id="463f3-542">In the assignments</span></span>
```csharp
Func<int,int> f1 = x => x + 1;                 // Ok

Func<int,double> f2 = x => x + 1;              // Ok

Func<double,int> f3 = x => x + 1;              // Error

Func<int, Task<int>> f4 = async x => x + 1;    // Ok
```
<span data-ttu-id="463f3-543">der Parameter und die Rückgabe Typen der einzelnen anonymen Funktionen werden vom Typ der Variablen bestimmt, der die anonyme Funktion zugewiesen wird.</span><span class="sxs-lookup"><span data-stu-id="463f3-543">the parameter and return types of each anonymous function are determined from the type of the variable to which the anonymous function is assigned.</span></span>

<span data-ttu-id="463f3-544">Bei der ersten Zuweisung wird die anonyme Funktion erfolgreich in den Delegattyp konvertiert `Func<int,int>` weil `x` den Typ `int`erhält, `x+1` ein gültiger Ausdruck ist, der implizit in den Typ `int`konvertiert werden kann.</span><span class="sxs-lookup"><span data-stu-id="463f3-544">The first assignment successfully converts the anonymous function to the delegate type `Func<int,int>` because, when `x` is given type `int`, `x+1` is a valid expression that is implicitly convertible to type `int`.</span></span>

<span data-ttu-id="463f3-545">Entsprechend konvertiert die zweite Zuweisung die anonyme Funktion erfolgreich in den Delegattyp `Func<int,double>`, da das Ergebnis `x+1` (vom Typ `int`) implizit in den Typ `double`konvertiert werden kann.</span><span class="sxs-lookup"><span data-stu-id="463f3-545">Likewise, the second assignment successfully converts the anonymous function to the delegate type `Func<int,double>` because the result of `x+1` (of type `int`) is implicitly convertible to type `double`.</span></span>

<span data-ttu-id="463f3-546">Die dritte Zuweisung ist jedoch ein Kompilierzeitfehler, da das Ergebnis von `x+1` (vom Typ `double`) nicht implizit in den Typ `int`konvertiert werden kann, wenn `x` den Typ `double`erhält.</span><span class="sxs-lookup"><span data-stu-id="463f3-546">However, the third assignment is a compile-time error because, when `x` is given type `double`, the result of `x+1` (of type `double`) is not implicitly convertible to type `int`.</span></span>

<span data-ttu-id="463f3-547">Mit der vierten Zuweisung wird die anonyme Async-Funktion erfolgreich in den Delegattyp konvertiert `Func<int, Task<int>>` da das Ergebnis `x+1` (vom Typ `int`) implizit in den Ergebnistyp `int` des Aufgabentyp `Task<int>`konvertiert werden kann.</span><span class="sxs-lookup"><span data-stu-id="463f3-547">The fourth assignment successfully converts the anonymous async function to the delegate type `Func<int, Task<int>>` because the result of `x+1` (of type `int`) is implicitly convertible to the result type `int` of the task type `Task<int>`.</span></span>

<span data-ttu-id="463f3-548">Anonyme Funktionen können die Überladungs Auflösung beeinflussen und an einem Typrückschluss teilnehmen.</span><span class="sxs-lookup"><span data-stu-id="463f3-548">Anonymous functions may influence overload resolution, and participate in type inference.</span></span> <span data-ttu-id="463f3-549">Weitere Informationen finden Sie unter [Funktionsmember](expressions.md#function-members) .</span><span class="sxs-lookup"><span data-stu-id="463f3-549">See [Function members](expressions.md#function-members) for further details.</span></span>

### <a name="evaluation-of-anonymous-function-conversions-to-delegate-types"></a><span data-ttu-id="463f3-550">Auswertung anonymer Funktions Konvertierungen in Delegattypen</span><span class="sxs-lookup"><span data-stu-id="463f3-550">Evaluation of anonymous function conversions to delegate types</span></span>

<span data-ttu-id="463f3-551">Die Konvertierung einer anonymen Funktion in einen Delegattyp erzeugt eine Delegatinstanz, die auf die anonyme Funktion und den (möglicherweise leeren) Satz erfasster äußerer Variablen verweist, die zum Zeitpunkt der Auswertung aktiv sind.</span><span class="sxs-lookup"><span data-stu-id="463f3-551">Conversion of an anonymous function to a delegate type produces a delegate instance which references the anonymous function and the (possibly empty) set of captured outer variables that are active at the time of the evaluation.</span></span> <span data-ttu-id="463f3-552">Wenn der Delegat aufgerufen wird, wird der Text der anonymen Funktion ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="463f3-552">When the delegate is invoked, the body of the anonymous function is executed.</span></span> <span data-ttu-id="463f3-553">Der Code im Text wird mit dem Satz erfasster äußerer Variablen ausgeführt, auf die der Delegat verweist.</span><span class="sxs-lookup"><span data-stu-id="463f3-553">The code in the body is executed using the set of captured outer variables referenced by the delegate.</span></span>

<span data-ttu-id="463f3-554">Die Aufruf Liste eines Delegaten, der aus einer anonymen Funktion erstellt wurde, enthält einen einzelnen Eintrag.</span><span class="sxs-lookup"><span data-stu-id="463f3-554">The invocation list of a delegate produced from an anonymous function contains a single entry.</span></span> <span data-ttu-id="463f3-555">Das genaue Zielobjekt und die Ziel Methode des Delegaten sind nicht angegeben.</span><span class="sxs-lookup"><span data-stu-id="463f3-555">The exact target object and target method of the delegate are unspecified.</span></span> <span data-ttu-id="463f3-556">Insbesondere ist nicht angegeben, ob das Zielobjekt des Delegaten `null`, der `this` Wert des einschließenden Funktionsmembers oder ein anderes Objekt ist.</span><span class="sxs-lookup"><span data-stu-id="463f3-556">In particular, it is unspecified whether the target object of the delegate is `null`, the `this` value of the enclosing function member, or some other object.</span></span>

<span data-ttu-id="463f3-557">Konvertierungen von semantisch identischen anonymen Funktionen mit dem gleichen (möglicherweise leeren) Satz erfasster externer Variablen Instanzen in dieselben Delegattypen sind zulässig (jedoch nicht erforderlich), um dieselbe Delegatinstanz zurückzugeben.</span><span class="sxs-lookup"><span data-stu-id="463f3-557">Conversions of semantically identical anonymous functions with the same (possibly empty) set of captured outer variable instances to the same delegate types are permitted (but not required) to return the same delegate instance.</span></span> <span data-ttu-id="463f3-558">Der Begriff semantisch identisch wird hier verwendet, um zu bedeuten, dass die Ausführung der anonymen Funktionen in allen Fällen dieselben Effekte mit denselben Argumenten erzeugt.</span><span class="sxs-lookup"><span data-stu-id="463f3-558">The term semantically identical is used here to mean that execution of the anonymous functions will, in all cases, produce the same effects given the same arguments.</span></span> <span data-ttu-id="463f3-559">Diese Regel ermöglicht es, Code wie den folgenden zu optimieren.</span><span class="sxs-lookup"><span data-stu-id="463f3-559">This rule permits code such as the following to be optimized.</span></span>

```csharp
delegate double Function(double x);

class Test
{
    static double[] Apply(double[] a, Function f) {
        double[] result = new double[a.Length];
        for (int i = 0; i < a.Length; i++) result[i] = f(a[i]);
        return result;
    }

    static void F(double[] a, double[] b) {
        a = Apply(a, (double x) => Math.Sin(x));
        b = Apply(b, (double y) => Math.Sin(y));
        ...
    }
}
```

<span data-ttu-id="463f3-560">Da die beiden anonymen Funktions Delegaten denselben (leeren) Satz erfasster äußerer Variablen aufweisen und die anonymen Funktionen semantisch identisch sind, ist es dem Compiler gestattet, dass die Delegaten auf dieselbe Ziel Methode verweisen.</span><span class="sxs-lookup"><span data-stu-id="463f3-560">Since the two anonymous function delegates have the same (empty) set of captured outer variables, and since the anonymous functions are semantically identical, the compiler is permitted to have the delegates refer to the same target method.</span></span> <span data-ttu-id="463f3-561">Tatsächlich ist es dem Compiler gestattet, dieselbe Delegatinstanz aus beiden anonymen Funktions Ausdrücken zurückzugeben.</span><span class="sxs-lookup"><span data-stu-id="463f3-561">Indeed, the compiler is permitted to return the very same delegate instance from both anonymous function expressions.</span></span>

### <a name="evaluation-of-anonymous-function-conversions-to-expression-tree-types"></a><span data-ttu-id="463f3-562">Auswertung anonymer Funktions Konvertierungen in Ausdrucks Baumstruktur Typen</span><span class="sxs-lookup"><span data-stu-id="463f3-562">Evaluation of anonymous function conversions to expression tree types</span></span>

<span data-ttu-id="463f3-563">Die Konvertierung einer anonymen Funktion in einen Ausdrucks bauentyp erzeugt eine Ausdrucks Baumstruktur ([Ausdrucks Baumstruktur Typen](types.md#expression-tree-types)).</span><span class="sxs-lookup"><span data-stu-id="463f3-563">Conversion of an anonymous function to an expression tree type produces an expression tree ([Expression tree types](types.md#expression-tree-types)).</span></span> <span data-ttu-id="463f3-564">Genauer bedeutet, dass die Auswertung der anonymen Funktions Konvertierung zur Erstellung einer Objektstruktur führt, die die Struktur der anonymen Funktion darstellt.</span><span class="sxs-lookup"><span data-stu-id="463f3-564">More precisely, evaluation of the anonymous function conversion leads to the construction of an object structure that represents the structure of the anonymous function itself.</span></span> <span data-ttu-id="463f3-565">Die genaue Struktur der Ausdrucks Baumstruktur sowie der genaue Prozess für die Erstellung werden implementiert.</span><span class="sxs-lookup"><span data-stu-id="463f3-565">The precise structure of the expression tree, as well as the exact process for creating it, are implementation defined.</span></span>

### <a name="implementation-example"></a><span data-ttu-id="463f3-566">Beispiel für die Implementierung</span><span class="sxs-lookup"><span data-stu-id="463f3-566">Implementation example</span></span>

<span data-ttu-id="463f3-567">In diesem Abschnitt wird eine mögliche Implementierung anonymer Funktions Konvertierungen in Bezug C# auf andere Konstrukte beschrieben.</span><span class="sxs-lookup"><span data-stu-id="463f3-567">This section describes a possible implementation of anonymous function conversions in terms of other C# constructs.</span></span> <span data-ttu-id="463f3-568">Die hier beschriebene Implementierung basiert auf denselben Prinzipien, die vom Microsoft C# -Compiler verwendet werden, aber es handelt sich nicht um eine obligatorische Implementierung, und es handelt sich nicht um die einzige Möglichkeit.</span><span class="sxs-lookup"><span data-stu-id="463f3-568">The implementation described here is based on the same principles used by the Microsoft C# compiler, but it is by no means a mandated implementation, nor is it the only one possible.</span></span> <span data-ttu-id="463f3-569">Die Konvertierung in Ausdrucks Baumstrukturen wird nur kurz erwähnt, da die genaue Semantik außerhalb des Gültigkeits Bereichs dieser Spezifikation liegt.</span><span class="sxs-lookup"><span data-stu-id="463f3-569">It only briefly mentions conversions to expression trees, as their exact semantics are outside the scope of this specification.</span></span>

<span data-ttu-id="463f3-570">Der Rest dieses Abschnitts enthält mehrere Beispiele für Code, der anonyme Funktionen mit unterschiedlichen Merkmalen enthält.</span><span class="sxs-lookup"><span data-stu-id="463f3-570">The remainder of this section gives several examples of code that contains anonymous functions with different characteristics.</span></span> <span data-ttu-id="463f3-571">Für jedes Beispiel wird eine entsprechende Übersetzung in Code bereitgestellt, C# der nur andere Konstrukte verwendet.</span><span class="sxs-lookup"><span data-stu-id="463f3-571">For each example, a corresponding translation to code that uses only other C# constructs is provided.</span></span> <span data-ttu-id="463f3-572">In den Beispielen wird davon ausgegangen, dass der Bezeichner `D` von den folgenden Delegattyp repräsentiert:</span><span class="sxs-lookup"><span data-stu-id="463f3-572">In the examples, the identifier `D` is assumed by represent the following delegate type:</span></span>
```csharp
public delegate void D();
```

<span data-ttu-id="463f3-573">Die einfachste Form einer anonymen Funktion ist eine, die keine äußeren Variablen aufzeichnet:</span><span class="sxs-lookup"><span data-stu-id="463f3-573">The simplest form of an anonymous function is one that captures no outer variables:</span></span>
```csharp
class Test
{
    static void F() {
        D d = () => { Console.WriteLine("test"); };
    }
}
```

<span data-ttu-id="463f3-574">Dies kann in eine Delegatinstanziierung übersetzt werden, die auf eine vom Compiler generierte statische Methode verweist, in der der Code der anonymen Funktion platziert wird:</span><span class="sxs-lookup"><span data-stu-id="463f3-574">This can be translated to a delegate instantiation that references a compiler generated static method in which the code of the anonymous function is placed:</span></span>
```csharp
class Test
{
    static void F() {
        D d = new D(__Method1);
    }

    static void __Method1() {
        Console.WriteLine("test");
    }
}
```

<span data-ttu-id="463f3-575">Im folgenden Beispiel verweist die anonyme Funktion auf Instanzmember von `this`:</span><span class="sxs-lookup"><span data-stu-id="463f3-575">In the following example, the anonymous function references instance members of `this`:</span></span>
```csharp
class Test
{
    int x;

    void F() {
        D d = () => { Console.WriteLine(x); };
    }
}
```

<span data-ttu-id="463f3-576">Dies kann in eine vom Compiler generierte Instanzmethode übersetzt werden, die den Code der anonymen Funktion enthält:</span><span class="sxs-lookup"><span data-stu-id="463f3-576">This can be translated to a compiler generated instance method containing the code of the anonymous function:</span></span>
```csharp
class Test
{
    int x;

    void F() {
        D d = new D(__Method1);
    }

    void __Method1() {
        Console.WriteLine(x);
    }
}
```

<span data-ttu-id="463f3-577">In diesem Beispiel erfasst die anonyme Funktion eine lokale Variable:</span><span class="sxs-lookup"><span data-stu-id="463f3-577">In this example, the anonymous function captures a local variable:</span></span>
```csharp
class Test
{
    void F() {
        int y = 123;
        D d = () => { Console.WriteLine(y); };
    }
}
```

<span data-ttu-id="463f3-578">Die Lebensdauer der lokalen Variablen muss nun mindestens zur Lebensdauer des anonymen Funktions Delegaten verlängert werden.</span><span class="sxs-lookup"><span data-stu-id="463f3-578">The lifetime of the local variable must now be extended to at least the lifetime of the anonymous function delegate.</span></span> <span data-ttu-id="463f3-579">Dies kann erreicht werden, indem Sie die lokale Variable in ein Feld einer vom Compiler generierten Klasse einbinden.</span><span class="sxs-lookup"><span data-stu-id="463f3-579">This can be achieved by "hoisting" the local variable into a field of a compiler generated class.</span></span> <span data-ttu-id="463f3-580">Die Instanziierung der lokalen Variablen ([Instanziierung lokaler Variablen](expressions.md#instantiation-of-local-variables)) entspricht dann dem Erstellen einer Instanz der vom Compiler generierten Klasse, und der Zugriff auf die lokale Variable entspricht dem Zugriff auf ein Feld in der Instanz der vom Compiler generierten Klasse.</span><span class="sxs-lookup"><span data-stu-id="463f3-580">Instantiation of the local variable ([Instantiation of local variables](expressions.md#instantiation-of-local-variables)) then corresponds to creating an instance of the compiler generated class, and accessing the local variable corresponds to accessing a field in the instance of the compiler generated class.</span></span> <span data-ttu-id="463f3-581">Außerdem wird die anonyme Funktion zu einer Instanzmethode der vom Compiler generierten Klasse:</span><span class="sxs-lookup"><span data-stu-id="463f3-581">Furthermore, the anonymous function becomes an instance method of the compiler generated class:</span></span>
```csharp
class Test
{
    void F() {
        __Locals1 __locals1 = new __Locals1();
        __locals1.y = 123;
        D d = new D(__locals1.__Method1);
    }

    class __Locals1
    {
        public int y;

        public void __Method1() {
            Console.WriteLine(y);
        }
    }
}
```

<span data-ttu-id="463f3-582">Zum Schluss erfasst die folgende anonyme Funktion `this` und zwei lokale Variablen mit unterschiedlichen Lebens dauern:</span><span class="sxs-lookup"><span data-stu-id="463f3-582">Finally, the following anonymous function captures `this` as well as two local variables with different lifetimes:</span></span>
```csharp
class Test
{
    int x;

    void F() {
        int y = 123;
        for (int i = 0; i < 10; i++) {
            int z = i * 2;
            D d = () => { Console.WriteLine(x + y + z); };
        }
    }
}
```

<span data-ttu-id="463f3-583">Hier wird eine vom Compiler generierte Klasse für jeden Anweisungsblock erstellt, in dem lokale Variablen aufgezeichnet werden, sodass die lokalen Variablen in den verschiedenen Blöcken eine unabhängige Lebensdauer aufweisen können.</span><span class="sxs-lookup"><span data-stu-id="463f3-583">Here, a compiler generated class is created for each statement block in which locals are captured such that the locals in the different blocks can have independent lifetimes.</span></span> <span data-ttu-id="463f3-584">Eine Instanz von `__Locals2`, die vom Compiler generierte-Klasse für den inneren Anweisungsblock, enthält die lokale Variable `z` und ein Feld, das auf eine Instanz von `__Locals1`verweist.</span><span class="sxs-lookup"><span data-stu-id="463f3-584">An instance of `__Locals2`, the compiler generated class for the inner statement block, contains the local variable `z` and a field that references an instance of `__Locals1`.</span></span>  <span data-ttu-id="463f3-585">Eine Instanz von `__Locals1`, die vom Compiler generierte-Klasse für den äußeren Anweisungsblock, enthält die lokale Variable `y` und ein Feld, das auf `this` des einschließenden Funktionsmembers verweist.</span><span class="sxs-lookup"><span data-stu-id="463f3-585">An instance of `__Locals1`, the compiler generated class for the outer statement block, contains the local variable `y` and a field that references `this` of the enclosing function member.</span></span> <span data-ttu-id="463f3-586">Mit diesen Datenstrukturen ist es möglich, alle aufgezeichneten äußeren Variablen über eine Instanz von `__Local2`zu erreichen, und der Code der anonymen Funktion kann daher als Instanzmethode dieser Klasse implementiert werden.</span><span class="sxs-lookup"><span data-stu-id="463f3-586">With these data structures it is possible to reach all captured outer variables through an instance of `__Local2`, and the code of the anonymous function can thus be implemented as an instance method of that class.</span></span>

```csharp
class Test
{
    void F() {
        __Locals1 __locals1 = new __Locals1();
        __locals1.__this = this;
        __locals1.y = 123;
        for (int i = 0; i < 10; i++) {
            __Locals2 __locals2 = new __Locals2();
            __locals2.__locals1 = __locals1;
            __locals2.z = i * 2;
            D d = new D(__locals2.__Method1);
        }
    }

    class __Locals1
    {
        public Test __this;
        public int y;
    }

    class __Locals2
    {
        public __Locals1 __locals1;
        public int z;

        public void __Method1() {
            Console.WriteLine(__locals1.__this.x + __locals1.y + z);
        }
    }
}
```

<span data-ttu-id="463f3-587">Dieselbe Technik, die hier zum Erfassen von lokalen Variablen angewendet wird, kann auch beim Umrechnen anonymer Funktionen in Ausdrucks Baumstrukturen verwendet werden: Verweise auf die vom Compiler generierten Objekte können in der Ausdrucks Baumstruktur gespeichert werden, und der Zugriff auf die lokalen Variablen kann wird als Feld Zugriffen für diese Objekte dargestellt.</span><span class="sxs-lookup"><span data-stu-id="463f3-587">The same technique applied here to capture local variables can also be used when converting anonymous functions to expression trees: References to the compiler generated objects can be stored in the expression tree, and access to the local variables can be represented as field accesses on these objects.</span></span> <span data-ttu-id="463f3-588">Der Vorteil dieses Ansatzes besteht darin, dass die "angehobenen" lokalen Variablen für Delegaten und Ausdrucks Baumstrukturen freigegeben werden können.</span><span class="sxs-lookup"><span data-stu-id="463f3-588">The advantage of this approach is that it allows the "lifted" local variables to be shared between delegates and expression trees.</span></span>

## <a name="method-group-conversions"></a><span data-ttu-id="463f3-589">Methoden Gruppen Konvertierungen</span><span class="sxs-lookup"><span data-stu-id="463f3-589">Method group conversions</span></span>

<span data-ttu-id="463f3-590">Eine implizite Konvertierung ([implizite Konvertierungen](conversions.md#implicit-conversions)) ist in einer Methoden Gruppe ([Ausdrucks Klassifizierungen](expressions.md#expression-classifications)) zu einem kompatiblen Delegattyp vorhanden.</span><span class="sxs-lookup"><span data-stu-id="463f3-590">An implicit conversion ([Implicit conversions](conversions.md#implicit-conversions)) exists from a method group ([Expression classifications](expressions.md#expression-classifications)) to a compatible delegate type.</span></span> <span data-ttu-id="463f3-591">Bei einem Delegattyp `D` und einem Ausdrucks `E`, der als Methoden Gruppe klassifiziert ist, gibt es eine implizite Konvertierung von `E` in `D`, wenn `E` mindestens eine Methode enthält, die in ihrer normalen Form ([anwendbares Funktionsmember](expressions.md#applicable-function-member)) auf eine Argumentliste anwendbar ist, die mithilfe der Parametertypen und Modifizierer von `D`erstellt wurde, wie im folgenden beschrieben.</span><span class="sxs-lookup"><span data-stu-id="463f3-591">Given a delegate type `D` and an expression `E` that is classified as a method group, an implicit conversion exists from `E` to `D` if `E` contains at least one method that is applicable in its normal form ([Applicable function member](expressions.md#applicable-function-member)) to an argument list constructed by use of the parameter types and modifiers of `D`, as described in the following.</span></span>

<span data-ttu-id="463f3-592">Die Kompilierzeit Anwendung einer Konvertierung von einer Methoden Gruppe `E` in einen Delegattyp `D` wird im folgenden beschrieben.</span><span class="sxs-lookup"><span data-stu-id="463f3-592">The compile-time application of a conversion from a method group `E` to a delegate type `D` is described in the following.</span></span> <span data-ttu-id="463f3-593">Beachten Sie, dass das vorhanden sein einer impliziten Konvertierung von `E` in `D` nicht sicherstellt, dass die Kompilierzeit Anwendung der Konvertierung ohne Fehler erfolgreich ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="463f3-593">Note that the existence of an implicit conversion from `E` to `D` does not guarantee that the compile-time application of the conversion will succeed without error.</span></span>

*  <span data-ttu-id="463f3-594">Es wird eine einzelne Methode `M` ausgewählt, die einem Methodenaufruf ([Methodenaufrufe](expressions.md#method-invocations)) der Form `E(A)`entspricht, mit den folgenden Änderungen:</span><span class="sxs-lookup"><span data-stu-id="463f3-594">A single method `M` is selected corresponding to a method invocation ([Method invocations](expressions.md#method-invocations)) of the form `E(A)`, with the following modifications:</span></span>
    * <span data-ttu-id="463f3-595">Bei der Argumentliste `A` handelt es sich um eine Liste von Ausdrücken, die jeweils als Variable und mit dem Typ und Modifizierer (`ref` oder `out`) des entsprechenden Parameters in der *formal_parameter_list* von `D`klassifiziert sind.</span><span class="sxs-lookup"><span data-stu-id="463f3-595">The argument list `A` is a list of expressions, each classified as a variable and with the type and modifier (`ref` or `out`) of the corresponding parameter in the *formal_parameter_list* of `D`.</span></span>
    * <span data-ttu-id="463f3-596">Bei den Kandidaten Methoden handelt es sich nur um die Methoden, die in ihrer normalen Form ([anwendbares Funktionsmember](expressions.md#applicable-function-member)) anwendbar sind, nicht die, die nur in der erweiterten Form anwendbar sind.</span><span class="sxs-lookup"><span data-stu-id="463f3-596">The candidate methods considered are only those methods that are applicable in their normal form ([Applicable function member](expressions.md#applicable-function-member)), not those applicable only in their expanded form.</span></span>
*  <span data-ttu-id="463f3-597">Wenn der Algorithmus von [Methoden](expressions.md#method-invocations) aufrufen einen Fehler erzeugt, tritt ein Kompilierzeitfehler auf.</span><span class="sxs-lookup"><span data-stu-id="463f3-597">If the algorithm of [Method invocations](expressions.md#method-invocations) produces an error, then a compile-time error occurs.</span></span> <span data-ttu-id="463f3-598">Andernfalls erzeugt der Algorithmus eine einzige beste Methode `M` die gleiche Anzahl von Parametern wie `D` haben, und die Konvertierung wird als vorhanden betrachtet.</span><span class="sxs-lookup"><span data-stu-id="463f3-598">Otherwise the algorithm produces a single best method `M` having the same number of parameters as `D` and the conversion is considered to exist.</span></span>
*  <span data-ttu-id="463f3-599">Die ausgewählte Methode `M` muss kompatibel sein ([delegatkompatibilität](delegates.md#delegate-compatibility)) mit dem Delegattyp `D`, oder andernfalls tritt ein Kompilierzeitfehler auf.</span><span class="sxs-lookup"><span data-stu-id="463f3-599">The selected method `M` must be compatible ([Delegate compatibility](delegates.md#delegate-compatibility)) with the delegate type `D`, or otherwise, a compile-time error occurs.</span></span>
*  <span data-ttu-id="463f3-600">Wenn die ausgewählte Methode `M` eine Instanzmethode ist, bestimmt der Instanzausdruck, der `E` zugeordnet ist, das Zielobjekt des Delegaten.</span><span class="sxs-lookup"><span data-stu-id="463f3-600">If the selected method `M` is an instance method, the instance expression associated with `E` determines the target object of the delegate.</span></span>
*  <span data-ttu-id="463f3-601">Wenn die ausgewählte Methode M eine Erweiterungsmethode ist, die mithilfe eines Element Zugriffs auf einen Instanzausdruck bezeichnet wird, bestimmt dieser Instanzausdruck das Zielobjekt des Delegaten.</span><span class="sxs-lookup"><span data-stu-id="463f3-601">If the selected method M is an extension method which is denoted by means of a member access on an instance expression, that instance expression determines the target object of the delegate.</span></span>
*  <span data-ttu-id="463f3-602">Das Ergebnis der Konvertierung ist ein Wert vom Typ `D`, nämlich ein neu erstellter Delegat, der auf die ausgewählte Methode und das ausgewählte Zielobjekt verweist.</span><span class="sxs-lookup"><span data-stu-id="463f3-602">The result of the conversion is a value of type `D`, namely a newly created delegate that refers to the selected method and target object.</span></span>
*  <span data-ttu-id="463f3-603">Beachten Sie, dass dieser Prozess zur Erstellung eines Delegaten zu einer Erweiterungsmethode führen kann, wenn der Algorithmus von [Methoden](expressions.md#method-invocations) aufrufen keine Instanzmethode findet, sondern den Aufruf von `E(A)` als Erweiterungs Methodenaufruf ([Erweiterungs Methodenaufrufe](expressions.md#extension-method-invocations)) erfolgreich verarbeitet.</span><span class="sxs-lookup"><span data-stu-id="463f3-603">Note that this process can lead to the creation of a delegate to an extension method, if the algorithm of [Method invocations](expressions.md#method-invocations) fails to find an instance method but succeeds in processing the invocation of `E(A)` as an extension method invocation ([Extension method invocations](expressions.md#extension-method-invocations)).</span></span> <span data-ttu-id="463f3-604">Ein Delegat, der auf diese Weise erstellt wurde, erfasst sowohl die Erweiterungsmethode als auch das erste Argument.</span><span class="sxs-lookup"><span data-stu-id="463f3-604">A delegate thus created captures the extension method as well as its first argument.</span></span>

<span data-ttu-id="463f3-605">Im folgenden Beispiel werden Methoden Gruppen Konvertierungen veranschaulicht:</span><span class="sxs-lookup"><span data-stu-id="463f3-605">The following example demonstrates method group conversions:</span></span>
```csharp
delegate string D1(object o);

delegate object D2(string s);

delegate object D3();

delegate string D4(object o, params object[] a);

delegate string D5(int i);

class Test
{
    static string F(object o) {...}

    static void G() {
        D1 d1 = F;            // Ok
        D2 d2 = F;            // Ok
        D3 d3 = F;            // Error -- not applicable
        D4 d4 = F;            // Error -- not applicable in normal form
        D5 d5 = F;            // Error -- applicable but not compatible

    }
}
```

<span data-ttu-id="463f3-606">Durch die Zuweisung zu `d1` wird die `F` der Methoden Gruppe implizit in einen Wert vom Typ `D1`konvertiert.</span><span class="sxs-lookup"><span data-stu-id="463f3-606">The assignment to `d1` implicitly converts the method group `F` to a value of type `D1`.</span></span>

<span data-ttu-id="463f3-607">Die Zuweisung zu `d2` zeigt, wie es möglich ist, einen Delegaten für eine Methode zu erstellen, die weniger abgeleitete Parametertypen (kontra Variant) und einen stärker abgeleiteten (kovarianten) Rückgabetyp aufweist.</span><span class="sxs-lookup"><span data-stu-id="463f3-607">The assignment to `d2` shows how it is possible to create a delegate to a method that has less derived (contravariant) parameter types and a more derived (covariant) return type.</span></span>

<span data-ttu-id="463f3-608">Die Zuweisung zu `d3` zeigt, wie keine Konvertierung vorhanden ist, wenn die Methode nicht anwendbar ist.</span><span class="sxs-lookup"><span data-stu-id="463f3-608">The assignment to `d3` shows how no conversion exists if the method is not applicable.</span></span>

<span data-ttu-id="463f3-609">Die Zuweisung zu `d4` zeigt, wie die Methode in ihrer normalen Form anwendbar sein muss.</span><span class="sxs-lookup"><span data-stu-id="463f3-609">The assignment to `d4` shows how the method must be applicable in its normal form.</span></span>

<span data-ttu-id="463f3-610">Die Zuweisung zu `d5` zeigt, wie Parameter und Rückgabe Typen des Delegaten und der Methode nur für Verweis Typen unterschiedlich sein dürfen.</span><span class="sxs-lookup"><span data-stu-id="463f3-610">The assignment to `d5` shows how parameter and return types of the delegate and method are allowed to differ only for reference types.</span></span>

<span data-ttu-id="463f3-611">Wie bei allen anderen impliziten und expliziten Konvertierungen kann der Cast-Operator verwendet werden, um eine Konvertierung der Methoden Gruppe explizit auszuführen.</span><span class="sxs-lookup"><span data-stu-id="463f3-611">As with all other implicit and explicit conversions, the cast operator can be used to explicitly perform a method group conversion.</span></span> <span data-ttu-id="463f3-612">Das Beispiel</span><span class="sxs-lookup"><span data-stu-id="463f3-612">Thus, the example</span></span>
```csharp
object obj = new EventHandler(myDialog.OkClick);
```
<span data-ttu-id="463f3-613">Stattdessen können Sie schreiben.</span><span class="sxs-lookup"><span data-stu-id="463f3-613">could instead be written</span></span>
```csharp
object obj = (EventHandler)myDialog.OkClick;
```

<span data-ttu-id="463f3-614">Methoden Gruppen können die Überladungs Auflösung beeinflussen und am Typrückschluss teilnehmen.</span><span class="sxs-lookup"><span data-stu-id="463f3-614">Method groups may influence overload resolution, and participate in type inference.</span></span> <span data-ttu-id="463f3-615">Weitere Informationen finden Sie unter [Funktionsmember](expressions.md#function-members) .</span><span class="sxs-lookup"><span data-stu-id="463f3-615">See [Function members](expressions.md#function-members) for further details.</span></span>

<span data-ttu-id="463f3-616">Die Lauf Zeit Auswertung einer Methoden Gruppen Konvertierung verläuft wie folgt:</span><span class="sxs-lookup"><span data-stu-id="463f3-616">The run-time evaluation of a method group conversion proceeds as follows:</span></span>

*  <span data-ttu-id="463f3-617">Wenn die zur Kompilierzeit ausgewählte Methode eine Instanzmethode ist oder es sich um eine Erweiterungsmethode handelt, auf die als Instanzmethode zugegriffen wird, wird das Zielobjekt des Delegaten aus dem Instanzausdruck bestimmt, der `E`zugeordnet ist:</span><span class="sxs-lookup"><span data-stu-id="463f3-617">If the method selected at compile-time is an instance method, or it is an extension method which is accessed as an instance method, the target object of the delegate is determined from the instance expression associated with `E`:</span></span>
    * <span data-ttu-id="463f3-618">Der Instanzausdruck wird ausgewertet.</span><span class="sxs-lookup"><span data-stu-id="463f3-618">The instance expression is evaluated.</span></span> <span data-ttu-id="463f3-619">Wenn diese Auswertung eine Ausnahme verursacht, werden keine weiteren Schritte ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="463f3-619">If this evaluation causes an exception, no further steps are executed.</span></span>
    * <span data-ttu-id="463f3-620">Wenn der Instanzausdruck eine *reference_type*ist, wird der durch den Instanzausdruck berechnete Wert zum Zielobjekt.</span><span class="sxs-lookup"><span data-stu-id="463f3-620">If the instance expression is of a *reference_type*, the value computed by the instance expression becomes the target object.</span></span> <span data-ttu-id="463f3-621">Wenn die ausgewählte Methode eine Instanzmethode ist und das Zielobjekt `null`ist, wird eine `System.NullReferenceException` ausgelöst, und es werden keine weiteren Schritte ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="463f3-621">If the selected method is an instance method and the target object is `null`, a `System.NullReferenceException` is thrown and no further steps are executed.</span></span>
    * <span data-ttu-id="463f3-622">Wenn der Instanzausdruck eine *value_type*ist, wird ein Boxing-Vorgang ([Boxing-Konvertierungen](types.md#boxing-conversions)) ausgeführt, um den Wert in ein Objekt zu konvertieren, und dieses Objekt wird zum Zielobjekt.</span><span class="sxs-lookup"><span data-stu-id="463f3-622">If the instance expression is of a *value_type*, a boxing operation ([Boxing conversions](types.md#boxing-conversions)) is performed to convert the value to an object, and this object becomes the target object.</span></span>
*  <span data-ttu-id="463f3-623">Andernfalls ist die ausgewählte Methode Teil eines statischen Methoden Aufrufes, und das Zielobjekt des Delegaten wird `null`.</span><span class="sxs-lookup"><span data-stu-id="463f3-623">Otherwise the selected method is part of a static method call, and the target object of the delegate is `null`.</span></span>
*  <span data-ttu-id="463f3-624">Eine neue Instanz des Delegattyps `D` zugeordnet wird.</span><span class="sxs-lookup"><span data-stu-id="463f3-624">A new instance of the delegate type `D` is allocated.</span></span> <span data-ttu-id="463f3-625">Wenn nicht genügend Arbeitsspeicher zum Zuordnen der neuen Instanz verfügbar ist, wird ein `System.OutOfMemoryException` ausgelöst, und es werden keine weiteren Schritte ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="463f3-625">If there is not enough memory available to allocate the new instance, a `System.OutOfMemoryException` is thrown and no further steps are executed.</span></span>
*  <span data-ttu-id="463f3-626">Die neue Delegatinstanz wird mit einem Verweis auf die Methode initialisiert, die zur Kompilierzeit bestimmt wurde, und ein Verweis auf das oben berechnete Zielobjekt.</span><span class="sxs-lookup"><span data-stu-id="463f3-626">The new delegate instance is initialized with a reference to the method that was determined at compile-time and a reference to the target object computed above.</span></span>
